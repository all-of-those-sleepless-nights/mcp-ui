<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <style>/*! tailwindcss v4.1.15 | MIT License | https://tailwindcss.com */
@layer properties;
@layer theme, base, components, utilities;
@layer theme {
  :root, :host {
    --font-sans: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",
      "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
      "Courier New", monospace;
    --color-red-200: oklch(88.5% 0.062 18.334);
    --color-red-400: oklch(70.4% 0.191 22.216);
    --color-red-500: oklch(63.7% 0.237 25.331);
    --color-emerald-200: oklch(90.5% 0.093 164.15);
    --color-emerald-300: oklch(84.5% 0.143 164.978);
    --color-emerald-400: oklch(76.5% 0.177 163.223);
    --color-emerald-500: oklch(69.6% 0.17 162.48);
    --color-slate-100: oklch(96.8% 0.007 247.896);
    --color-slate-200: oklch(92.9% 0.013 255.508);
    --color-slate-300: oklch(86.9% 0.022 252.894);
    --color-slate-400: oklch(70.4% 0.04 256.788);
    --color-slate-500: oklch(55.4% 0.046 257.417);
    --color-slate-600: oklch(44.6% 0.043 257.281);
    --color-slate-700: oklch(37.2% 0.044 257.287);
    --color-slate-800: oklch(27.9% 0.041 260.031);
    --color-slate-900: oklch(20.8% 0.042 265.755);
    --color-slate-950: oklch(12.9% 0.042 264.695);
    --color-black: #000;
    --color-white: #fff;
    --spacing: 0.25rem;
    --container-2xl: 42rem;
    --container-4xl: 56rem;
    --text-xs: 0.75rem;
    --text-xs--line-height: calc(1 / 0.75);
    --text-sm: 0.875rem;
    --text-sm--line-height: calc(1.25 / 0.875);
    --text-base: 1rem;
    --text-base--line-height: calc(1.5 / 1);
    --text-lg: 1.125rem;
    --text-lg--line-height: calc(1.75 / 1.125);
    --text-xl: 1.25rem;
    --text-xl--line-height: calc(1.75 / 1.25);
    --text-2xl: 1.5rem;
    --text-2xl--line-height: calc(2 / 1.5);
    --text-4xl: 2.25rem;
    --text-4xl--line-height: calc(2.5 / 2.25);
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --tracking-wide: 0.025em;
    --radius-lg: 0.5rem;
    --radius-xl: 0.75rem;
    --radius-2xl: 1rem;
    --radius-3xl: 1.5rem;
    --default-transition-duration: 150ms;
    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    --default-font-family: var(--font-sans);
    --default-mono-font-family: var(--font-mono);
  }
}
@layer base {
  *, ::after, ::before, ::backdrop, ::file-selector-button {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0 solid;
  }
  html, :host {
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -moz-tab-size: 4;
      -o-tab-size: 4;
         tab-size: 4;
    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
    font-feature-settings: var(--default-font-feature-settings, normal);
    font-variation-settings: var(--default-font-variation-settings, normal);
    -webkit-tap-highlight-color: transparent;
  }
  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }
  abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }
  h1, h2, h3, h4, h5, h6 {
    font-size: inherit;
    font-weight: inherit;
  }
  a {
    color: inherit;
    -webkit-text-decoration: inherit;
    text-decoration: inherit;
  }
  b, strong {
    font-weight: bolder;
  }
  code, kbd, samp, pre {
    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    font-feature-settings: var(--default-mono-font-feature-settings, normal);
    font-variation-settings: var(--default-mono-font-variation-settings, normal);
    font-size: 1em;
  }
  small {
    font-size: 80%;
  }
  sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  sub {
    bottom: -0.25em;
  }
  sup {
    top: -0.5em;
  }
  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }
  :-moz-focusring {
    outline: auto;
  }
  progress {
    vertical-align: baseline;
  }
  summary {
    display: list-item;
  }
  ol, ul, menu {
    list-style: none;
  }
  img, svg, video, canvas, audio, iframe, embed, object {
    display: block;
    vertical-align: middle;
  }
  img, video {
    max-width: 100%;
    height: auto;
  }
  button, input, select, optgroup, textarea, ::file-selector-button {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    border-radius: 0;
    background-color: transparent;
    opacity: 1;
  }
  :where(select:is([multiple], [size])) optgroup {
    font-weight: bolder;
  }
  :where(select:is([multiple], [size])) optgroup option {
    padding-inline-start: 20px;
  }
  ::file-selector-button {
    margin-inline-end: 4px;
  }
  ::-moz-placeholder {
    opacity: 1;
  }
  ::placeholder {
    opacity: 1;
  }
  @supports (not (-webkit-appearance: -apple-pay-button))  or (contain-intrinsic-size: 1px) {
    ::-moz-placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        & {
          color: color-mix(in oklab, currentcolor 50%, transparent);
        }
      }
    }
    ::placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        & {
          color: color-mix(in oklab, currentcolor 50%, transparent);
        }
      }
    }
  }
  textarea {
    resize: vertical;
  }
  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }
  ::-webkit-date-and-time-value {
    min-height: 1lh;
    text-align: inherit;
  }
  ::-webkit-datetime-edit {
    display: inline-flex;
  }
  ::-webkit-datetime-edit-fields-wrapper {
    padding: 0;
  }
  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {
    padding-block: 0;
  }
  ::-webkit-calendar-picker-indicator {
    line-height: 1;
  }
  :-moz-ui-invalid {
    box-shadow: none;
  }
  button, input:where([type="button"], [type="reset"], [type="submit"]), ::file-selector-button {
    -webkit-appearance: button;
       -moz-appearance: button;
            appearance: button;
  }
  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
    height: auto;
  }
  [hidden]:where(:not([hidden="until-found"])) {
    display: none !important;
  }
}
@layer utilities {
  .\@container {
    container-type: inline-size;
  }
  .pointer-events-auto {
    pointer-events: auto;
  }
  .pointer-events-none {
    pointer-events: none;
  }
  .visible {
    visibility: visible;
  }
  .absolute {
    position: absolute;
  }
  .fixed {
    position: fixed;
  }
  .relative {
    position: relative;
  }
  .static {
    position: static;
  }
  .inset-0 {
    inset: calc(var(--spacing) * 0);
  }
  .top-4 {
    top: calc(var(--spacing) * 4);
  }
  .right-0 {
    right: calc(var(--spacing) * 0);
  }
  .right-4 {
    right: calc(var(--spacing) * 4);
  }
  .bottom-0 {
    bottom: calc(var(--spacing) * 0);
  }
  .bottom-4 {
    bottom: calc(var(--spacing) * 4);
  }
  .left-0 {
    left: calc(var(--spacing) * 0);
  }
  .left-4 {
    left: calc(var(--spacing) * 4);
  }
  .container {
    width: 100%;
    @media (width >= 40rem) {
      max-width: 40rem;
    }
    @media (width >= 48rem) {
      max-width: 48rem;
    }
    @media (width >= 64rem) {
      max-width: 64rem;
    }
    @media (width >= 80rem) {
      max-width: 80rem;
    }
    @media (width >= 96rem) {
      max-width: 96rem;
    }
  }
  .m-0 {
    margin: calc(var(--spacing) * 0);
  }
  .mt-1 {
    margin-top: calc(var(--spacing) * 1);
  }
  .mt-2 {
    margin-top: calc(var(--spacing) * 2);
  }
  .mt-3 {
    margin-top: calc(var(--spacing) * 3);
  }
  .mt-4 {
    margin-top: calc(var(--spacing) * 4);
  }
  .mb-2 {
    margin-bottom: calc(var(--spacing) * 2);
  }
  .mb-3 {
    margin-bottom: calc(var(--spacing) * 3);
  }
  .mb-4 {
    margin-bottom: calc(var(--spacing) * 4);
  }
  .mb-8 {
    margin-bottom: calc(var(--spacing) * 8);
  }
  .block {
    display: block;
  }
  .contents {
    display: contents;
  }
  .flex {
    display: flex;
  }
  .grid {
    display: grid;
  }
  .hidden {
    display: none;
  }
  .inline {
    display: inline;
  }
  .inline-block {
    display: inline-block;
  }
  .inline-flex {
    display: inline-flex;
  }
  .table {
    display: table;
  }
  .h-9 {
    height: calc(var(--spacing) * 9);
  }
  .h-10 {
    height: calc(var(--spacing) * 10);
  }
  .h-11 {
    height: calc(var(--spacing) * 11);
  }
  .h-12 {
    height: calc(var(--spacing) * 12);
  }
  .h-16 {
    height: calc(var(--spacing) * 16);
  }
  .h-48 {
    height: calc(var(--spacing) * 48);
  }
  .h-96 {
    height: calc(var(--spacing) * 96);
  }
  .h-\[360px\] {
    height: 360px;
  }
  .h-full {
    height: 100%;
  }
  .max-h-\[420px\] {
    max-height: 420px;
  }
  .min-h-\[480px\] {
    min-height: 480px;
  }
  .min-h-full {
    min-height: 100%;
  }
  .w-9 {
    width: calc(var(--spacing) * 9);
  }
  .w-12 {
    width: calc(var(--spacing) * 12);
  }
  .w-16 {
    width: calc(var(--spacing) * 16);
  }
  .w-full {
    width: 100%;
  }
  .max-w-2xl {
    max-width: var(--container-2xl);
  }
  .max-w-4xl {
    max-width: var(--container-4xl);
  }
  .max-w-\[260px\] {
    max-width: 260px;
  }
  .max-w-\[320px\] {
    max-width: 320px;
  }
  .min-w-\[120px\] {
    min-width: 120px;
  }
  .min-w-\[220px\] {
    min-width: 220px;
  }
  .min-w-\[280px\] {
    min-width: 280px;
  }
  .flex-shrink {
    flex-shrink: 1;
  }
  .flex-shrink-0 {
    flex-shrink: 0;
  }
  .flex-grow {
    flex-grow: 1;
  }
  .border-collapse {
    border-collapse: collapse;
  }
  .transform {
    transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);
  }
  .cursor-pointer {
    cursor: pointer;
  }
  .resize {
    resize: both;
  }
  .flex-col {
    flex-direction: column;
  }
  .flex-wrap {
    flex-wrap: wrap;
  }
  .items-center {
    align-items: center;
  }
  .items-start {
    align-items: flex-start;
  }
  .justify-between {
    justify-content: space-between;
  }
  .justify-center {
    justify-content: center;
  }
  .justify-start {
    justify-content: flex-start;
  }
  .gap-0 {
    gap: calc(var(--spacing) * 0);
  }
  .gap-2 {
    gap: calc(var(--spacing) * 2);
  }
  .gap-3 {
    gap: calc(var(--spacing) * 3);
  }
  .gap-4 {
    gap: calc(var(--spacing) * 4);
  }
  .space-y-1 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-2 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-3 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 3) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-4 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-5 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 5) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 5) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-6 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .overflow-hidden {
    overflow: hidden;
  }
  .overflow-x-auto {
    overflow-x: auto;
  }
  .overflow-y-auto {
    overflow-y: auto;
  }
  .rounded {
    border-radius: 0.25rem;
  }
  .rounded-2xl {
    border-radius: var(--radius-2xl);
  }
  .rounded-3xl {
    border-radius: var(--radius-3xl);
  }
  .rounded-full {
    border-radius: calc(infinity * 1px);
  }
  .rounded-lg {
    border-radius: var(--radius-lg);
  }
  .rounded-xl {
    border-radius: var(--radius-xl);
  }
  .border {
    border-style: var(--tw-border-style);
    border-width: 1px;
  }
  .border-t {
    border-top-style: var(--tw-border-style);
    border-top-width: 1px;
  }
  .border-emerald-400 {
    border-color: var(--color-emerald-400);
  }
  .border-emerald-500 {
    border-color: var(--color-emerald-500);
  }
  .border-emerald-500\/50 {
    border-color: color-mix(in srgb, oklch(69.6% 0.17 162.48) 50%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        border-color: color-mix(in oklab, var(--color-emerald-500) 50%, transparent);
      }
    }
  }
  .border-red-500 {
    border-color: var(--color-red-500);
  }
  .border-red-500\/40 {
    border-color: color-mix(in srgb, oklch(63.7% 0.237 25.331) 40%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        border-color: color-mix(in oklab, var(--color-red-500) 40%, transparent);
      }
    }
  }
  .border-slate-600 {
    border-color: var(--color-slate-600);
  }
  .border-slate-700 {
    border-color: var(--color-slate-700);
  }
  .border-slate-800 {
    border-color: var(--color-slate-800);
  }
  .bg-black {
    background-color: var(--color-black);
  }
  .bg-black\/30 {
    background-color: color-mix(in srgb, #000 30%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-black) 30%, transparent);
      }
    }
  }
  .bg-black\/40 {
    background-color: color-mix(in srgb, #000 40%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-black) 40%, transparent);
      }
    }
  }
  .bg-emerald-500 {
    background-color: var(--color-emerald-500);
  }
  .bg-emerald-500\/10 {
    background-color: color-mix(in srgb, oklch(69.6% 0.17 162.48) 10%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-emerald-500) 10%, transparent);
      }
    }
  }
  .bg-emerald-500\/90 {
    background-color: color-mix(in srgb, oklch(69.6% 0.17 162.48) 90%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-emerald-500) 90%, transparent);
      }
    }
  }
  .bg-red-500 {
    background-color: var(--color-red-500);
  }
  .bg-red-500\/10 {
    background-color: color-mix(in srgb, oklch(63.7% 0.237 25.331) 10%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-red-500) 10%, transparent);
      }
    }
  }
  .bg-slate-800 {
    background-color: var(--color-slate-800);
  }
  .bg-slate-900 {
    background-color: var(--color-slate-900);
  }
  .bg-slate-900\/40 {
    background-color: color-mix(in srgb, oklch(20.8% 0.042 265.755) 40%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-900) 40%, transparent);
      }
    }
  }
  .bg-slate-900\/60 {
    background-color: color-mix(in srgb, oklch(20.8% 0.042 265.755) 60%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-900) 60%, transparent);
      }
    }
  }
  .bg-slate-900\/70 {
    background-color: color-mix(in srgb, oklch(20.8% 0.042 265.755) 70%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-900) 70%, transparent);
      }
    }
  }
  .bg-slate-900\/80 {
    background-color: color-mix(in srgb, oklch(20.8% 0.042 265.755) 80%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-900) 80%, transparent);
      }
    }
  }
  .bg-slate-950 {
    background-color: var(--color-slate-950);
  }
  .bg-slate-950\/70 {
    background-color: color-mix(in srgb, oklch(12.9% 0.042 264.695) 70%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-950) 70%, transparent);
      }
    }
  }
  .bg-slate-950\/80 {
    background-color: color-mix(in srgb, oklch(12.9% 0.042 264.695) 80%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        background-color: color-mix(in oklab, var(--color-slate-950) 80%, transparent);
      }
    }
  }
  .bg-transparent {
    background-color: transparent;
  }
  .bg-gradient-to-br {
    --tw-gradient-position: to bottom right in oklab;
    background-image: linear-gradient(var(--tw-gradient-stops));
  }
  .bg-gradient-to-t {
    --tw-gradient-position: to top in oklab;
    background-image: linear-gradient(var(--tw-gradient-stops));
  }
  .from-black {
    --tw-gradient-from: var(--color-black);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .from-black\/80 {
    --tw-gradient-from: color-mix(in srgb, #000 80%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        --tw-gradient-from: color-mix(in oklab, var(--color-black) 80%, transparent);
      }
    }
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .from-slate-900 {
    --tw-gradient-from: var(--color-slate-900);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .to-slate-700 {
    --tw-gradient-to: var(--color-slate-700);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .to-transparent {
    --tw-gradient-to: transparent;
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .object-cover {
    -o-object-fit: cover;
       object-fit: cover;
  }
  .p-2 {
    padding: calc(var(--spacing) * 2);
  }
  .p-4 {
    padding: calc(var(--spacing) * 4);
  }
  .p-5 {
    padding: calc(var(--spacing) * 5);
  }
  .p-6 {
    padding: calc(var(--spacing) * 6);
  }
  .p-8 {
    padding: calc(var(--spacing) * 8);
  }
  .px-3 {
    padding-inline: calc(var(--spacing) * 3);
  }
  .px-4 {
    padding-inline: calc(var(--spacing) * 4);
  }
  .px-5 {
    padding-inline: calc(var(--spacing) * 5);
  }
  .py-1 {
    padding-block: calc(var(--spacing) * 1);
  }
  .py-1\.5 {
    padding-block: calc(var(--spacing) * 1.5);
  }
  .py-2 {
    padding-block: calc(var(--spacing) * 2);
  }
  .py-3 {
    padding-block: calc(var(--spacing) * 3);
  }
  .py-4 {
    padding-block: calc(var(--spacing) * 4);
  }
  .py-6 {
    padding-block: calc(var(--spacing) * 6);
  }
  .pb-2 {
    padding-bottom: calc(var(--spacing) * 2);
  }
  .pb-3 {
    padding-bottom: calc(var(--spacing) * 3);
  }
  .pb-4 {
    padding-bottom: calc(var(--spacing) * 4);
  }
  .text-center {
    text-align: center;
  }
  .text-justify {
    text-align: justify;
  }
  .text-right {
    text-align: right;
  }
  .font-mono {
    font-family: var(--font-mono);
  }
  .font-sans {
    font-family: var(--font-sans);
  }
  .text-2xl {
    font-size: var(--text-2xl);
    line-height: var(--tw-leading, var(--text-2xl--line-height));
  }
  .text-4xl {
    font-size: var(--text-4xl);
    line-height: var(--tw-leading, var(--text-4xl--line-height));
  }
  .text-base {
    font-size: var(--text-base);
    line-height: var(--tw-leading, var(--text-base--line-height));
  }
  .text-lg {
    font-size: var(--text-lg);
    line-height: var(--tw-leading, var(--text-lg--line-height));
  }
  .text-sm {
    font-size: var(--text-sm);
    line-height: var(--tw-leading, var(--text-sm--line-height));
  }
  .text-xl {
    font-size: var(--text-xl);
    line-height: var(--tw-leading, var(--text-xl--line-height));
  }
  .text-xs {
    font-size: var(--text-xs);
    line-height: var(--tw-leading, var(--text-xs--line-height));
  }
  .font-bold {
    --tw-font-weight: var(--font-weight-bold);
    font-weight: var(--font-weight-bold);
  }
  .font-medium {
    --tw-font-weight: var(--font-weight-medium);
    font-weight: var(--font-weight-medium);
  }
  .font-semibold {
    --tw-font-weight: var(--font-weight-semibold);
    font-weight: var(--font-weight-semibold);
  }
  .tracking-wide {
    --tw-tracking: var(--tracking-wide);
    letter-spacing: var(--tracking-wide);
  }
  .text-wrap {
    text-wrap: wrap;
  }
  .text-emerald-200 {
    color: var(--color-emerald-200);
  }
  .text-emerald-300 {
    color: var(--color-emerald-300);
  }
  .text-red-200 {
    color: var(--color-red-200);
  }
  .text-red-400 {
    color: var(--color-red-400);
  }
  .text-slate-100 {
    color: var(--color-slate-100);
  }
  .text-slate-200 {
    color: var(--color-slate-200);
  }
  .text-slate-300 {
    color: var(--color-slate-300);
  }
  .text-slate-400 {
    color: var(--color-slate-400);
  }
  .text-slate-500 {
    color: var(--color-slate-500);
  }
  .text-slate-950 {
    color: var(--color-slate-950);
  }
  .text-white {
    color: var(--color-white);
  }
  .lowercase {
    text-transform: lowercase;
  }
  .uppercase {
    text-transform: uppercase;
  }
  .underline {
    text-decoration-line: underline;
  }
  .antialiased {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  .shadow {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-2xl {
    --tw-shadow: 0 25px 50px -12px var(--tw-shadow-color, rgb(0 0 0 / 0.25));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-lg {
    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-sm {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-xl {
    --tw-shadow: 0 20px 25px -5px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 8px 10px -6px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-black {
    --tw-shadow-color: #000;
    @supports (color: color-mix(in lab, red, red)) {
      & {
        --tw-shadow-color: color-mix(in oklab, var(--color-black) var(--tw-shadow-alpha), transparent);
      }
    }
  }
  .shadow-black\/30 {
    --tw-shadow-color: color-mix(in srgb, #000 30%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      & {
        --tw-shadow-color: color-mix(in oklab, color-mix(in oklab, var(--color-black) 30%, transparent) var(--tw-shadow-alpha), transparent);
      }
    }
  }
  .outline {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }
  .blur {
    --tw-blur: blur(8px);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .grayscale {
    --tw-grayscale: grayscale(100%);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .invert {
    --tw-invert: invert(100%);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .filter {
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .backdrop-blur {
    --tw-backdrop-blur: blur(8px);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .backdrop-filter {
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .transition {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, backdrop-filter, display, content-visibility, overlay, pointer-events;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-colors {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .hover\:border-emerald-300 {
    &:hover {
      @media (hover: hover) {
        border-color: var(--color-emerald-300);
      }
    }
  }
  .hover\:border-emerald-400 {
    &:hover {
      @media (hover: hover) {
        border-color: var(--color-emerald-400);
      }
    }
  }
  .hover\:bg-emerald-400 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-emerald-400);
      }
    }
  }
  .hover\:bg-red-400 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-red-400);
      }
    }
  }
  .hover\:bg-slate-700 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-slate-700);
      }
    }
  }
  .hover\:bg-slate-800 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-slate-800);
      }
    }
  }
  .hover\:text-emerald-300 {
    &:hover {
      @media (hover: hover) {
        color: var(--color-emerald-300);
      }
    }
  }
  .focus\:border-emerald-400 {
    &:focus {
      border-color: var(--color-emerald-400);
    }
  }
  .focus\:outline-none {
    &:focus {
      --tw-outline-style: none;
      outline-style: none;
    }
  }
  .focus-visible\:ring-2 {
    &:focus-visible {
      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }
  .focus-visible\:ring-emerald-400 {
    &:focus-visible {
      --tw-ring-color: var(--color-emerald-400);
    }
  }
  .focus-visible\:ring-offset-2 {
    &:focus-visible {
      --tw-ring-offset-width: 2px;
      --tw-ring-offset-shadow: var(--tw-ring-inset,) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
    }
  }
  .focus-visible\:ring-offset-slate-950 {
    &:focus-visible {
      --tw-ring-offset-color: var(--color-slate-950);
    }
  }
  .sm\:grid-cols-2 {
    @media (width >= 40rem) {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  .md\:h-\[420px\] {
    @media (width >= 48rem) {
      height: 420px;
    }
  }
  .md\:grid-cols-\[2\.2fr\,1fr\] {
    @media (width >= 48rem) {
      grid-template-columns: 2.2fr,1fr;
    }
  }
  .md\:border-t-0 {
    @media (width >= 48rem) {
      border-top-style: var(--tw-border-style);
      border-top-width: 0px;
    }
  }
  .md\:border-l {
    @media (width >= 48rem) {
      border-left-style: var(--tw-border-style);
      border-left-width: 1px;
    }
  }
}
@property --tw-rotate-x {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-y {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-z {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-x {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-y {
  syntax: "*";
  inherits: false;
}
@property --tw-space-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-gradient-position {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-via {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-to {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-via-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 0%;
}
@property --tw-gradient-via-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 50%;
}
@property --tw-gradient-to-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-font-weight {
  syntax: "*";
  inherits: false;
}
@property --tw-tracking {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-ring-inset {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0px;
}
@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}
@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-outline-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-sepia {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-drop-shadow-size {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-sepia {
  syntax: "*";
  inherits: false;
}
@layer properties {
  @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {
    *, ::before, ::after, ::backdrop {
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-space-y-reverse: 0;
      --tw-border-style: solid;
      --tw-gradient-position: initial;
      --tw-gradient-from: #0000;
      --tw-gradient-via: #0000;
      --tw-gradient-to: #0000;
      --tw-gradient-stops: initial;
      --tw-gradient-via-stops: initial;
      --tw-gradient-from-position: 0%;
      --tw-gradient-via-position: 50%;
      --tw-gradient-to-position: 100%;
      --tw-font-weight: initial;
      --tw-tracking: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-outline-style: solid;
      --tw-blur: initial;
      --tw-brightness: initial;
      --tw-contrast: initial;
      --tw-grayscale: initial;
      --tw-hue-rotate: initial;
      --tw-invert: initial;
      --tw-opacity: initial;
      --tw-saturate: initial;
      --tw-sepia: initial;
      --tw-drop-shadow: initial;
      --tw-drop-shadow-color: initial;
      --tw-drop-shadow-alpha: 100%;
      --tw-drop-shadow-size: initial;
      --tw-backdrop-blur: initial;
      --tw-backdrop-brightness: initial;
      --tw-backdrop-contrast: initial;
      --tw-backdrop-grayscale: initial;
      --tw-backdrop-hue-rotate: initial;
      --tw-backdrop-invert: initial;
      --tw-backdrop-opacity: initial;
      --tw-backdrop-saturate: initial;
      --tw-backdrop-sepia: initial;
    }
  }
}

</style>
  <style>/* node_modules/@mantine/core/styles.css */
:root {
  color-scheme: var(--mantine-color-scheme);
}
*,
*::before,
*::after {
  box-sizing: border-box;
}
input,
button,
textarea,
select {
  font: inherit;
}
button,
select {
  text-transform: none;
}
body {
  margin: 0;
  font-family: var(--mantine-font-family);
  font-size: var(--mantine-font-size-md);
  line-height: var(--mantine-line-height);
  background-color: var(--mantine-color-body);
  color: var(--mantine-color-text);
  -webkit-font-smoothing: var(--mantine-webkit-font-smoothing);
  -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing);
}
@media screen and (max-device-width: 31.25em) {
  body {
    -webkit-text-size-adjust: 100%;
  }
}
@media (prefers-reduced-motion: reduce) {
  [data-respect-reduced-motion] [data-reduce-motion] {
    transition: none;
    animation: none;
  }
}
[data-mantine-color-scheme=light] .mantine-light-hidden {
  display: none;
}
[data-mantine-color-scheme=dark] .mantine-dark-hidden {
  display: none;
}
.mantine-focus-auto:focus-visible {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.mantine-focus-always:focus {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.mantine-focus-never:focus {
  outline: none;
}
.mantine-active:active {
  transform: translateY(calc(0.0625rem * var(--mantine-scale)));
}
fieldset:disabled .mantine-active:active {
  transform: none;
}
:where([dir=rtl]) .mantine-rotate-rtl {
  transform: rotate(180deg);
}
:root {
  --mantine-z-index-app: 100;
  --mantine-z-index-modal: 200;
  --mantine-z-index-popover: 300;
  --mantine-z-index-overlay: 400;
  --mantine-z-index-max: 9999;
  --mantine-scale: 1;
  --mantine-cursor-type: default;
  --mantine-webkit-font-smoothing: antialiased;
  --mantine-moz-font-smoothing: grayscale;
  --mantine-color-white: #fff;
  --mantine-color-black: #000;
  --mantine-line-height: 1.55;
  --mantine-font-family:
    -apple-system,
    BlinkMacSystemFont,
    Segoe UI,
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    Apple Color Emoji,
    Segoe UI Emoji;
  --mantine-font-family-monospace:
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Monaco,
    Consolas,
    Liberation Mono,
    Courier New,
    monospace;
  --mantine-font-family-headings:
    -apple-system,
    BlinkMacSystemFont,
    Segoe UI,
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    Apple Color Emoji,
    Segoe UI Emoji;
  --mantine-heading-font-weight: 700;
  --mantine-heading-text-wrap: wrap;
  --mantine-radius-default: calc(0.25rem * var(--mantine-scale));
  --mantine-primary-color-filled: var(--mantine-color-blue-filled);
  --mantine-primary-color-filled-hover: var(--mantine-color-blue-filled-hover);
  --mantine-primary-color-light: var(--mantine-color-blue-light);
  --mantine-primary-color-light-hover: var(--mantine-color-blue-light-hover);
  --mantine-primary-color-light-color: var(--mantine-color-blue-light-color);
  --mantine-breakpoint-xs: 36em;
  --mantine-breakpoint-sm: 48em;
  --mantine-breakpoint-md: 62em;
  --mantine-breakpoint-lg: 75em;
  --mantine-breakpoint-xl: 88em;
  --mantine-spacing-xs: calc(0.625rem * var(--mantine-scale));
  --mantine-spacing-sm: calc(0.75rem * var(--mantine-scale));
  --mantine-spacing-md: calc(1rem * var(--mantine-scale));
  --mantine-spacing-lg: calc(1.25rem * var(--mantine-scale));
  --mantine-spacing-xl: calc(2rem * var(--mantine-scale));
  --mantine-font-size-xs: calc(0.75rem * var(--mantine-scale));
  --mantine-font-size-sm: calc(0.875rem * var(--mantine-scale));
  --mantine-font-size-md: calc(1rem * var(--mantine-scale));
  --mantine-font-size-lg: calc(1.125rem * var(--mantine-scale));
  --mantine-font-size-xl: calc(1.25rem * var(--mantine-scale));
  --mantine-line-height-xs: 1.4;
  --mantine-line-height-sm: 1.45;
  --mantine-line-height-md: 1.55;
  --mantine-line-height-lg: 1.6;
  --mantine-line-height-xl: 1.65;
  --mantine-shadow-xs: 0 calc(0.0625rem * var(--mantine-scale)) calc(0.1875rem * var(--mantine-scale)) rgba(0, 0, 0, 0.05), 0 calc(0.0625rem * var(--mantine-scale)) calc(0.125rem * var(--mantine-scale)) rgba(0, 0, 0, 0.1);
  --mantine-shadow-sm:
    0 calc(0.0625rem * var(--mantine-scale)) calc(0.1875rem * var(--mantine-scale)) rgba(0, 0, 0, 0.05),
    rgba(0, 0, 0, 0.05) 0 calc(0.625rem * var(--mantine-scale)) calc(0.9375rem * var(--mantine-scale)) calc(-0.3125rem * var(--mantine-scale)),
    rgba(0, 0, 0, 0.04) 0 calc(0.4375rem * var(--mantine-scale)) calc(0.4375rem * var(--mantine-scale)) calc(-0.3125rem * var(--mantine-scale));
  --mantine-shadow-md:
    0 calc(0.0625rem * var(--mantine-scale)) calc(0.1875rem * var(--mantine-scale)) rgba(0, 0, 0, 0.05),
    rgba(0, 0, 0, 0.05) 0 calc(1.25rem * var(--mantine-scale)) calc(1.5625rem * var(--mantine-scale)) calc(-0.3125rem * var(--mantine-scale)),
    rgba(0, 0, 0, 0.04) 0 calc(0.625rem * var(--mantine-scale)) calc(0.625rem * var(--mantine-scale)) calc(-0.3125rem * var(--mantine-scale));
  --mantine-shadow-lg:
    0 calc(0.0625rem * var(--mantine-scale)) calc(0.1875rem * var(--mantine-scale)) rgba(0, 0, 0, 0.05),
    rgba(0, 0, 0, 0.05) 0 calc(1.75rem * var(--mantine-scale)) calc(1.4375rem * var(--mantine-scale)) calc(-0.4375rem * var(--mantine-scale)),
    rgba(0, 0, 0, 0.04) 0 calc(0.75rem * var(--mantine-scale)) calc(0.75rem * var(--mantine-scale)) calc(-0.4375rem * var(--mantine-scale));
  --mantine-shadow-xl:
    0 calc(0.0625rem * var(--mantine-scale)) calc(0.1875rem * var(--mantine-scale)) rgba(0, 0, 0, 0.05),
    rgba(0, 0, 0, 0.05) 0 calc(2.25rem * var(--mantine-scale)) calc(1.75rem * var(--mantine-scale)) calc(-0.4375rem * var(--mantine-scale)),
    rgba(0, 0, 0, 0.04) 0 calc(1.0625rem * var(--mantine-scale)) calc(1.0625rem * var(--mantine-scale)) calc(-0.4375rem * var(--mantine-scale));
  --mantine-radius-xs: calc(0.125rem * var(--mantine-scale));
  --mantine-radius-sm: calc(0.25rem * var(--mantine-scale));
  --mantine-radius-md: calc(0.5rem * var(--mantine-scale));
  --mantine-radius-lg: calc(1rem * var(--mantine-scale));
  --mantine-radius-xl: calc(2rem * var(--mantine-scale));
  --mantine-primary-color-0: var(--mantine-color-blue-0);
  --mantine-primary-color-1: var(--mantine-color-blue-1);
  --mantine-primary-color-2: var(--mantine-color-blue-2);
  --mantine-primary-color-3: var(--mantine-color-blue-3);
  --mantine-primary-color-4: var(--mantine-color-blue-4);
  --mantine-primary-color-5: var(--mantine-color-blue-5);
  --mantine-primary-color-6: var(--mantine-color-blue-6);
  --mantine-primary-color-7: var(--mantine-color-blue-7);
  --mantine-primary-color-8: var(--mantine-color-blue-8);
  --mantine-primary-color-9: var(--mantine-color-blue-9);
  --mantine-color-dark-0: #c9c9c9;
  --mantine-color-dark-1: #b8b8b8;
  --mantine-color-dark-2: #828282;
  --mantine-color-dark-3: #696969;
  --mantine-color-dark-4: #424242;
  --mantine-color-dark-5: #3b3b3b;
  --mantine-color-dark-6: #2e2e2e;
  --mantine-color-dark-7: #242424;
  --mantine-color-dark-8: #1f1f1f;
  --mantine-color-dark-9: #141414;
  --mantine-color-gray-0: #f8f9fa;
  --mantine-color-gray-1: #f1f3f5;
  --mantine-color-gray-2: #e9ecef;
  --mantine-color-gray-3: #dee2e6;
  --mantine-color-gray-4: #ced4da;
  --mantine-color-gray-5: #adb5bd;
  --mantine-color-gray-6: #868e96;
  --mantine-color-gray-7: #495057;
  --mantine-color-gray-8: #343a40;
  --mantine-color-gray-9: #212529;
  --mantine-color-red-0: #fff5f5;
  --mantine-color-red-1: #ffe3e3;
  --mantine-color-red-2: #ffc9c9;
  --mantine-color-red-3: #ffa8a8;
  --mantine-color-red-4: #ff8787;
  --mantine-color-red-5: #ff6b6b;
  --mantine-color-red-6: #fa5252;
  --mantine-color-red-7: #f03e3e;
  --mantine-color-red-8: #e03131;
  --mantine-color-red-9: #c92a2a;
  --mantine-color-pink-0: #fff0f6;
  --mantine-color-pink-1: #ffdeeb;
  --mantine-color-pink-2: #fcc2d7;
  --mantine-color-pink-3: #faa2c1;
  --mantine-color-pink-4: #f783ac;
  --mantine-color-pink-5: #f06595;
  --mantine-color-pink-6: #e64980;
  --mantine-color-pink-7: #d6336c;
  --mantine-color-pink-8: #c2255c;
  --mantine-color-pink-9: #a61e4d;
  --mantine-color-grape-0: #f8f0fc;
  --mantine-color-grape-1: #f3d9fa;
  --mantine-color-grape-2: #eebefa;
  --mantine-color-grape-3: #e599f7;
  --mantine-color-grape-4: #da77f2;
  --mantine-color-grape-5: #cc5de8;
  --mantine-color-grape-6: #be4bdb;
  --mantine-color-grape-7: #ae3ec9;
  --mantine-color-grape-8: #9c36b5;
  --mantine-color-grape-9: #862e9c;
  --mantine-color-violet-0: #f3f0ff;
  --mantine-color-violet-1: #e5dbff;
  --mantine-color-violet-2: #d0bfff;
  --mantine-color-violet-3: #b197fc;
  --mantine-color-violet-4: #9775fa;
  --mantine-color-violet-5: #845ef7;
  --mantine-color-violet-6: #7950f2;
  --mantine-color-violet-7: #7048e8;
  --mantine-color-violet-8: #6741d9;
  --mantine-color-violet-9: #5f3dc4;
  --mantine-color-indigo-0: #edf2ff;
  --mantine-color-indigo-1: #dbe4ff;
  --mantine-color-indigo-2: #bac8ff;
  --mantine-color-indigo-3: #91a7ff;
  --mantine-color-indigo-4: #748ffc;
  --mantine-color-indigo-5: #5c7cfa;
  --mantine-color-indigo-6: #4c6ef5;
  --mantine-color-indigo-7: #4263eb;
  --mantine-color-indigo-8: #3b5bdb;
  --mantine-color-indigo-9: #364fc7;
  --mantine-color-blue-0: #e7f5ff;
  --mantine-color-blue-1: #d0ebff;
  --mantine-color-blue-2: #a5d8ff;
  --mantine-color-blue-3: #74c0fc;
  --mantine-color-blue-4: #4dabf7;
  --mantine-color-blue-5: #339af0;
  --mantine-color-blue-6: #228be6;
  --mantine-color-blue-7: #1c7ed6;
  --mantine-color-blue-8: #1971c2;
  --mantine-color-blue-9: #1864ab;
  --mantine-color-cyan-0: #e3fafc;
  --mantine-color-cyan-1: #c5f6fa;
  --mantine-color-cyan-2: #99e9f2;
  --mantine-color-cyan-3: #66d9e8;
  --mantine-color-cyan-4: #3bc9db;
  --mantine-color-cyan-5: #22b8cf;
  --mantine-color-cyan-6: #15aabf;
  --mantine-color-cyan-7: #1098ad;
  --mantine-color-cyan-8: #0c8599;
  --mantine-color-cyan-9: #0b7285;
  --mantine-color-teal-0: #e6fcf5;
  --mantine-color-teal-1: #c3fae8;
  --mantine-color-teal-2: #96f2d7;
  --mantine-color-teal-3: #63e6be;
  --mantine-color-teal-4: #38d9a9;
  --mantine-color-teal-5: #20c997;
  --mantine-color-teal-6: #12b886;
  --mantine-color-teal-7: #0ca678;
  --mantine-color-teal-8: #099268;
  --mantine-color-teal-9: #087f5b;
  --mantine-color-green-0: #ebfbee;
  --mantine-color-green-1: #d3f9d8;
  --mantine-color-green-2: #b2f2bb;
  --mantine-color-green-3: #8ce99a;
  --mantine-color-green-4: #69db7c;
  --mantine-color-green-5: #51cf66;
  --mantine-color-green-6: #40c057;
  --mantine-color-green-7: #37b24d;
  --mantine-color-green-8: #2f9e44;
  --mantine-color-green-9: #2b8a3e;
  --mantine-color-lime-0: #f4fce3;
  --mantine-color-lime-1: #e9fac8;
  --mantine-color-lime-2: #d8f5a2;
  --mantine-color-lime-3: #c0eb75;
  --mantine-color-lime-4: #a9e34b;
  --mantine-color-lime-5: #94d82d;
  --mantine-color-lime-6: #82c91e;
  --mantine-color-lime-7: #74b816;
  --mantine-color-lime-8: #66a80f;
  --mantine-color-lime-9: #5c940d;
  --mantine-color-yellow-0: #fff9db;
  --mantine-color-yellow-1: #fff3bf;
  --mantine-color-yellow-2: #ffec99;
  --mantine-color-yellow-3: #ffe066;
  --mantine-color-yellow-4: #ffd43b;
  --mantine-color-yellow-5: #fcc419;
  --mantine-color-yellow-6: #fab005;
  --mantine-color-yellow-7: #f59f00;
  --mantine-color-yellow-8: #f08c00;
  --mantine-color-yellow-9: #e67700;
  --mantine-color-orange-0: #fff4e6;
  --mantine-color-orange-1: #ffe8cc;
  --mantine-color-orange-2: #ffd8a8;
  --mantine-color-orange-3: #ffc078;
  --mantine-color-orange-4: #ffa94d;
  --mantine-color-orange-5: #ff922b;
  --mantine-color-orange-6: #fd7e14;
  --mantine-color-orange-7: #f76707;
  --mantine-color-orange-8: #e8590c;
  --mantine-color-orange-9: #d9480f;
  --mantine-h1-font-size: calc(2.125rem * var(--mantine-scale));
  --mantine-h1-line-height: 1.3;
  --mantine-h1-font-weight: 700;
  --mantine-h2-font-size: calc(1.625rem * var(--mantine-scale));
  --mantine-h2-line-height: 1.35;
  --mantine-h2-font-weight: 700;
  --mantine-h3-font-size: calc(1.375rem * var(--mantine-scale));
  --mantine-h3-line-height: 1.4;
  --mantine-h3-font-weight: 700;
  --mantine-h4-font-size: calc(1.125rem * var(--mantine-scale));
  --mantine-h4-line-height: 1.45;
  --mantine-h4-font-weight: 700;
  --mantine-h5-font-size: calc(1rem * var(--mantine-scale));
  --mantine-h5-line-height: 1.5;
  --mantine-h5-font-weight: 700;
  --mantine-h6-font-size: calc(0.875rem * var(--mantine-scale));
  --mantine-h6-line-height: 1.5;
  --mantine-h6-font-weight: 700;
}
:root[data-mantine-color-scheme=dark] {
  --mantine-color-scheme: dark;
  --mantine-primary-color-contrast: var(--mantine-color-white);
  --mantine-color-bright: var(--mantine-color-white);
  --mantine-color-text: var(--mantine-color-dark-0);
  --mantine-color-body: var(--mantine-color-dark-7);
  --mantine-color-error: var(--mantine-color-red-8);
  --mantine-color-placeholder: var(--mantine-color-dark-3);
  --mantine-color-anchor: var(--mantine-color-blue-4);
  --mantine-color-default: var(--mantine-color-dark-6);
  --mantine-color-default-hover: var(--mantine-color-dark-5);
  --mantine-color-default-color: var(--mantine-color-white);
  --mantine-color-default-border: var(--mantine-color-dark-4);
  --mantine-color-dimmed: var(--mantine-color-dark-2);
  --mantine-color-disabled: var(--mantine-color-dark-6);
  --mantine-color-disabled-color: var(--mantine-color-dark-3);
  --mantine-color-disabled-border: var(--mantine-color-dark-4);
  --mantine-color-dark-text: var(--mantine-color-dark-4);
  --mantine-color-dark-filled: var(--mantine-color-dark-8);
  --mantine-color-dark-filled-hover: var(--mantine-color-dark-9);
  --mantine-color-dark-light: rgba(46, 46, 46, 0.15);
  --mantine-color-dark-light-hover: rgba(46, 46, 46, 0.2);
  --mantine-color-dark-light-color: var(--mantine-color-dark-3);
  --mantine-color-dark-outline: var(--mantine-color-dark-4);
  --mantine-color-dark-outline-hover: rgba(66, 66, 66, 0.05);
  --mantine-color-gray-text: var(--mantine-color-gray-4);
  --mantine-color-gray-filled: var(--mantine-color-gray-8);
  --mantine-color-gray-filled-hover: var(--mantine-color-gray-9);
  --mantine-color-gray-light: rgba(134, 142, 150, 0.15);
  --mantine-color-gray-light-hover: rgba(134, 142, 150, 0.2);
  --mantine-color-gray-light-color: var(--mantine-color-gray-3);
  --mantine-color-gray-outline: var(--mantine-color-gray-4);
  --mantine-color-gray-outline-hover: rgba(206, 212, 218, 0.05);
  --mantine-color-red-text: var(--mantine-color-red-4);
  --mantine-color-red-filled: var(--mantine-color-red-8);
  --mantine-color-red-filled-hover: var(--mantine-color-red-9);
  --mantine-color-red-light: rgba(250, 82, 82, 0.15);
  --mantine-color-red-light-hover: rgba(250, 82, 82, 0.2);
  --mantine-color-red-light-color: var(--mantine-color-red-3);
  --mantine-color-red-outline: var(--mantine-color-red-4);
  --mantine-color-red-outline-hover: rgba(255, 135, 135, 0.05);
  --mantine-color-pink-text: var(--mantine-color-pink-4);
  --mantine-color-pink-filled: var(--mantine-color-pink-8);
  --mantine-color-pink-filled-hover: var(--mantine-color-pink-9);
  --mantine-color-pink-light: rgba(230, 73, 128, 0.15);
  --mantine-color-pink-light-hover: rgba(230, 73, 128, 0.2);
  --mantine-color-pink-light-color: var(--mantine-color-pink-3);
  --mantine-color-pink-outline: var(--mantine-color-pink-4);
  --mantine-color-pink-outline-hover: rgba(247, 131, 172, 0.05);
  --mantine-color-grape-text: var(--mantine-color-grape-4);
  --mantine-color-grape-filled: var(--mantine-color-grape-8);
  --mantine-color-grape-filled-hover: var(--mantine-color-grape-9);
  --mantine-color-grape-light: rgba(190, 75, 219, 0.15);
  --mantine-color-grape-light-hover: rgba(190, 75, 219, 0.2);
  --mantine-color-grape-light-color: var(--mantine-color-grape-3);
  --mantine-color-grape-outline: var(--mantine-color-grape-4);
  --mantine-color-grape-outline-hover: rgba(218, 119, 242, 0.05);
  --mantine-color-violet-text: var(--mantine-color-violet-4);
  --mantine-color-violet-filled: var(--mantine-color-violet-8);
  --mantine-color-violet-filled-hover: var(--mantine-color-violet-9);
  --mantine-color-violet-light: rgba(121, 80, 242, 0.15);
  --mantine-color-violet-light-hover: rgba(121, 80, 242, 0.2);
  --mantine-color-violet-light-color: var(--mantine-color-violet-3);
  --mantine-color-violet-outline: var(--mantine-color-violet-4);
  --mantine-color-violet-outline-hover: rgba(151, 117, 250, 0.05);
  --mantine-color-indigo-text: var(--mantine-color-indigo-4);
  --mantine-color-indigo-filled: var(--mantine-color-indigo-8);
  --mantine-color-indigo-filled-hover: var(--mantine-color-indigo-9);
  --mantine-color-indigo-light: rgba(76, 110, 245, 0.15);
  --mantine-color-indigo-light-hover: rgba(76, 110, 245, 0.2);
  --mantine-color-indigo-light-color: var(--mantine-color-indigo-3);
  --mantine-color-indigo-outline: var(--mantine-color-indigo-4);
  --mantine-color-indigo-outline-hover: rgba(116, 143, 252, 0.05);
  --mantine-color-blue-text: var(--mantine-color-blue-4);
  --mantine-color-blue-filled: var(--mantine-color-blue-8);
  --mantine-color-blue-filled-hover: var(--mantine-color-blue-9);
  --mantine-color-blue-light: rgba(34, 139, 230, 0.15);
  --mantine-color-blue-light-hover: rgba(34, 139, 230, 0.2);
  --mantine-color-blue-light-color: var(--mantine-color-blue-3);
  --mantine-color-blue-outline: var(--mantine-color-blue-4);
  --mantine-color-blue-outline-hover: rgba(77, 171, 247, 0.05);
  --mantine-color-cyan-text: var(--mantine-color-cyan-4);
  --mantine-color-cyan-filled: var(--mantine-color-cyan-8);
  --mantine-color-cyan-filled-hover: var(--mantine-color-cyan-9);
  --mantine-color-cyan-light: rgba(21, 170, 191, 0.15);
  --mantine-color-cyan-light-hover: rgba(21, 170, 191, 0.2);
  --mantine-color-cyan-light-color: var(--mantine-color-cyan-3);
  --mantine-color-cyan-outline: var(--mantine-color-cyan-4);
  --mantine-color-cyan-outline-hover: rgba(59, 201, 219, 0.05);
  --mantine-color-teal-text: var(--mantine-color-teal-4);
  --mantine-color-teal-filled: var(--mantine-color-teal-8);
  --mantine-color-teal-filled-hover: var(--mantine-color-teal-9);
  --mantine-color-teal-light: rgba(18, 184, 134, 0.15);
  --mantine-color-teal-light-hover: rgba(18, 184, 134, 0.2);
  --mantine-color-teal-light-color: var(--mantine-color-teal-3);
  --mantine-color-teal-outline: var(--mantine-color-teal-4);
  --mantine-color-teal-outline-hover: rgba(56, 217, 169, 0.05);
  --mantine-color-green-text: var(--mantine-color-green-4);
  --mantine-color-green-filled: var(--mantine-color-green-8);
  --mantine-color-green-filled-hover: var(--mantine-color-green-9);
  --mantine-color-green-light: rgba(64, 192, 87, 0.15);
  --mantine-color-green-light-hover: rgba(64, 192, 87, 0.2);
  --mantine-color-green-light-color: var(--mantine-color-green-3);
  --mantine-color-green-outline: var(--mantine-color-green-4);
  --mantine-color-green-outline-hover: rgba(105, 219, 124, 0.05);
  --mantine-color-lime-text: var(--mantine-color-lime-4);
  --mantine-color-lime-filled: var(--mantine-color-lime-8);
  --mantine-color-lime-filled-hover: var(--mantine-color-lime-9);
  --mantine-color-lime-light: rgba(130, 201, 30, 0.15);
  --mantine-color-lime-light-hover: rgba(130, 201, 30, 0.2);
  --mantine-color-lime-light-color: var(--mantine-color-lime-3);
  --mantine-color-lime-outline: var(--mantine-color-lime-4);
  --mantine-color-lime-outline-hover: rgba(169, 227, 75, 0.05);
  --mantine-color-yellow-text: var(--mantine-color-yellow-4);
  --mantine-color-yellow-filled: var(--mantine-color-yellow-8);
  --mantine-color-yellow-filled-hover: var(--mantine-color-yellow-9);
  --mantine-color-yellow-light: rgba(250, 176, 5, 0.15);
  --mantine-color-yellow-light-hover: rgba(250, 176, 5, 0.2);
  --mantine-color-yellow-light-color: var(--mantine-color-yellow-3);
  --mantine-color-yellow-outline: var(--mantine-color-yellow-4);
  --mantine-color-yellow-outline-hover: rgba(255, 212, 59, 0.05);
  --mantine-color-orange-text: var(--mantine-color-orange-4);
  --mantine-color-orange-filled: var(--mantine-color-orange-8);
  --mantine-color-orange-filled-hover: var(--mantine-color-orange-9);
  --mantine-color-orange-light: rgba(253, 126, 20, 0.15);
  --mantine-color-orange-light-hover: rgba(253, 126, 20, 0.2);
  --mantine-color-orange-light-color: var(--mantine-color-orange-3);
  --mantine-color-orange-outline: var(--mantine-color-orange-4);
  --mantine-color-orange-outline-hover: rgba(255, 169, 77, 0.05);
}
:root[data-mantine-color-scheme=light] {
  --mantine-color-scheme: light;
  --mantine-primary-color-contrast: var(--mantine-color-white);
  --mantine-color-bright: var(--mantine-color-black);
  --mantine-color-text: #000;
  --mantine-color-body: #fff;
  --mantine-color-error: var(--mantine-color-red-6);
  --mantine-color-placeholder: var(--mantine-color-gray-5);
  --mantine-color-anchor: var(--mantine-color-blue-6);
  --mantine-color-default: var(--mantine-color-white);
  --mantine-color-default-hover: var(--mantine-color-gray-0);
  --mantine-color-default-color: var(--mantine-color-black);
  --mantine-color-default-border: var(--mantine-color-gray-4);
  --mantine-color-dimmed: var(--mantine-color-gray-6);
  --mantine-color-disabled: var(--mantine-color-gray-2);
  --mantine-color-disabled-color: var(--mantine-color-gray-5);
  --mantine-color-disabled-border: var(--mantine-color-gray-3);
  --mantine-color-dark-text: var(--mantine-color-dark-filled);
  --mantine-color-dark-filled: var(--mantine-color-dark-6);
  --mantine-color-dark-filled-hover: var(--mantine-color-dark-7);
  --mantine-color-dark-light: rgba(46, 46, 46, 0.1);
  --mantine-color-dark-light-hover: rgba(46, 46, 46, 0.12);
  --mantine-color-dark-light-color: var(--mantine-color-dark-6);
  --mantine-color-dark-outline: var(--mantine-color-dark-6);
  --mantine-color-dark-outline-hover: rgba(46, 46, 46, 0.05);
  --mantine-color-gray-text: var(--mantine-color-gray-filled);
  --mantine-color-gray-filled: var(--mantine-color-gray-6);
  --mantine-color-gray-filled-hover: var(--mantine-color-gray-7);
  --mantine-color-gray-light: rgba(134, 142, 150, 0.1);
  --mantine-color-gray-light-hover: rgba(134, 142, 150, 0.12);
  --mantine-color-gray-light-color: var(--mantine-color-gray-6);
  --mantine-color-gray-outline: var(--mantine-color-gray-6);
  --mantine-color-gray-outline-hover: rgba(134, 142, 150, 0.05);
  --mantine-color-red-text: var(--mantine-color-red-filled);
  --mantine-color-red-filled: var(--mantine-color-red-6);
  --mantine-color-red-filled-hover: var(--mantine-color-red-7);
  --mantine-color-red-light: rgba(250, 82, 82, 0.1);
  --mantine-color-red-light-hover: rgba(250, 82, 82, 0.12);
  --mantine-color-red-light-color: var(--mantine-color-red-6);
  --mantine-color-red-outline: var(--mantine-color-red-6);
  --mantine-color-red-outline-hover: rgba(250, 82, 82, 0.05);
  --mantine-color-pink-text: var(--mantine-color-pink-filled);
  --mantine-color-pink-filled: var(--mantine-color-pink-6);
  --mantine-color-pink-filled-hover: var(--mantine-color-pink-7);
  --mantine-color-pink-light: rgba(230, 73, 128, 0.1);
  --mantine-color-pink-light-hover: rgba(230, 73, 128, 0.12);
  --mantine-color-pink-light-color: var(--mantine-color-pink-6);
  --mantine-color-pink-outline: var(--mantine-color-pink-6);
  --mantine-color-pink-outline-hover: rgba(230, 73, 128, 0.05);
  --mantine-color-grape-text: var(--mantine-color-grape-filled);
  --mantine-color-grape-filled: var(--mantine-color-grape-6);
  --mantine-color-grape-filled-hover: var(--mantine-color-grape-7);
  --mantine-color-grape-light: rgba(190, 75, 219, 0.1);
  --mantine-color-grape-light-hover: rgba(190, 75, 219, 0.12);
  --mantine-color-grape-light-color: var(--mantine-color-grape-6);
  --mantine-color-grape-outline: var(--mantine-color-grape-6);
  --mantine-color-grape-outline-hover: rgba(190, 75, 219, 0.05);
  --mantine-color-violet-text: var(--mantine-color-violet-filled);
  --mantine-color-violet-filled: var(--mantine-color-violet-6);
  --mantine-color-violet-filled-hover: var(--mantine-color-violet-7);
  --mantine-color-violet-light: rgba(121, 80, 242, 0.1);
  --mantine-color-violet-light-hover: rgba(121, 80, 242, 0.12);
  --mantine-color-violet-light-color: var(--mantine-color-violet-6);
  --mantine-color-violet-outline: var(--mantine-color-violet-6);
  --mantine-color-violet-outline-hover: rgba(121, 80, 242, 0.05);
  --mantine-color-indigo-text: var(--mantine-color-indigo-filled);
  --mantine-color-indigo-filled: var(--mantine-color-indigo-6);
  --mantine-color-indigo-filled-hover: var(--mantine-color-indigo-7);
  --mantine-color-indigo-light: rgba(76, 110, 245, 0.1);
  --mantine-color-indigo-light-hover: rgba(76, 110, 245, 0.12);
  --mantine-color-indigo-light-color: var(--mantine-color-indigo-6);
  --mantine-color-indigo-outline: var(--mantine-color-indigo-6);
  --mantine-color-indigo-outline-hover: rgba(76, 110, 245, 0.05);
  --mantine-color-blue-text: var(--mantine-color-blue-filled);
  --mantine-color-blue-filled: var(--mantine-color-blue-6);
  --mantine-color-blue-filled-hover: var(--mantine-color-blue-7);
  --mantine-color-blue-light: rgba(34, 139, 230, 0.1);
  --mantine-color-blue-light-hover: rgba(34, 139, 230, 0.12);
  --mantine-color-blue-light-color: var(--mantine-color-blue-6);
  --mantine-color-blue-outline: var(--mantine-color-blue-6);
  --mantine-color-blue-outline-hover: rgba(34, 139, 230, 0.05);
  --mantine-color-cyan-text: var(--mantine-color-cyan-filled);
  --mantine-color-cyan-filled: var(--mantine-color-cyan-6);
  --mantine-color-cyan-filled-hover: var(--mantine-color-cyan-7);
  --mantine-color-cyan-light: rgba(21, 170, 191, 0.1);
  --mantine-color-cyan-light-hover: rgba(21, 170, 191, 0.12);
  --mantine-color-cyan-light-color: var(--mantine-color-cyan-6);
  --mantine-color-cyan-outline: var(--mantine-color-cyan-6);
  --mantine-color-cyan-outline-hover: rgba(21, 170, 191, 0.05);
  --mantine-color-teal-text: var(--mantine-color-teal-filled);
  --mantine-color-teal-filled: var(--mantine-color-teal-6);
  --mantine-color-teal-filled-hover: var(--mantine-color-teal-7);
  --mantine-color-teal-light: rgba(18, 184, 134, 0.1);
  --mantine-color-teal-light-hover: rgba(18, 184, 134, 0.12);
  --mantine-color-teal-light-color: var(--mantine-color-teal-6);
  --mantine-color-teal-outline: var(--mantine-color-teal-6);
  --mantine-color-teal-outline-hover: rgba(18, 184, 134, 0.05);
  --mantine-color-green-text: var(--mantine-color-green-filled);
  --mantine-color-green-filled: var(--mantine-color-green-6);
  --mantine-color-green-filled-hover: var(--mantine-color-green-7);
  --mantine-color-green-light: rgba(64, 192, 87, 0.1);
  --mantine-color-green-light-hover: rgba(64, 192, 87, 0.12);
  --mantine-color-green-light-color: var(--mantine-color-green-6);
  --mantine-color-green-outline: var(--mantine-color-green-6);
  --mantine-color-green-outline-hover: rgba(64, 192, 87, 0.05);
  --mantine-color-lime-text: var(--mantine-color-lime-filled);
  --mantine-color-lime-filled: var(--mantine-color-lime-6);
  --mantine-color-lime-filled-hover: var(--mantine-color-lime-7);
  --mantine-color-lime-light: rgba(130, 201, 30, 0.1);
  --mantine-color-lime-light-hover: rgba(130, 201, 30, 0.12);
  --mantine-color-lime-light-color: var(--mantine-color-lime-6);
  --mantine-color-lime-outline: var(--mantine-color-lime-6);
  --mantine-color-lime-outline-hover: rgba(130, 201, 30, 0.05);
  --mantine-color-yellow-text: var(--mantine-color-yellow-filled);
  --mantine-color-yellow-filled: var(--mantine-color-yellow-6);
  --mantine-color-yellow-filled-hover: var(--mantine-color-yellow-7);
  --mantine-color-yellow-light: rgba(250, 176, 5, 0.1);
  --mantine-color-yellow-light-hover: rgba(250, 176, 5, 0.12);
  --mantine-color-yellow-light-color: var(--mantine-color-yellow-6);
  --mantine-color-yellow-outline: var(--mantine-color-yellow-6);
  --mantine-color-yellow-outline-hover: rgba(250, 176, 5, 0.05);
  --mantine-color-orange-text: var(--mantine-color-orange-filled);
  --mantine-color-orange-filled: var(--mantine-color-orange-6);
  --mantine-color-orange-filled-hover: var(--mantine-color-orange-7);
  --mantine-color-orange-light: rgba(253, 126, 20, 0.1);
  --mantine-color-orange-light-hover: rgba(253, 126, 20, 0.12);
  --mantine-color-orange-light-color: var(--mantine-color-orange-6);
  --mantine-color-orange-outline: var(--mantine-color-orange-6);
  --mantine-color-orange-outline-hover: rgba(253, 126, 20, 0.05);
}
.m_d57069b5 {
  --scrollarea-scrollbar-size: calc(0.75rem * var(--mantine-scale));
  position: relative;
  overflow: hidden;
}
.m_d57069b5:where([data-autosize]) .m_b1336c6 {
  min-width: min-content;
}
.m_c0783ff9 {
  scrollbar-width: none;
  overscroll-behavior: var(--scrollarea-over-scroll-behavior);
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
  width: 100%;
  height: 100%;
}
.m_c0783ff9::-webkit-scrollbar {
  display: none;
}
.m_c0783ff9:where([data-scrollbars=xy], [data-scrollbars=y]):where([data-offset-scrollbars=xy], [data-offset-scrollbars=y], [data-offset-scrollbars=present]):where([data-vertical-hidden]) {
  padding-inline-end: 0;
  padding-inline-start: 0;
}
.m_c0783ff9:where([data-scrollbars=xy], [data-scrollbars=y]):where([data-offset-scrollbars=xy], [data-offset-scrollbars=y], [data-offset-scrollbars=present]):not([data-vertical-hidden]) {
  padding-inline-end: var(--scrollarea-scrollbar-size);
  padding-inline-start: unset;
}
.m_c0783ff9:where([data-scrollbars=xy], [data-scrollbars=x]):where([data-offset-scrollbars=xy], [data-offset-scrollbars=x], [data-offset-scrollbars=present]):where([data-horizontal-hidden]) {
  padding-bottom: 0;
}
.m_c0783ff9:where([data-scrollbars=xy], [data-scrollbars=x]):where([data-offset-scrollbars=xy], [data-offset-scrollbars=x], [data-offset-scrollbars=present]):not([data-horizontal-hidden]) {
  padding-bottom: var(--scrollarea-scrollbar-size);
}
.m_f8f631dd {
  min-width: 100%;
  display: table;
}
.m_c44ba933 {
  user-select: none;
  touch-action: none;
  box-sizing: border-box;
  transition: background-color 150ms ease, opacity 150ms ease;
  padding: calc(var(--scrollarea-scrollbar-size) / 5);
  display: flex;
  background-color: transparent;
  flex-direction: row;
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_c44ba933:hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=light]) .m_c44ba933:hover > .m_d8b5e363 {
    background-color: rgba(0, 0, 0, 0.5);
  }
  :where([data-mantine-color-scheme=dark]) .m_c44ba933:hover {
    background-color: var(--mantine-color-dark-8);
  }
  :where([data-mantine-color-scheme=dark]) .m_c44ba933:hover > .m_d8b5e363 {
    background-color: rgba(255, 255, 255, 0.5);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_c44ba933:active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=light]) .m_c44ba933:active > .m_d8b5e363 {
    background-color: rgba(0, 0, 0, 0.5);
  }
  :where([data-mantine-color-scheme=dark]) .m_c44ba933:active {
    background-color: var(--mantine-color-dark-8);
  }
  :where([data-mantine-color-scheme=dark]) .m_c44ba933:active > .m_d8b5e363 {
    background-color: rgba(255, 255, 255, 0.5);
  }
}
.m_c44ba933:where([data-hidden], [data-state=hidden]) {
  display: none;
}
.m_c44ba933:where([data-orientation=vertical]) {
  width: var(--scrollarea-scrollbar-size);
  top: 0;
  bottom: var(--sa-corner-width);
  inset-inline-end: 0;
}
.m_c44ba933:where([data-orientation=horizontal]) {
  height: var(--scrollarea-scrollbar-size);
  flex-direction: column;
  bottom: 0;
  inset-inline-start: 0;
  inset-inline-end: var(--sa-corner-width);
}
.m_d8b5e363 {
  flex: 1;
  border-radius: var(--scrollarea-scrollbar-size);
  position: relative;
  transition: background-color 150ms ease;
  overflow: hidden;
  opacity: var(--thumb-opacity);
}
.m_d8b5e363::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  height: 100%;
  min-width: calc(2.75rem * var(--mantine-scale));
  min-height: calc(2.75rem * var(--mantine-scale));
}
:where([data-mantine-color-scheme=light]) .m_d8b5e363 {
  background-color: rgba(0, 0, 0, 0.4);
}
:where([data-mantine-color-scheme=dark]) .m_d8b5e363 {
  background-color: rgba(255, 255, 255, 0.4);
}
.m_21657268 {
  position: absolute;
  opacity: 0;
  transition: opacity 150ms ease;
  display: block;
  inset-inline-end: 0;
  bottom: 0;
}
:where([data-mantine-color-scheme=light]) .m_21657268 {
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_21657268 {
  background-color: var(--mantine-color-dark-8);
}
.m_21657268:where([data-hovered]) {
  opacity: 1;
}
.m_21657268:where([data-hidden]) {
  display: none;
}
.m_b1336c6 {
  min-width: 100%;
}
.m_87cf2631 {
  background-color: transparent;
  cursor: pointer;
  border: 0;
  padding: 0;
  appearance: none;
  font-size: var(--mantine-font-size-md);
  text-align: left;
  text-decoration: none;
  color: inherit;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
:where([dir=rtl]) .m_87cf2631 {
  text-align: right;
}
.m_515a97f8 {
  border: 0;
  clip: rect(0 0 0 0);
  height: calc(0.0625rem * var(--mantine-scale));
  width: calc(0.0625rem * var(--mantine-scale));
  margin: calc(-0.0625rem * var(--mantine-scale));
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
}
.m_1b7284a3 {
  --paper-radius: var(--mantine-radius-default);
  outline: 0;
  -webkit-tap-highlight-color: transparent;
  display: block;
  touch-action: manipulation;
  text-decoration: none;
  border-radius: var(--paper-radius);
  box-shadow: var(--paper-shadow);
  background-color: var(--mantine-color-body);
}
[data-mantine-color-scheme=light] .m_1b7284a3 {
  --paper-border-color: var(--mantine-color-gray-3);
}
[data-mantine-color-scheme=dark] .m_1b7284a3 {
  --paper-border-color: var(--mantine-color-dark-4);
}
.m_1b7284a3:where([data-with-border]) {
  border: calc(0.0625rem * var(--mantine-scale)) solid var(--paper-border-color);
}
.m_9814e45f {
  inset: 0;
  position: absolute;
  background: var(--overlay-bg, rgba(0, 0, 0, 0.6));
  -webkit-backdrop-filter: var(--overlay-filter);
  backdrop-filter: var(--overlay-filter);
  border-radius: var(--overlay-radius, 0);
  z-index: var(--overlay-z-index);
}
.m_9814e45f:where([data-fixed]) {
  position: fixed;
}
.m_9814e45f:where([data-center]) {
  display: flex;
  align-items: center;
  justify-content: center;
}
.m_38a85659 {
  position: absolute;
  border: 1px solid var(--popover-border-color);
  padding: var(--mantine-spacing-sm) var(--mantine-spacing-md);
  box-shadow: var(--popover-shadow, none);
  border-radius: var(--popover-radius, var(--mantine-radius-default));
}
.m_38a85659:where([data-fixed]) {
  position: fixed;
}
.m_38a85659:focus {
  outline: none;
}
:where([data-mantine-color-scheme=light]) .m_38a85659 {
  --popover-border-color: var(--mantine-color-gray-2);
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_38a85659 {
  --popover-border-color: var(--mantine-color-dark-4);
  background-color: var(--mantine-color-dark-6);
}
.m_a31dc6c1 {
  background-color: inherit;
  border: 1px solid var(--popover-border-color);
  z-index: 1;
}
.m_3d7bc908 {
  position: fixed;
  inset: 0;
}
.m_5ae2e3c {
  --loader-size-xs: calc(1.125rem * var(--mantine-scale));
  --loader-size-sm: calc(1.375rem * var(--mantine-scale));
  --loader-size-md: calc(2.25rem * var(--mantine-scale));
  --loader-size-lg: calc(2.75rem * var(--mantine-scale));
  --loader-size-xl: calc(3.625rem * var(--mantine-scale));
  --loader-size: var(--loader-size-md);
  --loader-color: var(--mantine-primary-color-filled);
}
@keyframes m_5d2b3b9d {
  0% {
    transform: scale(0.6);
    opacity: 0;
  }
  50%, 100% {
    transform: scale(1);
  }
}
.m_7a2bd4cd {
  position: relative;
  width: var(--loader-size);
  height: var(--loader-size);
  display: flex;
  gap: calc(var(--loader-size) / 5);
}
.m_870bb79 {
  flex: 1;
  background: var(--loader-color);
  animation: m_5d2b3b9d 1.2s cubic-bezier(0, 0.5, 0.5, 1) infinite;
  border-radius: calc(0.125rem * var(--mantine-scale));
}
.m_870bb79:nth-of-type(1) {
  animation-delay: -240ms;
}
.m_870bb79:nth-of-type(2) {
  animation-delay: -120ms;
}
.m_870bb79:nth-of-type(3) {
  animation-delay: 0;
}
@keyframes m_aac34a1 {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(0.6);
    opacity: 0.5;
  }
}
.m_4e3f22d7 {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: calc(var(--loader-size) / 10);
  position: relative;
  width: var(--loader-size);
  height: var(--loader-size);
}
.m_870c4af {
  width: calc(var(--loader-size) / 3 - var(--loader-size) / 15);
  height: calc(var(--loader-size) / 3 - var(--loader-size) / 15);
  border-radius: 50%;
  background: var(--loader-color);
  animation: m_aac34a1 0.8s infinite linear;
}
.m_870c4af:nth-child(2) {
  animation-delay: 0.4s;
}
@keyframes m_f8e89c4b {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.m_b34414df {
  display: inline-block;
  width: var(--loader-size);
  height: var(--loader-size);
}
.m_b34414df::after {
  content: "";
  display: block;
  width: var(--loader-size);
  height: var(--loader-size);
  border-radius: calc(625rem * var(--mantine-scale));
  border-width: calc(var(--loader-size) / 8);
  border-style: solid;
  border-color: var(--loader-color) var(--loader-color) var(--loader-color) transparent;
  animation: m_f8e89c4b 1.2s linear infinite;
}
.m_8d3f4000 {
  --ai-size-xs: calc(1.125rem * var(--mantine-scale));
  --ai-size-sm: calc(1.375rem * var(--mantine-scale));
  --ai-size-md: calc(1.75rem * var(--mantine-scale));
  --ai-size-lg: calc(2.125rem * var(--mantine-scale));
  --ai-size-xl: calc(2.75rem * var(--mantine-scale));
  --ai-size-input-xs: calc(1.875rem * var(--mantine-scale));
  --ai-size-input-sm: calc(2.25rem * var(--mantine-scale));
  --ai-size-input-md: calc(2.625rem * var(--mantine-scale));
  --ai-size-input-lg: calc(3.125rem * var(--mantine-scale));
  --ai-size-input-xl: calc(3.75rem * var(--mantine-scale));
  --ai-size: var(--ai-size-md);
  --ai-color: var(--mantine-color-white);
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  user-select: none;
  overflow: hidden;
  width: var(--ai-size);
  height: var(--ai-size);
  min-width: var(--ai-size);
  min-height: var(--ai-size);
  border-radius: var(--ai-radius, var(--mantine-radius-default));
  background: var(--ai-bg, var(--mantine-primary-color-filled));
  color: var(--ai-color, var(--mantine-color-white));
  border: var(--ai-bd, calc(0.0625rem * var(--mantine-scale)) solid transparent);
  cursor: pointer;
}
@media (hover: hover) {
  .m_8d3f4000:hover:where(:not([data-loading], :disabled, [data-disabled])) {
    background-color: var(--ai-hover, var(--mantine-primary-color-filled-hover));
    color: var(--ai-hover-color, var(--ai-color));
  }
}
@media (hover: none) {
  .m_8d3f4000:active:where(:not([data-loading], :disabled, [data-disabled])) {
    background-color: var(--ai-hover, var(--mantine-primary-color-filled-hover));
    color: var(--ai-hover-color, var(--ai-color));
  }
}
.m_8d3f4000[data-loading] {
  cursor: not-allowed;
}
.m_8d3f4000[data-loading] .m_8d3afb97 {
  opacity: 0;
  transform: translateY(100%);
}
.m_8d3f4000:where(:disabled:not([data-loading]), [data-disabled]:not([data-loading])) {
  cursor: not-allowed;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  color: var(--mantine-color-disabled-color);
  background-color: var(--mantine-color-disabled);
}
.m_8d3f4000:where(:disabled:not([data-loading]), [data-disabled]:not([data-loading])):active {
  transform: none;
}
.m_302b9fb1 {
  inset: calc(-0.0625rem * var(--mantine-scale));
  position: absolute;
  border-radius: var(--ai-radius, var(--mantine-radius-default));
  display: flex;
  align-items: center;
  justify-content: center;
}
:where([data-mantine-color-scheme=light]) .m_302b9fb1 {
  background-color: rgba(255, 255, 255, 0.15);
}
:where([data-mantine-color-scheme=dark]) .m_302b9fb1 {
  background-color: rgba(0, 0, 0, 0.15);
}
.m_1a0f1b21 {
  --ai-border-width: calc(0.0625rem * var(--mantine-scale));
  display: flex;
}
.m_1a0f1b21 :where(*):focus {
  position: relative;
  z-index: 1;
}
.m_1a0f1b21[data-orientation=horizontal] {
  flex-direction: row;
}
.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):first-child,
.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):first-child {
  border-end-end-radius: 0;
  border-start-end-radius: 0;
  border-inline-end-width: calc(var(--ai-border-width) / 2);
}
.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):last-child,
.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):last-child {
  border-end-start-radius: 0;
  border-start-start-radius: 0;
  border-inline-start-width: calc(var(--ai-border-width) / 2);
}
.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child),
.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):not(:first-child):not(:last-child) {
  border-radius: 0;
  border-inline-width: calc(var(--ai-border-width) / 2);
}
.m_1a0f1b21[data-orientation=vertical] {
  flex-direction: column;
}
.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):first-child,
.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):first-child {
  border-end-start-radius: 0;
  border-end-end-radius: 0;
  border-bottom-width: calc(var(--ai-border-width) / 2);
}
.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):last-child,
.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):last-child {
  border-start-start-radius: 0;
  border-start-end-radius: 0;
  border-top-width: calc(var(--ai-border-width) / 2);
}
.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child),
.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):not(:first-child):not(:last-child) {
  border-radius: 0;
  border-bottom-width: calc(var(--ai-border-width) / 2);
  border-top-width: calc(var(--ai-border-width) / 2);
}
.m_8d3afb97 {
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 150ms ease, opacity 100ms ease;
  width: 100%;
  height: 100%;
}
.m_437b6484 {
  --section-height-xs: calc(1.125rem * var(--mantine-scale));
  --section-height-sm: calc(1.375rem * var(--mantine-scale));
  --section-height-md: calc(1.75rem * var(--mantine-scale));
  --section-height-lg: calc(2.125rem * var(--mantine-scale));
  --section-height-xl: calc(2.75rem * var(--mantine-scale));
  --section-height-input-xs: calc(1.875rem * var(--mantine-scale));
  --section-height-input-sm: calc(2.25rem * var(--mantine-scale));
  --section-height-input-md: calc(2.625rem * var(--mantine-scale));
  --section-height-input-lg: calc(3.125rem * var(--mantine-scale));
  --section-height-input-xl: calc(3.75rem * var(--mantine-scale));
  --section-padding-x-xs: calc(0.375rem * var(--mantine-scale));
  --section-padding-x-sm: calc(0.5rem * var(--mantine-scale));
  --section-padding-x-md: calc(0.625rem * var(--mantine-scale));
  --section-padding-x-lg: calc(0.75rem * var(--mantine-scale));
  --section-padding-x-xl: calc(1rem * var(--mantine-scale));
  --section-height: var(--section-height-sm);
  --section-padding-x: var(--section-padding-x-sm);
  --section-color: var(--mantine-color-white);
  font-weight: 600;
  width: auto;
  border-radius: var(--section-radius, var(--mantine-radius-default));
  font-size: var(--section-fz, var(--mantine-font-size-sm));
  background: var(--section-bg, var(--mantine-primary-color-filled));
  border: var(--section-bd, calc(0.0625rem * var(--mantine-scale)) solid transparent);
  color: var(--section-color, var(--mantine-color-white));
  height: var(--section-height, var(--section-height-sm));
  padding-inline: var(--section-padding-x, var(--section-padding-x-sm));
  vertical-align: middle;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.m_86a44da5 {
  --cb-size-xs: calc(1.125rem * var(--mantine-scale));
  --cb-size-sm: calc(1.375rem * var(--mantine-scale));
  --cb-size-md: calc(1.75rem * var(--mantine-scale));
  --cb-size-lg: calc(2.125rem * var(--mantine-scale));
  --cb-size-xl: calc(2.75rem * var(--mantine-scale));
  --cb-size: var(--cb-size-md);
  --cb-icon-size: 70%;
  --cb-radius: var(--mantine-radius-default);
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  user-select: none;
  width: var(--cb-size);
  height: var(--cb-size);
  min-width: var(--cb-size);
  min-height: var(--cb-size);
  border-radius: var(--cb-radius);
}
:where([data-mantine-color-scheme=light]) .m_86a44da5 {
  color: var(--mantine-color-gray-7);
}
:where([data-mantine-color-scheme=dark]) .m_86a44da5 {
  color: var(--mantine-color-dark-1);
}
.m_86a44da5[data-disabled],
.m_86a44da5:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled], :disabled)):hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled], :disabled)):hover {
    background-color: var(--mantine-color-dark-6);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled], :disabled)):active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled], :disabled)):active {
    background-color: var(--mantine-color-dark-6);
  }
}
.m_4081bf90 {
  display: flex;
  flex-direction: row;
  flex-wrap: var(--group-wrap, wrap);
  justify-content: var(--group-justify, flex-start);
  align-items: var(--group-align, center);
  gap: var(--group-gap, var(--mantine-spacing-md));
}
.m_4081bf90:where([data-grow]) > * {
  flex-grow: 1;
  max-width: var(--group-child-width);
}
.m_615af6c9 {
  line-height: 1;
  padding: 0;
  margin: 0;
  font-weight: 400;
  font-size: var(--mantine-font-size-md);
}
.m_b5489c3c {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--mb-padding, var(--mantine-spacing-md));
  padding-inline-end: calc(var(--mb-padding, var(--mantine-spacing-md)) - calc(0.3125rem * var(--mantine-scale)));
  position: sticky;
  top: 0;
  background-color: var(--mantine-color-body);
  z-index: 1000;
  min-height: calc(3.75rem * var(--mantine-scale));
  transition: padding-inline-end 100ms;
}
.m_60c222c7 {
  position: fixed;
  width: 100%;
  top: 0;
  bottom: 0;
  z-index: var(--mb-z-index);
  pointer-events: none;
}
.m_fd1ab0aa {
  pointer-events: all;
  box-shadow: var(--mb-shadow, var(--mantine-shadow-xl));
}
.m_fd1ab0aa [data-mantine-scrollbar] {
  z-index: 1001;
}
[data-offset-scrollbars] .m_fd1ab0aa:has([data-mantine-scrollbar]) .m_b5489c3c {
  padding-inline-end: calc(var(--mb-padding, var(--mantine-spacing-md)) + calc(0.3125rem * var(--mantine-scale)));
}
.m_606cb269 {
  margin-inline-start: auto;
}
.m_5df29311 {
  padding: var(--mb-padding, var(--mantine-spacing-md));
  padding-top: var(--mb-padding, var(--mantine-spacing-md));
}
.m_5df29311:where(:not(:only-child)) {
  padding-top: 0;
}
.m_6c018570 {
  position: relative;
  margin-top: var(--input-margin-top, 0rem);
  margin-bottom: var(--input-margin-bottom, 0rem);
  --input-height-xs: calc(1.875rem * var(--mantine-scale));
  --input-height-sm: calc(2.25rem * var(--mantine-scale));
  --input-height-md: calc(2.625rem * var(--mantine-scale));
  --input-height-lg: calc(3.125rem * var(--mantine-scale));
  --input-height-xl: calc(3.75rem * var(--mantine-scale));
  --input-padding-y-xs: calc(0.3125rem * var(--mantine-scale));
  --input-padding-y-sm: calc(0.375rem * var(--mantine-scale));
  --input-padding-y-md: calc(0.5rem * var(--mantine-scale));
  --input-padding-y-lg: calc(0.625rem * var(--mantine-scale));
  --input-padding-y-xl: calc(0.8125rem * var(--mantine-scale));
  --input-height: var(--input-height-sm);
  --input-radius: var(--mantine-radius-default);
  --input-cursor: text;
  --input-text-align: left;
  --input-line-height: calc(var(--input-height) - calc(0.125rem * var(--mantine-scale)));
  --input-padding: calc(var(--input-height) / 3);
  --input-padding-inline-start: var(--input-padding);
  --input-padding-inline-end: var(--input-padding);
  --input-placeholder-color: var(--mantine-color-placeholder);
  --input-color: var(--mantine-color-text);
  --input-disabled-bg: var(--mantine-color-disabled);
  --input-disabled-color: var(--mantine-color-disabled-color);
  --input-left-section-size: var(--input-left-section-width, calc(var(--input-height) - calc(0.125rem * var(--mantine-scale))));
  --input-right-section-size: var( --input-right-section-width, calc(var(--input-height) - calc(0.125rem * var(--mantine-scale))) );
  --input-size: var(--input-height);
  --section-y: calc(0.0625rem * var(--mantine-scale));
  --left-section-start: calc(0.0625rem * var(--mantine-scale));
  --left-section-border-radius: var(--input-radius) 0 0 var(--input-radius);
  --right-section-end: calc(0.0625rem * var(--mantine-scale));
  --right-section-border-radius: 0 var(--input-radius) var(--input-radius) 0;
}
.m_6c018570[data-variant=unstyled] {
  --input-padding: 0;
  --input-padding-y: 0;
  --input-padding-inline-start: 0;
  --input-padding-inline-end: 0;
}
.m_6c018570[data-pointer] {
  --input-cursor: pointer;
}
.m_6c018570[data-multiline] {
  --input-padding-y-xs: calc(0.28125rem * var(--mantine-scale));
  --input-padding-y-sm: calc(0.34375rem * var(--mantine-scale));
  --input-padding-y-md: calc(0.4375rem * var(--mantine-scale));
  --input-padding-y-lg: calc(0.59375rem * var(--mantine-scale));
  --input-padding-y-xl: calc(0.8125rem * var(--mantine-scale));
  --input-size: auto;
  --input-line-height: var(--mantine-line-height);
}
.m_6c018570[data-with-left-section] {
  --input-padding-inline-start: var(--input-left-section-size);
}
.m_6c018570[data-with-right-section] {
  --input-padding-inline-end: var(--input-right-section-size);
}
.m_6c018570[data-size=xs] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]) {
  --input-padding-inline-end: calc(2.5625rem * var(--mantine-scale));
}
.m_6c018570[data-size=sm] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]) {
  --input-padding-inline-end: calc(3.125rem * var(--mantine-scale));
}
.m_6c018570[data-size=md] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]) {
  --input-padding-inline-end: calc(3.75rem * var(--mantine-scale));
}
.m_6c018570[data-size=lg] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]) {
  --input-padding-inline-end: calc(4.5rem * var(--mantine-scale));
}
.m_6c018570[data-size=xl] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]) {
  --input-padding-inline-end: calc(5.5625rem * var(--mantine-scale));
}
[data-mantine-color-scheme=light] .m_6c018570[data-variant=default] {
  --input-bd: var(--mantine-color-gray-4);
  --input-bg: var(--mantine-color-white);
  --input-bd-focus: var(--mantine-primary-color-filled);
}
[data-mantine-color-scheme=light] .m_6c018570[data-variant=filled] {
  --input-bd: transparent;
  --input-bg: var(--mantine-color-gray-1);
  --input-bd-focus: var(--mantine-primary-color-filled);
}
[data-mantine-color-scheme=light] .m_6c018570[data-variant=unstyled] {
  --input-bd: transparent;
  --input-bg: transparent;
  --input-bd-focus: transparent;
}
[data-mantine-color-scheme=dark] .m_6c018570[data-variant=default] {
  --input-bd: var(--mantine-color-dark-4);
  --input-bg: var(--mantine-color-dark-6);
  --input-bd-focus: var(--mantine-primary-color-filled);
}
[data-mantine-color-scheme=dark] .m_6c018570[data-variant=filled] {
  --input-bd: transparent;
  --input-bg: var(--mantine-color-dark-5);
  --input-bd-focus: var(--mantine-primary-color-filled);
}
[data-mantine-color-scheme=dark] .m_6c018570[data-variant=unstyled] {
  --input-bd: transparent;
  --input-bg: transparent;
  --input-bd-focus: transparent;
}
[data-mantine-color-scheme] .m_6c018570[data-error]:not([data-variant=unstyled]) {
  --input-bd: var(--mantine-color-error);
}
[data-mantine-color-scheme] .m_6c018570[data-error] {
  --input-color: var(--mantine-color-error);
  --input-placeholder-color: var(--mantine-color-error);
  --input-section-color: var(--mantine-color-error);
}
:where([dir=rtl]) .m_6c018570 {
  --input-text-align: right;
  --left-section-border-radius: 0 var(--input-radius) var(--input-radius) 0;
  --right-section-border-radius: var(--input-radius) 0 0 var(--input-radius);
}
.m_8fb7ebe7 {
  -webkit-tap-highlight-color: transparent;
  appearance: none;
  resize: var(--input-resize, none);
  display: block;
  width: 100%;
  transition: border-color 100ms ease;
  text-align: var(--input-text-align);
  color: var(--input-color);
  border: calc(0.0625rem * var(--mantine-scale)) solid var(--input-bd);
  background-color: var(--input-bg);
  font-family: var(--input-font-family, var(--mantine-font-family));
  height: var(--input-size);
  min-height: var(--input-height);
  line-height: var(--input-line-height);
  font-size: var(--_input-fz, var(--input-fz, var(--mantine-font-size-md)));
  border-radius: var(--input-radius);
  padding-inline-start: var(--input-padding-inline-start);
  padding-inline-end: var(--input-padding-inline-end);
  padding-top: var(--input-padding-y, 0rem);
  padding-bottom: var(--input-padding-y, 0rem);
  cursor: var(--input-cursor);
  overflow: var(--input-overflow);
}
.m_8fb7ebe7[data-no-overflow] {
  --input-overflow: hidden;
}
.m_8fb7ebe7[data-monospace] {
  --input-font-family: var(--mantine-font-family-monospace);
  --_input-fz: calc(var(--input-fz) - calc(0.125rem * var(--mantine-scale)));
}
.m_8fb7ebe7:focus,
.m_8fb7ebe7:focus-within {
  outline: none;
  --input-bd: var(--input-bd-focus);
}
[data-error] .m_8fb7ebe7:focus,
[data-error] .m_8fb7ebe7:focus-within {
  --input-bd: var(--mantine-color-error);
}
.m_8fb7ebe7::placeholder {
  color: var(--input-placeholder-color);
  opacity: 1;
}
.m_8fb7ebe7::-webkit-inner-spin-button,
.m_8fb7ebe7::-webkit-outer-spin-button,
.m_8fb7ebe7::-webkit-search-decoration,
.m_8fb7ebe7::-webkit-search-cancel-button,
.m_8fb7ebe7::-webkit-search-results-button,
.m_8fb7ebe7::-webkit-search-results-decoration {
  appearance: none;
}
.m_8fb7ebe7[type=number] {
  -moz-appearance: textfield;
}
.m_8fb7ebe7:disabled,
.m_8fb7ebe7[data-disabled] {
  cursor: not-allowed;
  opacity: 0.6;
  background-color: var(--input-disabled-bg);
  color: var(--input-disabled-color);
}
.m_8fb7ebe7:has(input:disabled) {
  cursor: not-allowed;
  opacity: 0.6;
  background-color: var(--input-disabled-bg);
  color: var(--input-disabled-color);
}
.m_8fb7ebe7[readonly] {
  caret-color: transparent;
}
.m_82577fc2 {
  pointer-events: var(--section-pointer-events);
  position: absolute;
  z-index: 1;
  inset-inline-start: var(--section-start);
  inset-inline-end: var(--section-end);
  bottom: var(--section-y);
  top: var(--section-y);
  display: flex;
  align-items: center;
  justify-content: center;
  width: var(--section-size);
  border-radius: var(--section-border-radius);
  color: var(--input-section-color, var(--mantine-color-dimmed));
}
.m_82577fc2[data-position=right] {
  --section-pointer-events: var(--input-right-section-pointer-events);
  --section-end: var(--right-section-end);
  --section-size: var(--input-right-section-size);
  --section-border-radius: var(--right-section-border-radius);
}
.m_6c018570[data-size=xs] .m_82577fc2[data-position=right]:has([data-combined-clear-section]) {
  --section-size: calc(2.5625rem * var(--mantine-scale));
}
.m_6c018570[data-size=sm] .m_82577fc2[data-position=right]:has([data-combined-clear-section]) {
  --section-size: calc(3.125rem * var(--mantine-scale));
}
.m_6c018570[data-size=md] .m_82577fc2[data-position=right]:has([data-combined-clear-section]) {
  --section-size: calc(3.75rem * var(--mantine-scale));
}
.m_6c018570[data-size=lg] .m_82577fc2[data-position=right]:has([data-combined-clear-section]) {
  --section-size: calc(4.5rem * var(--mantine-scale));
}
.m_6c018570[data-size=xl] .m_82577fc2[data-position=right]:has([data-combined-clear-section]) {
  --section-size: calc(5.5625rem * var(--mantine-scale));
}
.m_82577fc2[data-position=left] {
  --section-pointer-events: var(--input-left-section-pointer-events);
  --section-start: var(--left-section-start);
  --section-size: var(--input-left-section-size);
  --section-border-radius: var(--left-section-border-radius);
}
.m_88bacfd0 {
  color: var(--input-placeholder-color, var(--mantine-color-placeholder));
}
[data-error] .m_88bacfd0 {
  --input-placeholder-color: var(--input-color, var(--mantine-color-placeholder));
}
.m_46b77525 {
  line-height: var(--mantine-line-height);
}
.m_8fdc1311 {
  display: inline-block;
  font-weight: 500;
  overflow-wrap: break-word;
  cursor: default;
  -webkit-tap-highlight-color: transparent;
  font-size: var(--input-label-size, var(--mantine-font-size-sm));
}
.m_78a94662 {
  color: var(--input-asterisk-color, var(--mantine-color-error));
}
.m_8f816625,
.m_fe47ce59 {
  word-wrap: break-word;
  line-height: 1.2;
  display: block;
  margin: 0;
  padding: 0;
}
.m_8f816625 {
  color: var(--mantine-color-error);
  font-size: var(--input-error-size, calc(var(--mantine-font-size-sm) - calc(0.125rem * var(--mantine-scale))));
}
.m_fe47ce59 {
  color: var(--mantine-color-dimmed);
  font-size: var(--input-description-size, calc(var(--mantine-font-size-sm) - calc(0.125rem * var(--mantine-scale))));
}
.m_8bffd616 {
  display: flex;
}
.m_96b553a6 {
  --transition-duration: 150ms;
  top: 0;
  left: 0;
  position: absolute;
  z-index: 0;
  transition-property:
    transform,
    width,
    height;
  transition-timing-function: ease;
  transition-duration: 0ms;
}
.m_96b553a6:where([data-initialized]) {
  transition-duration: var(--transition-duration);
}
.m_96b553a6:where([data-hidden]) {
  background-color: red;
  display: none;
}
.m_9bdbb667 {
  --accordion-radius: var(--mantine-radius-default);
}
.m_df78851f {
  overflow-wrap: break-word;
}
.m_4ba554d4 {
  padding: var(--mantine-spacing-md);
  padding-top: calc(var(--mantine-spacing-xs) / 2);
}
.m_8fa820a0 {
  margin: 0;
  padding: 0;
}
.m_4ba585b8 {
  width: 100%;
  display: flex;
  align-items: center;
  flex-direction: row-reverse;
  padding-inline: var(--mantine-spacing-md);
  opacity: 1;
  cursor: pointer;
  background-color: transparent;
  color: var(--mantine-color-bright);
}
.m_4ba585b8:where([data-chevron-position=left]) {
  flex-direction: row;
  padding-inline-start: 0;
}
.m_4ba585b8:where(:disabled, [data-disabled]) {
  opacity: 0.4;
  cursor: not-allowed;
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled, [data-disabled])):hover,
  :where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled, [data-disabled])):hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled, [data-disabled])):hover,
  :where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled, [data-disabled])):hover {
    background-color: var(--mantine-color-dark-6);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled, [data-disabled])):active,
  :where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled, [data-disabled])):active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled, [data-disabled])):active,
  :where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled, [data-disabled])):active {
    background-color: var(--mantine-color-dark-6);
  }
}
.m_df3ffa0f {
  color: inherit;
  font-weight: 400;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: var(--mantine-spacing-sm);
  padding-bottom: var(--mantine-spacing-sm);
}
.m_3f35ae96 {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  transition: transform var(--accordion-transition-duration, 200ms) ease;
  width: var(--accordion-chevron-size, calc(0.9375rem * var(--mantine-scale)));
  min-width: var(--accordion-chevron-size, calc(0.9375rem * var(--mantine-scale)));
  transform: rotate(0deg);
}
.m_3f35ae96:where([data-rotate]) {
  transform: rotate(180deg);
}
.m_3f35ae96:where([data-position=left]) {
  margin-inline-end: var(--mantine-spacing-md);
  margin-inline-start: var(--mantine-spacing-md);
}
.m_9bd771fe {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-inline-end: var(--mantine-spacing-sm);
}
.m_9bd771fe:where([data-chevron-position=left]) {
  margin-inline-end: 0;
  margin-inline-start: var(--mantine-spacing-lg);
}
:where([data-mantine-color-scheme=light]) .m_9bd7b098 {
  --item-border-color: var(--mantine-color-gray-3);
  --item-filled-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_9bd7b098 {
  --item-border-color: var(--mantine-color-dark-4);
  --item-filled-color: var(--mantine-color-dark-6);
}
.m_fe19b709 {
  border-bottom: 1px solid var(--item-border-color);
}
.m_1f921b3b {
  border: 1px solid var(--item-border-color);
  transition: background-color 150ms ease;
}
.m_1f921b3b:where([data-active]) {
  background-color: var(--item-filled-color);
}
.m_1f921b3b:first-of-type {
  border-start-start-radius: var(--accordion-radius);
  border-start-end-radius: var(--accordion-radius);
}
.m_1f921b3b:first-of-type > [data-accordion-control] {
  border-start-start-radius: var(--accordion-radius);
  border-start-end-radius: var(--accordion-radius);
}
.m_1f921b3b:last-of-type {
  border-end-start-radius: var(--accordion-radius);
  border-end-end-radius: var(--accordion-radius);
}
.m_1f921b3b:last-of-type > [data-accordion-control] {
  border-end-start-radius: var(--accordion-radius);
  border-end-end-radius: var(--accordion-radius);
}
.m_1f921b3b + .m_1f921b3b {
  border-top: 0;
}
.m_2cdf939a {
  border-radius: var(--accordion-radius);
}
.m_2cdf939a:where([data-active]) {
  background-color: var(--item-filled-color);
}
.m_9f59b069 {
  background-color: var(--item-filled-color);
  border-radius: var(--accordion-radius);
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  transition: background-color 150ms ease;
}
.m_9f59b069[data-active] {
  border-color: var(--item-border-color);
}
:where([data-mantine-color-scheme=light]) .m_9f59b069[data-active] {
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_9f59b069[data-active] {
  background-color: var(--mantine-color-dark-7);
}
.m_9f59b069 + .m_9f59b069 {
  margin-top: var(--mantine-spacing-md);
}
.m_7f854edf {
  position: fixed;
  z-index: var(--affix-z-index);
  inset-inline-start: var(--affix-left);
  inset-inline-end: var(--affix-right);
  top: var(--affix-top);
  bottom: var(--affix-bottom);
}
.m_66836ed3 {
  --alert-radius: var(--mantine-radius-default);
  --alert-bg: var(--mantine-primary-color-light);
  --alert-bd: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  --alert-color: var(--mantine-primary-color-light-color);
  padding: var(--mantine-spacing-md) var(--mantine-spacing-md);
  border-radius: var(--alert-radius);
  position: relative;
  overflow: hidden;
  background-color: var(--alert-bg);
  border: var(--alert-bd);
  color: var(--alert-color);
}
.m_a5d60502 {
  display: flex;
}
.m_667c2793 {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--mantine-spacing-xs);
}
.m_6a03f287 {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: var(--mantine-font-size-sm);
  font-weight: 700;
}
.m_6a03f287:where([data-with-close-button]) {
  padding-inline-end: var(--mantine-spacing-md);
}
.m_698f4f23 {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
}
.m_667f2a6a {
  line-height: 1;
  width: calc(1.25rem * var(--mantine-scale));
  height: calc(1.25rem * var(--mantine-scale));
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin-inline-end: var(--mantine-spacing-md);
  margin-top: calc(0.0625rem * var(--mantine-scale));
}
.m_7fa78076 {
  text-overflow: ellipsis;
  overflow: hidden;
  font-size: var(--mantine-font-size-sm);
}
:where([data-mantine-color-scheme=light]) .m_7fa78076 {
  color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=dark]) .m_7fa78076 {
  color: var(--mantine-color-white);
}
.m_7fa78076:where([data-variant=filled]) {
  color: var(--alert-color);
}
.m_7fa78076:where([data-variant=white]) {
  color: var(--mantine-color-black);
}
.m_87f54839 {
  width: calc(1.25rem * var(--mantine-scale));
  height: calc(1.25rem * var(--mantine-scale));
  color: var(--alert-color);
}
.m_b6d8b162 {
  -webkit-tap-highlight-color: transparent;
  text-decoration: none;
  font-size: var(--text-fz, var(--mantine-font-size-md));
  line-height: var(--text-lh, var(--mantine-line-height-md));
  font-weight: normal;
  margin: 0;
  padding: 0;
  color: var(--text-color);
}
.m_b6d8b162:where([data-truncate]) {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.m_b6d8b162:where([data-truncate=start]) {
  direction: rtl;
  text-align: right;
}
:where([dir=rtl]) .m_b6d8b162:where([data-truncate=start]) {
  direction: ltr;
  text-align: left;
}
.m_b6d8b162:where([data-variant=gradient]) {
  background-image: var(--text-gradient);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.m_b6d8b162:where([data-line-clamp]) {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: var(--text-line-clamp);
  -webkit-box-orient: vertical;
}
.m_b6d8b162:where([data-inherit]) {
  line-height: inherit;
  font-weight: inherit;
  font-size: inherit;
}
.m_b6d8b162:where([data-inline]) {
  line-height: 1;
}
.m_849cf0da {
  color: var(--mantine-color-anchor);
  text-decoration: none;
  appearance: none;
  border: none;
  display: inline;
  padding: 0;
  margin: 0;
  background-color: transparent;
  cursor: pointer;
}
@media (hover: hover) {
  .m_849cf0da:where([data-underline=hover]):hover {
    text-decoration: underline;
  }
}
@media (hover: none) {
  .m_849cf0da:where([data-underline=hover]):active {
    text-decoration: underline;
  }
}
.m_849cf0da:where([data-underline=not-hover]) {
  text-decoration: underline;
}
@media (hover: hover) {
  .m_849cf0da:where([data-underline=not-hover]):hover {
    text-decoration: none;
  }
}
@media (hover: none) {
  .m_849cf0da:where([data-underline=not-hover]):active {
    text-decoration: none;
  }
}
.m_849cf0da:where([data-underline=always]) {
  text-decoration: underline;
}
.m_849cf0da:where([data-variant=gradient]),
.m_849cf0da:where([data-variant=gradient]):hover {
  text-decoration: none;
}
.m_849cf0da:where([data-line-clamp]) {
  display: -webkit-box;
}
.m_48204f9b {
  width: var(--slider-size);
  height: var(--slider-size);
  position: relative;
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}
.m_48204f9b:focus-within {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.m_48204f9b {
  --slider-size: calc(3.75rem * var(--mantine-scale));
  --thumb-size: calc(var(--slider-size) / 5);
}
:where([data-mantine-color-scheme=light]) .m_48204f9b {
  background-color: var(--mantine-color-gray-1);
}
:where([data-mantine-color-scheme=dark]) .m_48204f9b {
  background-color: var(--mantine-color-dark-5);
}
.m_bb9cdbad {
  position: absolute;
  inset: calc(0.0625rem * var(--mantine-scale));
  border-radius: var(--slider-size);
  pointer-events: none;
}
.m_481dd586 {
  width: calc(0.125rem * var(--mantine-scale));
  position: absolute;
  top: 0;
  bottom: 0;
  left: calc(50% - 1px);
  transform: rotate(var(--angle));
}
.m_481dd586::before {
  content: "";
  position: absolute;
  top: calc(var(--thumb-size) / 3);
  left: calc(0.03125rem * var(--mantine-scale));
  width: calc(0.0625rem * var(--mantine-scale));
  height: calc(var(--thumb-size) / 1.5);
  transform: translate(-50%, -50%);
}
:where([data-mantine-color-scheme=light]) .m_481dd586::before {
  background-color: var(--mantine-color-gray-4);
}
:where([data-mantine-color-scheme=dark]) .m_481dd586::before {
  background-color: var(--mantine-color-dark-3);
}
.m_481dd586[data-label]::after {
  min-width: calc(1.125rem * var(--mantine-scale));
  text-align: center;
  content: attr(data-label);
  position: absolute;
  top: calc(-1.5rem * var(--mantine-scale));
  left: calc(-0.4375rem * var(--mantine-scale));
  transform: rotate(calc(360deg - var(--angle)));
  font-size: var(--mantine-font-size-xs);
}
.m_bc02ba3d {
  position: absolute;
  inset-block: 0;
  inset-inline-start: calc(50% - 1.5px);
  inset-inline-end: 0;
  height: 100%;
  width: calc(0.1875rem * var(--mantine-scale));
  outline: none;
  pointer-events: none;
}
.m_bc02ba3d::before {
  content: "";
  position: absolute;
  right: 0;
  top: 0;
  height: min(var(--thumb-size), calc(var(--slider-size) / 2));
  width: calc(0.1875rem * var(--mantine-scale));
}
:where([data-mantine-color-scheme=light]) .m_bc02ba3d::before {
  background-color: var(--mantine-color-gray-7);
}
:where([data-mantine-color-scheme=dark]) .m_bc02ba3d::before {
  background-color: var(--mantine-color-dark-1);
}
.m_bb8e875b {
  font-size: var(--mantine-font-size-xs);
}
.m_89ab340[data-resizing] {
  --app-shell-transition-duration: 0ms !important;
}
.m_89ab340[data-disabled] {
  --app-shell-header-offset: 0rem !important;
  --app-shell-navbar-offset: 0rem !important;
  --app-shell-aside-offset: 0rem !important;
  --app-shell-footer-offset: 0rem !important;
}
[data-mantine-color-scheme=light] .m_89ab340 {
  --app-shell-border-color: var(--mantine-color-gray-3);
}
[data-mantine-color-scheme=dark] .m_89ab340 {
  --app-shell-border-color: var(--mantine-color-dark-4);
}
.m_45252eee,
.m_9cdde9a,
.m_3b16f56b,
.m_8983817,
.m_3840c879 {
  transition-duration: var(--app-shell-transition-duration);
  transition-timing-function: var(--app-shell-transition-timing-function);
}
.m_45252eee,
.m_9cdde9a {
  position: fixed;
  display: flex;
  flex-direction: column;
  top: var(--app-shell-header-offset, 0rem);
  height: calc(100dvh - var(--app-shell-header-offset, 0rem) - var(--app-shell-footer-offset, 0rem));
  background-color: var(--mantine-color-body);
  transition-property:
    transform,
    top,
    height;
}
:where([data-layout=alt]) .m_45252eee,
:where([data-layout=alt]) .m_9cdde9a {
  top: 0rem;
  height: 100dvh;
}
.m_45252eee {
  inset-inline-start: 0;
  width: var(--app-shell-navbar-width);
  transition-property:
    transform,
    top,
    height;
  transform: var(--app-shell-navbar-transform);
  z-index: var(--app-shell-navbar-z-index);
}
:where([dir=rtl]) .m_45252eee {
  transform: var(--app-shell-navbar-transform-rtl);
}
.m_45252eee:where([data-with-border]) {
  border-inline-end: 1px solid var(--app-shell-border-color);
}
.m_9cdde9a {
  inset-inline-end: 0;
  width: var(--app-shell-aside-width);
  transform: var(--app-shell-aside-transform);
  z-index: var(--app-shell-aside-z-index);
}
:where([dir=rtl]) .m_9cdde9a {
  transform: var(--app-shell-aside-transform-rtl);
}
.m_9cdde9a:where([data-with-border]) {
  border-inline-start: 1px solid var(--app-shell-border-color);
}
.m_8983817 {
  padding-inline-start: calc(var(--app-shell-navbar-offset, 0rem) + var(--app-shell-padding));
  padding-inline-end: calc(var(--app-shell-aside-offset, 0rem) + var(--app-shell-padding));
  padding-top: calc(var(--app-shell-header-offset, 0rem) + var(--app-shell-padding));
  padding-bottom: calc(var(--app-shell-footer-offset, 0rem) + var(--app-shell-padding));
  min-height: 100dvh;
  transition-property: padding;
}
.m_3b16f56b,
.m_3840c879 {
  position: fixed;
  inset-inline: 0;
  transition-property:
    transform,
    left,
    right;
  background-color: var(--mantine-color-body);
}
:where([data-layout=alt]) .m_3b16f56b,
:where([data-layout=alt]) .m_3840c879 {
  inset-inline-start: var(--app-shell-navbar-offset, 0rem);
  inset-inline-end: var(--app-shell-aside-offset, 0rem);
}
.m_3b16f56b {
  top: 0;
  height: var(--app-shell-header-height);
  background-color: var(--mantine-color-body);
  transform: var(--app-shell-header-transform);
  z-index: var(--app-shell-header-z-index);
}
.m_3b16f56b:where([data-with-border]) {
  border-bottom: 1px solid var(--app-shell-border-color);
}
.m_3840c879 {
  bottom: 0;
  height: calc(var(--app-shell-footer-height) + env(safe-area-inset-bottom));
  padding-bottom: env(safe-area-inset-bottom);
  transform: var(--app-shell-footer-transform);
  z-index: var(--app-shell-footer-z-index);
}
.m_3840c879:where([data-with-border]) {
  border-top: 1px solid var(--app-shell-border-color);
}
.m_6dcfc7c7 {
  flex-grow: 0;
}
.m_6dcfc7c7:where([data-grow]) {
  flex-grow: 1;
}
.m_71ac47fc {
  --ar-ratio: 1;
  max-width: 100%;
}
.m_71ac47fc > :where(*:not(style)) {
  aspect-ratio: var(--ar-ratio);
  width: 100%;
}
.m_71ac47fc > :where(img, video) {
  object-fit: cover;
}
.m_88b62a41 {
  --combobox-padding: calc(0.25rem * var(--mantine-scale));
  padding: var(--combobox-padding);
}
.m_88b62a41:has([data-mantine-scrollbar]) .m_985517d8 {
  max-width: calc(100% + var(--combobox-padding));
}
.m_88b62a41[data-composed] {
  padding-inline-end: 0;
}
.m_88b62a41[data-hidden] {
  display: none;
}
.m_88b62a41,
.m_b2821a6e {
  --combobox-option-padding-xs: calc(0.25rem * var(--mantine-scale)) calc(0.5rem * var(--mantine-scale));
  --combobox-option-padding-sm: calc(0.375rem * var(--mantine-scale)) calc(0.625rem * var(--mantine-scale));
  --combobox-option-padding-md: calc(0.5rem * var(--mantine-scale)) calc(0.75rem * var(--mantine-scale));
  --combobox-option-padding-lg: calc(0.625rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));
  --combobox-option-padding-xl: calc(0.875rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));
  --combobox-option-padding: var(--combobox-option-padding-sm);
}
.m_92253aa5 {
  padding: var(--combobox-option-padding);
  font-size: var(--combobox-option-fz, var(--mantine-font-size-sm));
  border-radius: var(--mantine-radius-default);
  background-color: transparent;
  color: inherit;
  cursor: pointer;
  overflow-wrap: break-word;
}
.m_92253aa5:where([data-combobox-selected]) {
  background-color: var(--mantine-primary-color-filled);
  color: var(--mantine-color-white);
}
.m_92253aa5:where([data-combobox-disabled]) {
  cursor: not-allowed;
  opacity: 0.35;
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_92253aa5:hover:where(:not([data-combobox-selected], [data-combobox-disabled])) {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_92253aa5:hover:where(:not([data-combobox-selected], [data-combobox-disabled])) {
    background-color: var(--mantine-color-dark-7);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_92253aa5:active:where(:not([data-combobox-selected], [data-combobox-disabled])) {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_92253aa5:active:where(:not([data-combobox-selected], [data-combobox-disabled])) {
    background-color: var(--mantine-color-dark-7);
  }
}
.m_985517d8 {
  margin-inline: calc(var(--combobox-padding) * -1);
  margin-top: calc(var(--combobox-padding) * -1);
  width: calc(100% + var(--combobox-padding) * 2);
  border-top-width: 0;
  border-inline-width: 0;
  border-end-start-radius: 0;
  border-end-end-radius: 0;
  margin-bottom: var(--combobox-padding);
  position: relative;
}
:where([data-mantine-color-scheme=light]) .m_985517d8,
:where([data-mantine-color-scheme=light]) .m_985517d8:focus {
  border-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_985517d8,
:where([data-mantine-color-scheme=dark]) .m_985517d8:focus {
  border-color: var(--mantine-color-dark-4);
}
:where([data-mantine-color-scheme=light]) .m_985517d8 {
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_985517d8 {
  background-color: var(--mantine-color-dark-7);
}
.m_2530cd1d {
  font-size: var(--combobox-option-fz, var(--mantine-font-size-sm));
  text-align: center;
  padding: var(--combobox-option-padding);
  color: var(--mantine-color-dimmed);
}
.m_858f94bd,
.m_82b967cb {
  font-size: var(--combobox-option-fz, var(--mantine-font-size-sm));
  border: 0 solid transparent;
  margin-inline: calc(var(--combobox-padding) * -1);
  padding: var(--combobox-option-padding);
}
:where([data-mantine-color-scheme=light]) .m_858f94bd,
:where([data-mantine-color-scheme=light]) .m_82b967cb {
  border-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_858f94bd,
:where([data-mantine-color-scheme=dark]) .m_82b967cb {
  border-color: var(--mantine-color-dark-4);
}
.m_82b967cb {
  border-top-width: calc(0.0625rem * var(--mantine-scale));
  margin-top: var(--combobox-padding);
  margin-bottom: calc(var(--combobox-padding) * -1);
}
.m_858f94bd {
  border-bottom-width: calc(0.0625rem * var(--mantine-scale));
  margin-bottom: var(--combobox-padding);
  margin-top: calc(var(--combobox-padding) * -1);
}
.m_254f3e4f:has(.m_2bb2e9e5:only-child) {
  display: none;
}
.m_2bb2e9e5 {
  color: var(--mantine-color-dimmed);
  font-size: calc(var(--combobox-option-fz, var(--mantine-font-size-sm)) * 0.85);
  padding: var(--combobox-option-padding);
  font-weight: 500;
  position: relative;
  display: flex;
  align-items: center;
}
.m_2bb2e9e5::after {
  content: "";
  flex: 1;
  inset-inline: 0;
  height: calc(0.0625rem * var(--mantine-scale));
  margin-inline-start: var(--mantine-spacing-xs);
}
:where([data-mantine-color-scheme=light]) .m_2bb2e9e5::after {
  background-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_2bb2e9e5::after {
  background-color: var(--mantine-color-dark-4);
}
.m_2bb2e9e5:only-child {
  display: none;
}
.m_2943220b {
  --combobox-chevron-size-xs: calc(0.875rem * var(--mantine-scale));
  --combobox-chevron-size-sm: calc(1.125rem * var(--mantine-scale));
  --combobox-chevron-size-md: calc(1.25rem * var(--mantine-scale));
  --combobox-chevron-size-lg: calc(1.5rem * var(--mantine-scale));
  --combobox-chevron-size-xl: calc(1.75rem * var(--mantine-scale));
  --combobox-chevron-size: var(--combobox-chevron-size-sm);
}
:where([data-mantine-color-scheme=light]) .m_2943220b {
  --_combobox-chevron-color: var(--combobox-chevron-color, var(--mantine-color-gray-6));
}
:where([data-mantine-color-scheme=dark]) .m_2943220b {
  --_combobox-chevron-color: var(--combobox-chevron-color, var(--mantine-color-dark-3));
}
.m_2943220b {
  width: var(--combobox-chevron-size);
  height: var(--combobox-chevron-size);
  color: var(--_combobox-chevron-color);
}
.m_2943220b:where([data-error]) {
  color: var(--combobox-chevron-color, var(--mantine-color-error));
}
.m_390b5f4 {
  display: flex;
  align-items: center;
  gap: calc(0.5rem * var(--mantine-scale));
}
.m_390b5f4:where([data-reverse]) {
  justify-content: space-between;
}
.m_8ee53fc2 {
  opacity: 0.4;
  width: 0.8em;
  min-width: 0.8em;
  height: 0.8em;
}
:where([data-combobox-selected]) .m_8ee53fc2 {
  opacity: 1;
}
.m_5f75b09e {
  --label-lh-xs: calc(1rem * var(--mantine-scale));
  --label-lh-sm: calc(1.25rem * var(--mantine-scale));
  --label-lh-md: calc(1.5rem * var(--mantine-scale));
  --label-lh-lg: calc(1.875rem * var(--mantine-scale));
  --label-lh-xl: calc(2.25rem * var(--mantine-scale));
  --label-lh: var(--label-lh-sm);
}
.m_5f75b09e[data-label-position=left] {
  --label-order: 1;
  --label-offset-end: var(--mantine-spacing-sm);
  --label-offset-start: 0;
}
.m_5f75b09e[data-label-position=right] {
  --label-order: 2;
  --label-offset-end: 0;
  --label-offset-start: var(--mantine-spacing-sm);
}
.m_5f6e695e {
  -webkit-tap-highlight-color: transparent;
  display: flex;
}
.m_d3ea56bb {
  --label-cursor: var(--mantine-cursor-type);
  -webkit-tap-highlight-color: transparent;
  display: inline-flex;
  flex-direction: column;
  font-size: var(--label-fz, var(--mantine-font-size-sm));
  line-height: var(--label-lh);
  cursor: var(--label-cursor);
  order: var(--label-order);
}
fieldset:disabled .m_d3ea56bb,
.m_d3ea56bb[data-disabled] {
  --label-cursor: not-allowed;
}
.m_8ee546b8 {
  cursor: var(--label-cursor);
  color: inherit;
  padding-inline-start: var(--label-offset-start);
  padding-inline-end: var(--label-offset-end);
}
fieldset:disabled .m_8ee546b8,
.m_8ee546b8:where([data-disabled]) {
  color: var(--mantine-color-disabled-color);
}
.m_328f68c0 {
  margin-top: calc(var(--mantine-spacing-xs) / 2);
  padding-inline-start: var(--label-offset-start);
  padding-inline-end: var(--label-offset-end);
}
.m_8e8a99cc {
  margin-top: calc(var(--mantine-spacing-xs) / 2);
  padding-inline-start: var(--label-offset-start);
  padding-inline-end: var(--label-offset-end);
}
.m_26775b0a {
  --card-radius: var(--mantine-radius-default);
  display: block;
  width: 100%;
  border-radius: var(--card-radius);
  cursor: pointer;
}
.m_26775b0a :where(*) {
  cursor: inherit;
}
.m_26775b0a:where([data-with-border]) {
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
}
:where([data-mantine-color-scheme=light]) .m_26775b0a:where([data-with-border]) {
  border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_26775b0a:where([data-with-border]) {
  border-color: var(--mantine-color-dark-4);
}
.m_5e5256ee {
  --checkbox-size-xs: calc(1rem * var(--mantine-scale));
  --checkbox-size-sm: calc(1.25rem * var(--mantine-scale));
  --checkbox-size-md: calc(1.5rem * var(--mantine-scale));
  --checkbox-size-lg: calc(1.875rem * var(--mantine-scale));
  --checkbox-size-xl: calc(2.25rem * var(--mantine-scale));
  --checkbox-size: var(--checkbox-size-sm);
  --checkbox-color: var(--mantine-primary-color-filled);
}
.m_5e5256ee:where([data-variant=filled]) {
  --checkbox-icon-color: var(--mantine-color-white);
}
.m_5e5256ee:where([data-variant=outline]) {
  --checkbox-icon-color: var(--checkbox-color);
}
.m_5e5256ee {
  position: relative;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  width: var(--checkbox-size);
  min-width: var(--checkbox-size);
  height: var(--checkbox-size);
  min-height: var(--checkbox-size);
  border-radius: var(--checkbox-radius, var(--mantine-radius-default));
  transition: border-color 100ms ease, background-color 100ms ease;
  cursor: var(--mantine-cursor-type);
  -webkit-tap-highlight-color: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
}
:where([data-mantine-color-scheme=light]) .m_5e5256ee {
  background-color: var(--mantine-color-white);
  border-color: var(--mantine-color-gray-4);
}
:where([data-mantine-color-scheme=dark]) .m_5e5256ee {
  background-color: var(--mantine-color-dark-6);
  border-color: var(--mantine-color-dark-4);
}
.m_5e5256ee[data-indeterminate],
.m_5e5256ee[data-checked] {
  background-color: var(--checkbox-color);
  border-color: var(--checkbox-color);
}
.m_5e5256ee[data-indeterminate] > .m_1b1c543a,
.m_5e5256ee[data-checked] > .m_1b1c543a {
  opacity: 1;
  transform: none;
  color: var(--checkbox-icon-color);
}
.m_5e5256ee[data-disabled] {
  cursor: not-allowed;
  border-color: var(--mantine-color-disabled-border);
  background-color: var(--mantine-color-disabled);
}
[data-mantine-color-scheme=light] .m_5e5256ee[data-disabled][data-checked] > .m_1b1c543a {
  color: var(--mantine-color-gray-5);
}
[data-mantine-color-scheme=dark] .m_5e5256ee[data-disabled][data-checked] > .m_1b1c543a {
  color: var(--mantine-color-dark-3);
}
.m_76e20374[data-indeterminate]:not([data-disabled]),
.m_76e20374[data-checked]:not([data-disabled]) {
  background-color: transparent;
  border-color: var(--checkbox-color);
}
.m_76e20374[data-indeterminate]:not([data-disabled]) > .m_1b1c543a,
.m_76e20374[data-checked]:not([data-disabled]) > .m_1b1c543a {
  color: var(--checkbox-icon-color);
  opacity: 1;
  transform: none;
}
.m_1b1c543a {
  display: block;
  width: 60%;
  color: transparent;
  pointer-events: none;
  transform: translateY(calc(0.3125rem * var(--mantine-scale))) scale(0.5);
  opacity: 1;
  transition: transform 100ms ease, opacity 100ms ease;
}
.m_bf2d988c {
  --checkbox-size-xs: calc(1rem * var(--mantine-scale));
  --checkbox-size-sm: calc(1.25rem * var(--mantine-scale));
  --checkbox-size-md: calc(1.5rem * var(--mantine-scale));
  --checkbox-size-lg: calc(1.875rem * var(--mantine-scale));
  --checkbox-size-xl: calc(2.25rem * var(--mantine-scale));
  --checkbox-size: var(--checkbox-size-sm);
  --checkbox-color: var(--mantine-primary-color-filled);
}
.m_bf2d988c:where([data-variant=filled]) {
  --checkbox-icon-color: var(--mantine-color-white);
}
.m_bf2d988c:where([data-variant=outline]) {
  --checkbox-icon-color: var(--checkbox-color);
}
.m_26062bec {
  position: relative;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  order: 1;
}
.m_26062bec:where([data-label-position=left]) {
  order: 2;
}
.m_26063560 {
  appearance: none;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--checkbox-radius, var(--mantine-radius-default));
  padding: 0;
  display: block;
  margin: 0;
  transition: border-color 100ms ease, background-color 100ms ease;
  cursor: var(--mantine-cursor-type);
  -webkit-tap-highlight-color: transparent;
}
:where([data-mantine-color-scheme=light]) .m_26063560 {
  background-color: var(--mantine-color-white);
  border-color: var(--mantine-color-gray-4);
}
:where([data-mantine-color-scheme=dark]) .m_26063560 {
  background-color: var(--mantine-color-dark-6);
  border-color: var(--mantine-color-dark-4);
}
.m_26063560:where([data-error]) {
  border-color: var(--mantine-color-error);
}
.m_26063560[data-indeterminate],
.m_26063560:checked {
  background-color: var(--checkbox-color);
  border-color: var(--checkbox-color);
}
.m_26063560[data-indeterminate] + .m_bf295423,
.m_26063560:checked + .m_bf295423 {
  opacity: 1;
  transform: none;
}
.m_26063560:disabled {
  cursor: not-allowed;
  border-color: var(--mantine-color-disabled-border);
  background-color: var(--mantine-color-disabled);
}
.m_26063560:disabled + .m_bf295423 {
  color: var(--mantine-color-disabled-color);
}
.m_215c4542 + .m_bf295423 {
  color: var(--checkbox-color);
}
.m_215c4542[data-indeterminate]:not(:disabled),
.m_215c4542:checked:not(:disabled) {
  background-color: transparent;
  border-color: var(--checkbox-color);
}
.m_215c4542[data-indeterminate]:not(:disabled) + .m_bf295423,
.m_215c4542:checked:not(:disabled) + .m_bf295423 {
  color: var(--checkbox-icon-color);
  opacity: 1;
  transform: none;
}
.m_bf295423 {
  position: absolute;
  inset: 0;
  width: 60%;
  margin: auto;
  color: var(--checkbox-icon-color);
  pointer-events: none;
  transform: translateY(calc(0.3125rem * var(--mantine-scale))) scale(0.5);
  opacity: 0;
  transition: transform 100ms ease, opacity 100ms ease;
}
.m_11def92b {
  --ag-spacing: var(--mantine-spacing-sm);
  --ag-offset: calc(var(--ag-spacing) * -1);
  display: flex;
  padding-inline-start: var(--ag-spacing);
}
.m_f85678b6 {
  --avatar-size-xs: calc(1rem * var(--mantine-scale));
  --avatar-size-sm: calc(1.625rem * var(--mantine-scale));
  --avatar-size-md: calc(2.375rem * var(--mantine-scale));
  --avatar-size-lg: calc(3.5rem * var(--mantine-scale));
  --avatar-size-xl: calc(5.25rem * var(--mantine-scale));
  --avatar-size: var(--avatar-size-md);
  --avatar-radius: calc(62.5rem * var(--mantine-scale));
  --avatar-bg: var(--mantine-color-gray-light);
  --avatar-bd: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  --avatar-color: var(--mantine-color-gray-light-color);
  --avatar-placeholder-fz: calc(var(--avatar-size) / 2.5);
  -webkit-tap-highlight-color: transparent;
  position: relative;
  display: block;
  user-select: none;
  overflow: hidden;
  border-radius: var(--avatar-radius);
  text-decoration: none;
  padding: 0;
  width: var(--avatar-size);
  height: var(--avatar-size);
  min-width: var(--avatar-size);
}
.m_f85678b6:where([data-within-group]) {
  margin-inline-start: var(--ag-offset);
  border: 2px solid var(--mantine-color-body);
  background: var(--mantine-color-body);
}
.m_11f8ac07 {
  object-fit: cover;
  width: 100%;
  height: 100%;
  display: block;
}
.m_104cd71f {
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  user-select: none;
  border-radius: var(--avatar-radius);
  font-size: var(--avatar-placeholder-fz);
  background: var(--avatar-bg);
  border: var(--avatar-bd);
  color: var(--avatar-color);
}
.m_104cd71f > [data-avatar-placeholder-icon] {
  width: 70%;
  height: 70%;
}
.m_2ce0de02 {
  background-size: cover;
  background-position: center;
  display: block;
  width: 100%;
  border: 0;
  text-decoration: none;
  border-radius: var(--bi-radius, 0);
}
.m_347db0ec {
  --badge-height-xs: calc(1rem * var(--mantine-scale));
  --badge-height-sm: calc(1.125rem * var(--mantine-scale));
  --badge-height-md: calc(1.25rem * var(--mantine-scale));
  --badge-height-lg: calc(1.625rem * var(--mantine-scale));
  --badge-height-xl: calc(2rem * var(--mantine-scale));
  --badge-fz-xs: calc(0.5625rem * var(--mantine-scale));
  --badge-fz-sm: calc(0.625rem * var(--mantine-scale));
  --badge-fz-md: calc(0.6875rem * var(--mantine-scale));
  --badge-fz-lg: calc(0.8125rem * var(--mantine-scale));
  --badge-fz-xl: calc(1rem * var(--mantine-scale));
  --badge-padding-x-xs: calc(0.375rem * var(--mantine-scale));
  --badge-padding-x-sm: calc(0.5rem * var(--mantine-scale));
  --badge-padding-x-md: calc(0.625rem * var(--mantine-scale));
  --badge-padding-x-lg: calc(0.75rem * var(--mantine-scale));
  --badge-padding-x-xl: calc(1rem * var(--mantine-scale));
  --badge-height: var(--badge-height-md);
  --badge-fz: var(--badge-fz-md);
  --badge-padding-x: var(--badge-padding-x-md);
  --badge-radius: calc(62.5rem * var(--mantine-scale));
  --badge-lh: calc(var(--badge-height) - calc(0.125rem * var(--mantine-scale)));
  --badge-color: var(--mantine-color-white);
  --badge-bg: var(--mantine-primary-color-filled);
  --badge-border-width: calc(0.0625rem * var(--mantine-scale));
  --badge-bd: var(--badge-border-width) solid transparent;
  -webkit-tap-highlight-color: transparent;
  font-size: var(--badge-fz);
  border-radius: var(--badge-radius);
  height: var(--badge-height);
  line-height: var(--badge-lh);
  text-decoration: none;
  padding: 0 var(--badge-padding-x);
  display: inline-grid;
  align-items: center;
  justify-content: center;
  width: fit-content;
  text-transform: uppercase;
  font-weight: 700;
  letter-spacing: calc(0.015625rem * var(--mantine-scale));
  cursor: default;
  text-overflow: ellipsis;
  overflow: hidden;
  color: var(--badge-color);
  background: var(--badge-bg);
  border: var(--badge-bd);
}
.m_347db0ec:where([data-with-left-section], [data-variant=dot]) {
  grid-template-columns: auto 1fr;
}
.m_347db0ec:where([data-with-right-section]) {
  grid-template-columns: 1fr auto;
}
.m_347db0ec:where([data-with-left-section][data-with-right-section], [data-variant=dot][data-with-right-section]) {
  grid-template-columns: auto 1fr auto;
}
.m_347db0ec:where([data-block]) {
  display: flex;
  width: 100%;
}
.m_347db0ec:where([data-circle]) {
  padding-inline: calc(0.125rem * var(--mantine-scale));
  display: flex;
  width: var(--badge-height);
}
.m_fbd81e3d {
  --badge-dot-size: calc(var(--badge-height) / 3.4);
}
:where([data-mantine-color-scheme=light]) .m_fbd81e3d {
  background-color: var(--mantine-color-white);
  border-color: var(--mantine-color-gray-4);
  color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=dark]) .m_fbd81e3d {
  background-color: var(--mantine-color-dark-5);
  border-color: var(--mantine-color-dark-5);
  color: var(--mantine-color-white);
}
.m_fbd81e3d::before {
  content: "";
  display: block;
  width: var(--badge-dot-size);
  height: var(--badge-dot-size);
  border-radius: var(--badge-dot-size);
  background-color: var(--badge-dot-color);
  margin-inline-end: var(--badge-dot-size);
}
.m_5add502a {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: center;
  cursor: inherit;
}
.m_91fdda9b {
  --badge-section-margin: calc(var(--mantine-spacing-xs) / 2);
  display: inline-flex;
  justify-content: center;
  align-items: center;
  max-height: calc(var(--badge-height) - var(--badge-border-width) * 2);
}
.m_91fdda9b:where([data-position=left]) {
  margin-inline-end: var(--badge-section-margin);
}
.m_91fdda9b:where([data-position=right]) {
  margin-inline-start: var(--badge-section-margin);
}
.m_ddec01c0 {
  --blockquote-border: 3px solid var(--bq-bd);
  position: relative;
  margin: 0;
  border-inline-start: var(--blockquote-border);
  border-start-end-radius: var(--bq-radius);
  border-end-end-radius: var(--bq-radius);
  padding: var(--mantine-spacing-xl) calc(2.375rem * var(--mantine-scale));
}
:where([data-mantine-color-scheme=light]) .m_ddec01c0 {
  background-color: var(--bq-bg-light);
}
:where([data-mantine-color-scheme=dark]) .m_ddec01c0 {
  background-color: var(--bq-bg-dark);
}
.m_dde7bd57 {
  --blockquote-icon-offset: calc(var(--bq-icon-size) / -2);
  position: absolute;
  color: var(--bq-bd);
  background-color: var(--mantine-color-body);
  display: flex;
  align-items: center;
  justify-content: center;
  top: var(--blockquote-icon-offset);
  inset-inline-start: var(--blockquote-icon-offset);
  width: var(--bq-icon-size);
  height: var(--bq-icon-size);
  border-radius: var(--bq-icon-size);
}
.m_dde51a35 {
  display: block;
  margin-top: var(--mantine-spacing-md);
  opacity: 0.6;
  font-size: 85%;
}
.m_8b3717df {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}
.m_f678d540 {
  line-height: 1;
  white-space: nowrap;
  -webkit-tap-highlight-color: transparent;
}
.m_3b8f2208 {
  margin-inline: var(--bc-separator-margin, var(--mantine-spacing-xs));
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}
:where([data-mantine-color-scheme=light]) .m_3b8f2208 {
  color: var(--mantine-color-gray-7);
}
:where([data-mantine-color-scheme=dark]) .m_3b8f2208 {
  color: var(--mantine-color-dark-2);
}
.m_fea6bf1a {
  --burger-size-xs: calc(0.75rem * var(--mantine-scale));
  --burger-size-sm: calc(1.125rem * var(--mantine-scale));
  --burger-size-md: calc(1.5rem * var(--mantine-scale));
  --burger-size-lg: calc(2.125rem * var(--mantine-scale));
  --burger-size-xl: calc(2.625rem * var(--mantine-scale));
  --burger-size: var(--burger-size-md);
  --burger-line-size: calc(var(--burger-size) / 12);
  width: calc(var(--burger-size) + var(--mantine-spacing-xs));
  height: calc(var(--burger-size) + var(--mantine-spacing-xs));
  padding: calc(var(--mantine-spacing-xs) / 2);
  cursor: pointer;
}
:where([data-mantine-color-scheme=light]) .m_fea6bf1a {
  --burger-color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=dark]) .m_fea6bf1a {
  --burger-color: var(--mantine-color-white);
}
.m_d4fb9cad {
  position: relative;
  user-select: none;
}
.m_d4fb9cad,
.m_d4fb9cad::before,
.m_d4fb9cad::after {
  display: block;
  width: var(--burger-size);
  height: var(--burger-line-size);
  background-color: var(--burger-color);
  outline: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  transition-property: background-color, transform;
  transition-duration: var(--burger-transition-duration, 300ms);
  transition-timing-function: var(--burger-transition-timing-function, ease);
}
.m_d4fb9cad::before,
.m_d4fb9cad::after {
  position: absolute;
  content: "";
  inset-inline-start: 0;
}
.m_d4fb9cad::before {
  top: calc(var(--burger-size) / -3);
}
.m_d4fb9cad::after {
  top: calc(var(--burger-size) / 3);
}
.m_d4fb9cad[data-opened] {
  background-color: transparent;
}
.m_d4fb9cad[data-opened]::before {
  transform: translateY(calc(var(--burger-size) / 3)) rotate(45deg);
}
.m_d4fb9cad[data-opened]::after {
  transform: translateY(calc(var(--burger-size) / -3)) rotate(-45deg);
}
.m_77c9d27d {
  --button-height-xs: calc(1.875rem * var(--mantine-scale));
  --button-height-sm: calc(2.25rem * var(--mantine-scale));
  --button-height-md: calc(2.625rem * var(--mantine-scale));
  --button-height-lg: calc(3.125rem * var(--mantine-scale));
  --button-height-xl: calc(3.75rem * var(--mantine-scale));
  --button-height-compact-xs: calc(1.375rem * var(--mantine-scale));
  --button-height-compact-sm: calc(1.625rem * var(--mantine-scale));
  --button-height-compact-md: calc(1.875rem * var(--mantine-scale));
  --button-height-compact-lg: calc(2.125rem * var(--mantine-scale));
  --button-height-compact-xl: calc(2.5rem * var(--mantine-scale));
  --button-padding-x-xs: calc(0.875rem * var(--mantine-scale));
  --button-padding-x-sm: calc(1.125rem * var(--mantine-scale));
  --button-padding-x-md: calc(1.375rem * var(--mantine-scale));
  --button-padding-x-lg: calc(1.625rem * var(--mantine-scale));
  --button-padding-x-xl: calc(2rem * var(--mantine-scale));
  --button-padding-x-compact-xs: calc(0.4375rem * var(--mantine-scale));
  --button-padding-x-compact-sm: calc(0.5rem * var(--mantine-scale));
  --button-padding-x-compact-md: calc(0.625rem * var(--mantine-scale));
  --button-padding-x-compact-lg: calc(0.75rem * var(--mantine-scale));
  --button-padding-x-compact-xl: calc(0.875rem * var(--mantine-scale));
  --button-height: var(--button-height-sm);
  --button-padding-x: var(--button-padding-x-sm);
  --button-color: var(--mantine-color-white);
  user-select: none;
  font-weight: 600;
  position: relative;
  line-height: 1;
  text-align: center;
  overflow: hidden;
  width: auto;
  cursor: pointer;
  display: inline-block;
  border-radius: var(--button-radius, var(--mantine-radius-default));
  font-size: var(--button-fz, var(--mantine-font-size-sm));
  background: var(--button-bg, var(--mantine-primary-color-filled));
  border: var(--button-bd, calc(0.0625rem * var(--mantine-scale)) solid transparent);
  color: var(--button-color, var(--mantine-color-white));
  height: var(--button-height, var(--button-height-sm));
  padding-inline: var(--button-padding-x, var(--button-padding-x-sm));
  vertical-align: middle;
}
.m_77c9d27d:where([data-block]) {
  display: block;
  width: 100%;
}
.m_77c9d27d:where([data-with-left-section]) {
  padding-inline-start: calc(var(--button-padding-x) / 1.5);
}
.m_77c9d27d:where([data-with-right-section]) {
  padding-inline-end: calc(var(--button-padding-x) / 1.5);
}
.m_77c9d27d:where(:disabled:not([data-loading]), [data-disabled]:not([data-loading])) {
  cursor: not-allowed;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  transform: none;
  color: var(--mantine-color-disabled-color);
  background: var(--mantine-color-disabled);
}
.m_77c9d27d::before {
  content: "";
  pointer-events: none;
  position: absolute;
  inset: calc(-0.0625rem * var(--mantine-scale));
  border-radius: var(--button-radius, var(--mantine-radius-default));
  transform: translateY(-100%);
  opacity: 0;
  filter: blur(12px);
  transition: transform 150ms ease, opacity 100ms ease;
}
:where([data-mantine-color-scheme=light]) .m_77c9d27d::before {
  background-color: rgba(255, 255, 255, 0.15);
}
:where([data-mantine-color-scheme=dark]) .m_77c9d27d::before {
  background-color: rgba(0, 0, 0, 0.15);
}
.m_77c9d27d:where([data-loading]) {
  cursor: not-allowed;
  transform: none;
}
.m_77c9d27d:where([data-loading])::before {
  transform: translateY(0);
  opacity: 1;
}
.m_77c9d27d:where([data-loading]) .m_80f1301b {
  opacity: 0;
  transform: translateY(100%);
}
@media (hover: hover) {
  .m_77c9d27d:hover:where(:not([data-loading], :disabled, [data-disabled])) {
    background-color: var(--button-hover, var(--mantine-primary-color-filled-hover));
    color: var(--button-hover-color, var(--button-color));
  }
}
@media (hover: none) {
  .m_77c9d27d:active:where(:not([data-loading], :disabled, [data-disabled])) {
    background-color: var(--button-hover, var(--mantine-primary-color-filled-hover));
    color: var(--button-hover-color, var(--button-color));
  }
}
.m_80f1301b {
  display: flex;
  align-items: center;
  justify-content: var(--button-justify, center);
  height: 100%;
  overflow: visible;
  transition: transform 150ms ease, opacity 100ms ease;
}
.m_811560b9 {
  white-space: nowrap;
  height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  opacity: 1;
}
.m_811560b9:where([data-loading]) {
  opacity: 0.2;
}
.m_a74036a {
  display: flex;
  align-items: center;
}
.m_a74036a:where([data-position=left]) {
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_a74036a:where([data-position=right]) {
  margin-inline-start: var(--mantine-spacing-xs);
}
.m_a25b86ee {
  position: absolute;
  left: 50%;
  top: 50%;
}
.m_80d6d844 {
  --button-border-width: calc(0.0625rem * var(--mantine-scale));
  display: flex;
}
.m_80d6d844 :where(.m_77c9d27d):focus {
  position: relative;
  z-index: 1;
}
.m_80d6d844[data-orientation=horizontal] {
  flex-direction: row;
}
.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):first-child,
.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):first-child {
  border-end-end-radius: 0;
  border-start-end-radius: 0;
  border-inline-end-width: calc(var(--button-border-width) / 2);
}
.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):last-child,
.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):last-child {
  border-end-start-radius: 0;
  border-start-start-radius: 0;
  border-inline-start-width: calc(var(--button-border-width) / 2);
}
.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child),
.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):not(:first-child):not(:last-child) {
  border-radius: 0;
  border-inline-width: calc(var(--button-border-width) / 2);
}
.m_80d6d844[data-orientation=vertical] {
  flex-direction: column;
}
.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):first-child,
.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):first-child {
  border-end-start-radius: 0;
  border-end-end-radius: 0;
  border-bottom-width: calc(var(--button-border-width) / 2);
}
.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):last-child,
.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):last-child {
  border-start-start-radius: 0;
  border-start-end-radius: 0;
  border-top-width: calc(var(--button-border-width) / 2);
}
.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child),
.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):not(:first-child):not(:last-child) {
  border-radius: 0;
  border-bottom-width: calc(var(--button-border-width) / 2);
  border-top-width: calc(var(--button-border-width) / 2);
}
.m_70be2a01 {
  --section-height-xs: calc(1.875rem * var(--mantine-scale));
  --section-height-sm: calc(2.25rem * var(--mantine-scale));
  --section-height-md: calc(2.625rem * var(--mantine-scale));
  --section-height-lg: calc(3.125rem * var(--mantine-scale));
  --section-height-xl: calc(3.75rem * var(--mantine-scale));
  --section-height-compact-xs: calc(1.375rem * var(--mantine-scale));
  --section-height-compact-sm: calc(1.625rem * var(--mantine-scale));
  --section-height-compact-md: calc(1.875rem * var(--mantine-scale));
  --section-height-compact-lg: calc(2.125rem * var(--mantine-scale));
  --section-height-compact-xl: calc(2.5rem * var(--mantine-scale));
  --section-padding-x-xs: calc(0.875rem * var(--mantine-scale));
  --section-padding-x-sm: calc(1.125rem * var(--mantine-scale));
  --section-padding-x-md: calc(1.375rem * var(--mantine-scale));
  --section-padding-x-lg: calc(1.625rem * var(--mantine-scale));
  --section-padding-x-xl: calc(2rem * var(--mantine-scale));
  --section-padding-x-compact-xs: calc(0.4375rem * var(--mantine-scale));
  --section-padding-x-compact-sm: calc(0.5rem * var(--mantine-scale));
  --section-padding-x-compact-md: calc(0.625rem * var(--mantine-scale));
  --section-padding-x-compact-lg: calc(0.75rem * var(--mantine-scale));
  --section-padding-x-compact-xl: calc(0.875rem * var(--mantine-scale));
  --section-height: var(--section-height-sm);
  --section-padding-x: var(--section-padding-x-sm);
  --section-color: var(--mantine-color-white);
  font-weight: 600;
  width: auto;
  border-radius: var(--section-radius, var(--mantine-radius-default));
  font-size: var(--section-fz, var(--mantine-font-size-sm));
  background: var(--section-bg, var(--mantine-primary-color-filled));
  border: var(--section-bd, calc(0.0625rem * var(--mantine-scale)) solid transparent);
  color: var(--section-color, var(--mantine-color-white));
  height: var(--section-height, var(--section-height-sm));
  padding-inline: var(--section-padding-x, var(--section-padding-x-sm));
  vertical-align: middle;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.m_e615b15f {
  --card-padding: var(--mantine-spacing-md);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  padding: var(--card-padding);
  color: var(--mantine-color-text);
}
:where([data-mantine-color-scheme=light]) .m_e615b15f {
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_e615b15f {
  background-color: var(--mantine-color-dark-6);
}
.m_599a2148 {
  display: block;
  margin-inline: calc(var(--card-padding) * -1);
}
.m_599a2148:where(:first-child) {
  margin-top: calc(var(--card-padding) * -1);
  border-top: none !important;
}
.m_599a2148:where(:last-child) {
  margin-bottom: calc(var(--card-padding) * -1);
  border-bottom: none !important;
}
.m_599a2148:where([data-inherit-padding]) {
  padding-inline: var(--card-padding);
}
.m_599a2148:where([data-with-border]) {
  border-top: calc(0.0625rem * var(--mantine-scale)) solid;
  border-bottom: calc(0.0625rem * var(--mantine-scale)) solid;
}
:where([data-mantine-color-scheme=light]) .m_599a2148 {
  border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_599a2148 {
  border-color: var(--mantine-color-dark-4);
}
.m_599a2148 + .m_599a2148 {
  border-top: none !important;
}
.m_4451eb3a {
  display: flex;
  align-items: center;
  justify-content: center;
}
.m_4451eb3a:where([data-inline]) {
  display: inline-flex;
}
.m_f59ffda3 {
  --chip-size-xs: calc(1.4375rem * var(--mantine-scale));
  --chip-size-sm: calc(1.75rem * var(--mantine-scale));
  --chip-size-md: calc(2rem * var(--mantine-scale));
  --chip-size-lg: calc(2.25rem * var(--mantine-scale));
  --chip-size-xl: calc(2.5rem * var(--mantine-scale));
  --chip-icon-size-xs: calc(0.625rem * var(--mantine-scale));
  --chip-icon-size-sm: calc(0.75rem * var(--mantine-scale));
  --chip-icon-size-md: calc(0.875rem * var(--mantine-scale));
  --chip-icon-size-lg: calc(1rem * var(--mantine-scale));
  --chip-icon-size-xl: calc(1.125rem * var(--mantine-scale));
  --chip-padding-xs: calc(1rem * var(--mantine-scale));
  --chip-padding-sm: calc(1.25rem * var(--mantine-scale));
  --chip-padding-md: calc(1.5rem * var(--mantine-scale));
  --chip-padding-lg: calc(1.75rem * var(--mantine-scale));
  --chip-padding-xl: calc(2rem * var(--mantine-scale));
  --chip-checked-padding-xs: calc(0.46875rem * var(--mantine-scale));
  --chip-checked-padding-sm: calc(0.625rem * var(--mantine-scale));
  --chip-checked-padding-md: calc(0.73125rem * var(--mantine-scale));
  --chip-checked-padding-lg: calc(0.84375rem * var(--mantine-scale));
  --chip-checked-padding-xl: calc(0.98125rem * var(--mantine-scale));
  --chip-spacing-xs: calc(0.625rem * var(--mantine-scale));
  --chip-spacing-sm: calc(0.75rem * var(--mantine-scale));
  --chip-spacing-md: calc(1rem * var(--mantine-scale));
  --chip-spacing-lg: calc(1.25rem * var(--mantine-scale));
  --chip-spacing-xl: calc(1.375rem * var(--mantine-scale));
  --chip-size: var(--chip-size-sm);
  --chip-icon-size: var(--chip-icon-size-sm);
  --chip-padding: var(--chip-padding-sm);
  --chip-spacing: var(--chip-spacing-sm);
  --chip-checked-padding: var(--chip-checked-padding-sm);
  --chip-bg: var(--mantine-primary-color-filled);
  --chip-hover: var(--mantine-primary-color-filled-hover);
  --chip-color: var(--mantine-color-white);
  --chip-bd: calc(0.0625rem * var(--mantine-scale)) solid transparent;
}
.m_be049a53 {
  display: inline-flex;
  align-items: center;
  user-select: none;
  border-radius: var(--chip-radius, 1000rem);
  height: var(--chip-size);
  font-size: var(--chip-fz, var(--mantine-font-size-sm));
  line-height: calc(var(--chip-size) - calc(0.125rem * var(--mantine-scale)));
  padding-inline: var(--chip-padding);
  cursor: pointer;
  white-space: nowrap;
  -webkit-tap-highlight-color: transparent;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  color: var(--mantine-color-text);
}
.m_be049a53:where([data-checked]) {
  padding: var(--chip-checked-padding);
}
.m_be049a53:where([data-disabled]) {
  cursor: not-allowed;
  background-color: var(--mantine-color-disabled);
  color: var(--mantine-color-disabled-color);
}
:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]) {
  background-color: var(--mantine-color-white);
  border: 1px solid var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]) {
  background-color: var(--mantine-color-dark-6);
  border: 1px solid var(--mantine-color-dark-4);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):hover {
    background-color: var(--mantine-color-dark-5);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):active {
    background-color: var(--mantine-color-dark-5);
  }
}
.m_3904c1af:not([data-disabled]):where([data-checked]) {
  --chip-icon-color: var(--chip-color);
  border: var(--chip-bd);
}
@media (hover: hover) {
  .m_3904c1af:not([data-disabled]):where([data-checked]):hover {
    background-color: var(--chip-hover);
  }
}
@media (hover: none) {
  .m_3904c1af:not([data-disabled]):where([data-checked]):active {
    background-color: var(--chip-hover);
  }
}
.m_fa109255:not([data-disabled]),
.m_f7e165c3:not([data-disabled]) {
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  color: var(--mantine-color-text);
}
:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]),
:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]) {
  background-color: var(--mantine-color-gray-1);
}
:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]),
:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]) {
  background-color: var(--mantine-color-dark-5);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):hover,
  :where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):hover {
    background-color: var(--mantine-color-gray-2);
  }
  :where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):hover,
  :where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):hover {
    background-color: var(--mantine-color-dark-4);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):active,
  :where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):active {
    background-color: var(--mantine-color-gray-2);
  }
  :where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):active,
  :where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):active {
    background-color: var(--mantine-color-dark-4);
  }
}
.m_fa109255:not([data-disabled]):where([data-checked]),
.m_f7e165c3:not([data-disabled]):where([data-checked]) {
  --chip-icon-color: var(--chip-color);
  color: var(--chip-color);
  background-color: var(--chip-bg);
}
@media (hover: hover) {
  .m_fa109255:not([data-disabled]):where([data-checked]):hover,
  .m_f7e165c3:not([data-disabled]):where([data-checked]):hover {
    background-color: var(--chip-hover);
  }
}
@media (hover: none) {
  .m_fa109255:not([data-disabled]):where([data-checked]):active,
  .m_f7e165c3:not([data-disabled]):where([data-checked]):active {
    background-color: var(--chip-hover);
  }
}
.m_9ac86df9 {
  width: calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));
  max-width: calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));
  height: var(--chip-icon-size);
  display: flex;
  align-items: center;
  overflow: hidden;
}
.m_d6d72580 {
  width: var(--chip-icon-size);
  height: var(--chip-icon-size);
  display: block;
  color: var(--chip-icon-color, inherit);
}
.m_bde07329 {
  width: 0;
  height: 0;
  padding: 0;
  opacity: 0;
  margin: 0;
}
.m_bde07329:focus-visible + .m_be049a53 {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.m_b183c0a2 {
  font-family: var(--mantine-font-family-monospace);
  line-height: var(--mantine-line-height);
  padding: 2px calc(var(--mantine-spacing-xs) / 2);
  border-radius: var(--mantine-radius-sm);
  font-size: var(--mantine-font-size-xs);
  margin: 0;
  overflow: auto;
}
:where([data-mantine-color-scheme=light]) .m_b183c0a2 {
  background-color: var(--code-bg, var(--mantine-color-gray-0));
}
:where([data-mantine-color-scheme=dark]) .m_b183c0a2 {
  background-color: var(--code-bg, var(--mantine-color-dark-6));
}
.m_b183c0a2[data-block] {
  padding: var(--mantine-spacing-xs);
}
.m_de3d2490 {
  --cs-size: calc(1.75rem * var(--mantine-scale));
  --cs-radius: calc(62.5rem * var(--mantine-scale));
  -webkit-tap-highlight-color: transparent;
  border: none;
  appearance: none;
  display: block;
  line-height: 1;
  position: relative;
  width: var(--cs-size);
  height: var(--cs-size);
  min-width: var(--cs-size);
  min-height: var(--cs-size);
  border-radius: var(--cs-radius);
  color: inherit;
  text-decoration: none;
}
[data-mantine-color-scheme=light] .m_de3d2490 {
  --alpha-overlay-color: var(--mantine-color-gray-3);
  --alpha-overlay-bg: var(--mantine-color-white);
}
[data-mantine-color-scheme=dark] .m_de3d2490 {
  --alpha-overlay-color: var(--mantine-color-dark-4);
  --alpha-overlay-bg: var(--mantine-color-dark-7);
}
.m_862f3d1b {
  position: absolute;
  inset: 0;
  border-radius: var(--cs-radius);
}
.m_98ae7f22 {
  position: absolute;
  inset: 0;
  border-radius: var(--cs-radius);
  z-index: 1;
  box-shadow: rgba(0, 0, 0, 0.1) 0 0 0 calc(0.0625rem * var(--mantine-scale)) inset, rgb(0, 0, 0, 0.15) 0 0 calc(0.25rem * var(--mantine-scale)) inset;
}
.m_95709ac0 {
  position: absolute;
  inset: 0;
  border-radius: var(--cs-radius);
  background-size: calc(0.5rem * var(--mantine-scale)) calc(0.5rem * var(--mantine-scale));
  background-position:
    0 0,
    0 calc(0.25rem * var(--mantine-scale)),
    calc(0.25rem * var(--mantine-scale)) calc(-0.25rem * var(--mantine-scale)),
    calc(-0.25rem * var(--mantine-scale)) 0;
  background-image:
    linear-gradient(
      45deg,
      var(--alpha-overlay-color) 25%,
      transparent 25%),
    linear-gradient(
      -45deg,
      var(--alpha-overlay-color) 25%,
      transparent 25%),
    linear-gradient(
      45deg,
      transparent 75%,
      var(--alpha-overlay-color) 75%),
    linear-gradient(
      -45deg,
      var(--alpha-overlay-bg) 75%,
      var(--alpha-overlay-color) 75%);
}
.m_93e74e3 {
  position: absolute;
  inset: 0;
  border-radius: var(--cs-radius);
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
}
.m_fee9c77 {
  --cp-width-xs: calc(11.25rem * var(--mantine-scale));
  --cp-width-sm: calc(12.5rem * var(--mantine-scale));
  --cp-width-md: calc(15rem * var(--mantine-scale));
  --cp-width-lg: calc(17.5rem * var(--mantine-scale));
  --cp-width-xl: calc(20rem * var(--mantine-scale));
  --cp-preview-size-xs: calc(1.625rem * var(--mantine-scale));
  --cp-preview-size-sm: calc(2.125rem * var(--mantine-scale));
  --cp-preview-size-md: calc(2.625rem * var(--mantine-scale));
  --cp-preview-size-lg: calc(3.125rem * var(--mantine-scale));
  --cp-preview-size-xl: calc(3.375rem * var(--mantine-scale));
  --cp-thumb-size-xs: calc(0.5rem * var(--mantine-scale));
  --cp-thumb-size-sm: calc(0.75rem * var(--mantine-scale));
  --cp-thumb-size-md: calc(1rem * var(--mantine-scale));
  --cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));
  --cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));
  --cp-saturation-height-xs: calc(6.25rem * var(--mantine-scale));
  --cp-saturation-height-sm: calc(6.875rem * var(--mantine-scale));
  --cp-saturation-height-md: calc(7.5rem * var(--mantine-scale));
  --cp-saturation-height-lg: calc(8.75rem * var(--mantine-scale));
  --cp-saturation-height-xl: calc(10rem * var(--mantine-scale));
  --cp-preview-size: var(--cp-preview-size-sm);
  --cp-thumb-size: var(--cp-thumb-size-sm);
  --cp-saturation-height: var(--cp-saturation-height-sm);
  --cp-width: var(--cp-width-sm);
  --cp-body-spacing: var(--mantine-spacing-sm);
  width: var(--cp-width);
  padding: calc(0.0625rem * var(--mantine-scale));
}
.m_fee9c77:where([data-full-width]) {
  width: 100%;
}
.m_9dddfbac {
  width: var(--cp-preview-size);
  height: var(--cp-preview-size);
}
.m_bffecc3e {
  display: flex;
  padding-top: calc(var(--cp-body-spacing) / 2);
}
.m_3283bb96 {
  flex: 1;
}
.m_3283bb96:not(:only-child) {
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_40d572ba {
  overflow: hidden;
  position: absolute;
  box-shadow: 0 0 1px rgba(0, 0, 0, 0.6);
  border: 2px solid var(--mantine-color-white);
  width: var(--cp-thumb-size);
  height: var(--cp-thumb-size);
  border-radius: var(--cp-thumb-size);
  left: calc(var(--thumb-x-offset) - var(--cp-thumb-size) / 2);
  top: calc(var(--thumb-y-offset) - var(--cp-thumb-size) / 2);
}
.m_d8ee6fd8 {
  height: unset !important;
  width: unset !important;
  min-width: 0 !important;
  min-height: 0 !important;
  margin: calc(0.125rem * var(--mantine-scale));
  cursor: pointer;
  padding-bottom: calc(var(--cp-swatch-size) - calc(0.25rem * var(--mantine-scale)));
  flex: 0 0 calc(var(--cp-swatch-size) - calc(0.25rem * var(--mantine-scale)));
}
.m_5711e686 {
  margin-top: calc(0.3125rem * var(--mantine-scale));
  margin-inline: calc(-0.125rem * var(--mantine-scale));
  display: flex;
  flex-wrap: wrap;
}
.m_5711e686:only-child {
  margin-top: 0;
}
.m_202a296e {
  --cp-thumb-size-xs: calc(0.5rem * var(--mantine-scale));
  --cp-thumb-size-sm: calc(0.75rem * var(--mantine-scale));
  --cp-thumb-size-md: calc(1rem * var(--mantine-scale));
  --cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));
  --cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));
  -webkit-tap-highlight-color: transparent;
  position: relative;
  height: var(--cp-saturation-height);
  border-radius: var(--mantine-radius-sm);
  margin: calc(var(--cp-thumb-size) / 2);
}
.m_202a296e:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba {
  outline: 2px solid var(--mantine-color-blue-filled);
}
.m_202a296e:where([data-focus-ring=always]):focus .m_40d572ba {
  outline: 2px solid var(--mantine-color-blue-filled);
}
.m_11b3db02 {
  position: absolute;
  border-radius: var(--mantine-radius-sm);
  inset: calc(var(--cp-thumb-size) * -1 / 2 - calc(0.0625rem * var(--mantine-scale)));
}
.m_d856d47d {
  --cp-thumb-size-xs: calc(0.5rem * var(--mantine-scale));
  --cp-thumb-size-sm: calc(0.75rem * var(--mantine-scale));
  --cp-thumb-size-md: calc(1rem * var(--mantine-scale));
  --cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));
  --cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));
  --cp-thumb-size: var(--cp-thumb-size, calc(0.75rem * var(--mantine-scale)));
  position: relative;
  height: calc(var(--cp-thumb-size) + calc(0.125rem * var(--mantine-scale)));
  margin-inline: calc(var(--cp-thumb-size) / 2);
  outline: none;
}
.m_d856d47d + .m_d856d47d {
  margin-top: calc(0.375rem * var(--mantine-scale));
}
.m_d856d47d:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba {
  outline: 2px solid var(--mantine-color-blue-filled);
}
.m_d856d47d:where([data-focus-ring=always]):focus .m_40d572ba {
  outline: 2px solid var(--mantine-color-blue-filled);
}
:where([data-mantine-color-scheme=light]) .m_d856d47d {
  --slider-checkers: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_d856d47d {
  --slider-checkers: var(--mantine-color-dark-4);
}
.m_8f327113 {
  position: absolute;
  top: 0;
  bottom: 0;
  inset-inline: calc(var(--cp-thumb-size) * -1 / 2 - calc(0.0625rem * var(--mantine-scale)));
  border-radius: 10000rem;
}
.m_b077c2bc {
  --ci-eye-dropper-icon-size-xs: calc(0.875rem * var(--mantine-scale));
  --ci-eye-dropper-icon-size-sm: calc(1rem * var(--mantine-scale));
  --ci-eye-dropper-icon-size-md: calc(1.125rem * var(--mantine-scale));
  --ci-eye-dropper-icon-size-lg: calc(1.25rem * var(--mantine-scale));
  --ci-eye-dropper-icon-size-xl: calc(1.375rem * var(--mantine-scale));
  --ci-eye-dropper-icon-size: var(--ci-eye-dropper-icon-size-sm);
}
.m_c5ccdcab {
  --ci-preview-size-xs: calc(1rem * var(--mantine-scale));
  --ci-preview-size-sm: calc(1.125rem * var(--mantine-scale));
  --ci-preview-size-md: calc(1.375rem * var(--mantine-scale));
  --ci-preview-size-lg: calc(1.75rem * var(--mantine-scale));
  --ci-preview-size-xl: calc(2.25rem * var(--mantine-scale));
  --ci-preview-size: var(--ci-preview-size-sm);
}
.m_5ece2cd7 {
  padding: calc(0.5rem * var(--mantine-scale));
}
.m_7485cace {
  --container-size-xs: calc(33.75rem * var(--mantine-scale));
  --container-size-sm: calc(45rem * var(--mantine-scale));
  --container-size-md: calc(60rem * var(--mantine-scale));
  --container-size-lg: calc(71.25rem * var(--mantine-scale));
  --container-size-xl: calc(82.5rem * var(--mantine-scale));
  --container-size: var(--container-size-md);
}
.m_7485cace:where([data-strategy=block]) {
  max-width: var(--container-size);
  padding-inline: var(--mantine-spacing-md);
  margin-inline: auto;
}
.m_7485cace:where([data-strategy=block]):where([data-fluid]) {
  max-width: 100%;
}
.m_7485cace:where([data-strategy=grid]) {
  display: grid;
  grid-template-columns: 1fr min(100%, var(--container-size)) 1fr;
  margin-inline: auto;
}
.m_7485cace:where([data-strategy=grid]) > * {
  grid-column: 2;
}
.m_7485cace:where([data-strategy=grid]) > [data-breakout] {
  grid-column: 1 / -1;
}
.m_7485cace:where([data-strategy=grid]) > [data-breakout] > [data-container] {
  max-width: var(--container-size);
  margin-inline: auto;
}
.m_e2125a27 {
  --dialog-size-xs: calc(10rem * var(--mantine-scale));
  --dialog-size-sm: calc(12.5rem * var(--mantine-scale));
  --dialog-size-md: calc(21.25rem * var(--mantine-scale));
  --dialog-size-lg: calc(25rem * var(--mantine-scale));
  --dialog-size-xl: calc(31.25rem * var(--mantine-scale));
  --dialog-size: var(--dialog-size-md);
  position: relative;
  width: var(--dialog-size);
  max-width: calc(100vw - var(--mantine-spacing-xl) * 2);
  min-height: calc(3.125rem * var(--mantine-scale));
}
.m_5abab665 {
  position: absolute;
  top: calc(var(--mantine-spacing-md) / 2);
  inset-inline-end: calc(var(--mantine-spacing-md) / 2);
}
.m_3eebeb36 {
  --divider-size-xs: calc(0.0625rem * var(--mantine-scale));
  --divider-size-sm: calc(0.125rem * var(--mantine-scale));
  --divider-size-md: calc(0.1875rem * var(--mantine-scale));
  --divider-size-lg: calc(0.25rem * var(--mantine-scale));
  --divider-size-xl: calc(0.3125rem * var(--mantine-scale));
  --divider-size: var(--divider-size-xs);
}
:where([data-mantine-color-scheme=light]) .m_3eebeb36 {
  --divider-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_3eebeb36 {
  --divider-color: var(--mantine-color-dark-4);
}
.m_3eebeb36:where([data-orientation=horizontal]) {
  border-top: var(--divider-size) var(--divider-border-style, solid) var(--divider-color);
}
.m_3eebeb36:where([data-orientation=vertical]) {
  border-inline-start: var(--divider-size) var(--divider-border-style, solid) var(--divider-color);
  height: auto;
  align-self: stretch;
}
.m_3eebeb36:where([data-with-label]) {
  border: 0;
}
.m_9e365f20 {
  display: flex;
  align-items: center;
  font-size: var(--mantine-font-size-xs);
  color: var(--mantine-color-dimmed);
  white-space: nowrap;
}
.m_9e365f20:where([data-position=left])::before {
  display: none;
}
.m_9e365f20:where([data-position=right])::after {
  display: none;
}
.m_9e365f20::before {
  content: "";
  flex: 1;
  height: calc(0.0625rem * var(--mantine-scale));
  border-top: var(--divider-size) var(--divider-border-style, solid) var(--divider-color);
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_9e365f20::after {
  content: "";
  flex: 1;
  height: calc(0.0625rem * var(--mantine-scale));
  border-top: var(--divider-size) var(--divider-border-style, solid) var(--divider-color);
  margin-inline-start: var(--mantine-spacing-xs);
}
.m_f11b401e {
  --drawer-size-xs: calc(20rem * var(--mantine-scale));
  --drawer-size-sm: calc(23.75rem * var(--mantine-scale));
  --drawer-size-md: calc(27.5rem * var(--mantine-scale));
  --drawer-size-lg: calc(38.75rem * var(--mantine-scale));
  --drawer-size-xl: calc(48.75rem * var(--mantine-scale));
  --drawer-size: var(--drawer-size-md);
  --drawer-offset: 0rem;
}
.m_5a7c2c9 {
  z-index: 1000;
}
.m_b8a05bbd {
  flex: var(--drawer-flex, 0 0 var(--drawer-size));
  height: var(--drawer-height, calc(100% - var(--drawer-offset) * 2));
  margin: var(--drawer-offset);
  max-width: calc(100% - var(--drawer-offset) * 2);
  max-height: calc(100% - var(--drawer-offset) * 2);
  overflow-y: auto;
}
.m_b8a05bbd[data-hidden] {
  opacity: 0 !important;
  pointer-events: none;
}
.m_31cd769a {
  display: flex;
  justify-content: var(--drawer-justify, flex-start);
  align-items: var(--drawer-align, flex-start);
}
.m_e9408a47 {
  padding: var(--mantine-spacing-lg);
  padding-top: var(--mantine-spacing-xs);
  border-radius: var(--fieldset-radius, var(--mantine-radius-default));
  min-inline-size: auto;
}
.m_84c9523a {
  border: calc(0.0625rem * var(--mantine-scale)) solid;
}
:where([data-mantine-color-scheme=light]) .m_84c9523a {
  border-color: var(--mantine-color-gray-3);
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_84c9523a {
  border-color: var(--mantine-color-dark-4);
  background-color: var(--mantine-color-dark-7);
}
.m_ef274e49 {
  border: calc(0.0625rem * var(--mantine-scale)) solid;
}
:where([data-mantine-color-scheme=light]) .m_ef274e49 {
  border-color: var(--mantine-color-gray-3);
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_ef274e49 {
  border-color: var(--mantine-color-dark-4);
  background-color: var(--mantine-color-dark-6);
}
.m_eda993d3 {
  padding: 0;
  border: 0;
  border-radius: 0;
}
.m_90794832 {
  font-size: var(--mantine-font-size-sm);
}
.m_74ca27fe {
  padding: 0;
  margin-bottom: var(--mantine-spacing-sm);
}
.m_8478a6da {
  container: mantine-grid / inline-size;
}
.m_410352e9 {
  --grid-overflow: visible;
  --grid-margin: calc(var(--grid-gutter) / -2);
  --grid-col-padding: calc(var(--grid-gutter) / 2);
  overflow: var(--grid-overflow);
}
.m_dee7bd2f {
  width: calc(100% + var(--grid-gutter));
  display: flex;
  flex-wrap: wrap;
  justify-content: var(--grid-justify);
  align-items: var(--grid-align);
  margin: var(--grid-margin);
}
.m_96bdd299 {
  --col-flex-grow: 0;
  --col-offset: 0rem;
  flex-shrink: 0;
  order: var(--col-order);
  flex-basis: var(--col-flex-basis);
  width: var(--col-width);
  max-width: var(--col-max-width);
  flex-grow: var(--col-flex-grow);
  margin-inline-start: var(--col-offset);
  padding: var(--grid-col-padding);
}
.m_bcb3f3c2 {
  color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=light]) .m_bcb3f3c2 {
  background-color: var(--mark-bg-light);
}
:where([data-mantine-color-scheme=dark]) .m_bcb3f3c2 {
  background-color: var(--mark-bg-dark);
}
.m_9e117634 {
  display: block;
  object-fit: var(--image-object-fit, cover);
  width: 100%;
  border-radius: var(--image-radius, 0);
}
@keyframes m_885901b1 {
  0% {
    opacity: 0.6;
    transform: scale(0);
  }
  100% {
    opacity: 0;
    transform: scale(2.8);
  }
}
.m_e5262200 {
  --indicator-size: calc(0.625rem * var(--mantine-scale));
  --indicator-color: var(--mantine-primary-color-filled);
  position: relative;
  display: block;
}
.m_e5262200:where([data-inline]) {
  display: inline-block;
}
.m_760d1fb1 {
  position: absolute;
  top: var(--indicator-top);
  left: var(--indicator-left);
  right: var(--indicator-right);
  bottom: var(--indicator-bottom);
  transform: translate(var(--indicator-translate-x), var(--indicator-translate-y));
  min-width: var(--indicator-size);
  height: var(--indicator-size);
  border-radius: var(--indicator-radius, 1000rem);
  z-index: var(--indicator-z-index, 200);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--mantine-font-size-xs);
  background-color: var(--indicator-color);
  color: var(--indicator-text-color, var(--mantine-color-white));
  white-space: nowrap;
}
.m_760d1fb1::before {
  content: "";
  position: absolute;
  inset: 0;
  background-color: var(--indicator-color);
  border-radius: var(--indicator-radius, 1000rem);
  z-index: -1;
}
.m_760d1fb1:where([data-with-label]) {
  padding-inline: calc(var(--mantine-spacing-xs) / 2);
}
.m_760d1fb1:where([data-with-border]) {
  border: 2px solid var(--mantine-color-body);
}
.m_760d1fb1[data-processing]::before {
  animation: m_885901b1 1000ms linear infinite;
}
.m_dc6f14e2 {
  --kbd-fz-xs: calc(0.625rem * var(--mantine-scale));
  --kbd-fz-sm: calc(0.75rem * var(--mantine-scale));
  --kbd-fz-md: calc(0.875rem * var(--mantine-scale));
  --kbd-fz-lg: calc(1rem * var(--mantine-scale));
  --kbd-fz-xl: calc(1.25rem * var(--mantine-scale));
  --kbd-fz: var(--kbd-fz-sm);
  font-family: var(--mantine-font-family-monospace);
  line-height: var(--mantine-line-height);
  font-weight: 700;
  font-size: var(--kbd-fz);
  border-radius: var(--mantine-radius-sm);
  border: calc(0.0625rem * var(--mantine-scale)) solid;
  border-bottom-width: calc(0.1875rem * var(--mantine-scale));
  unicode-bidi: embed;
  text-align: center;
  padding: 0.12em 0.45em;
}
:where([data-mantine-color-scheme=light]) .m_dc6f14e2 {
  border-color: var(--mantine-color-gray-3);
  color: var(--mantine-color-gray-7);
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_dc6f14e2 {
  border-color: var(--mantine-color-dark-4);
  color: var(--mantine-color-dark-0);
  background-color: var(--mantine-color-dark-6);
}
.m_abbac491 {
  --list-fz: var(--mantine-font-size-md);
  --list-lh: var(--mantine-line-height-md);
  --list-marker-gap: var(--mantine-spacing-lg);
  list-style-position: outside;
  font-size: var(--list-fz);
  line-height: var(--list-lh);
  margin: 0;
  padding: 0;
  padding-inline-start: var(--list-marker-gap);
}
.m_abbac491:where([data-with-padding]) {
  padding-inline-start: calc(var(--list-marker-gap) + var(--mantine-spacing-md));
}
.m_abb6bec2 {
  white-space: normal;
  line-height: var(--list-lh);
}
.m_abb6bec2:where([data-with-icon]) {
  list-style: none;
}
.m_abb6bec2:where([data-with-icon]) .m_75cd9f71 {
  --li-direction: row;
  --li-align: center;
}
.m_abb6bec2:where(:not(:first-of-type)) {
  margin-top: var(--list-spacing, 0);
}
.m_abb6bec2:where([data-centered]) {
  line-height: 1;
}
.m_75cd9f71 {
  display: inline-flex;
  flex-direction: var(--li-direction, column);
  align-items: var(--li-align, flex-start);
  white-space: normal;
}
.m_60f83e5b {
  display: inline-block;
  vertical-align: middle;
  margin-inline-end: var(--mantine-spacing-sm);
}
.m_6e45937b {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  z-index: var(--lo-z-index);
}
.m_e8eb006c {
  position: relative;
  z-index: calc(var(--lo-z-index) + 1);
}
.m_df587f17 {
  z-index: var(--lo-z-index);
}
.m_dc9b7c9f {
  padding: calc(0.25rem * var(--mantine-scale));
}
.m_9bfac126 {
  color: var(--mantine-color-dimmed);
  font-weight: 500;
  font-size: var(--mantine-font-size-xs);
  padding: calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-sm);
  cursor: default;
}
.m_efdf90cb {
  margin-top: calc(0.25rem * var(--mantine-scale));
  margin-bottom: calc(0.25rem * var(--mantine-scale));
  border-top: calc(0.0625rem * var(--mantine-scale)) solid;
}
:where([data-mantine-color-scheme=light]) .m_efdf90cb {
  border-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_efdf90cb {
  border-color: var(--mantine-color-dark-4);
}
.m_99ac2aa1 {
  font-size: var(--mantine-font-size-sm);
  width: 100%;
  padding: calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-sm);
  border-radius: var(--popover-radius, var(--mantine-radius-default));
  color: var(--menu-item-color, var(--mantine-color-text));
  display: flex;
  align-items: center;
  user-select: none;
}
.m_99ac2aa1:where([data-disabled], :disabled) {
  color: var(--mantine-color-disabled-color);
  opacity: 0.6;
  cursor: not-allowed;
}
:where([data-mantine-color-scheme=light]) .m_99ac2aa1:where(:hover, :focus):where(:not(:disabled, [data-disabled])) {
  background-color: var(--menu-item-hover, var(--mantine-color-gray-1));
}
:where([data-mantine-color-scheme=dark]) .m_99ac2aa1:where(:hover, :focus):where(:not(:disabled, [data-disabled])) {
  background-color: var(--menu-item-hover, var(--mantine-color-dark-4));
}
.m_99ac2aa1:where([data-sub-menu-item]) {
  padding-inline-end: calc(0.3125rem * var(--mantine-scale));
}
.m_5476e0d3 {
  flex: 1;
}
.m_8b75e504 {
  display: flex;
  justify-content: center;
  align-items: center;
}
.m_8b75e504:where([data-position=left]) {
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_8b75e504:where([data-position=right]) {
  margin-inline-start: var(--mantine-spacing-xs);
}
.m_b85b0bed {
  transform: rotate(-90deg);
}
:where([dir=rtl]) .m_b85b0bed {
  transform: rotate(90deg);
}
.m_9df02822 {
  --modal-size-xs: calc(20rem * var(--mantine-scale));
  --modal-size-sm: calc(23.75rem * var(--mantine-scale));
  --modal-size-md: calc(27.5rem * var(--mantine-scale));
  --modal-size-lg: calc(38.75rem * var(--mantine-scale));
  --modal-size-xl: calc(48.75rem * var(--mantine-scale));
  --modal-size: var(--modal-size-md);
  --modal-y-offset: 5dvh;
  --modal-x-offset: 5vw;
}
.m_9df02822[data-full-screen] {
  --modal-border-radius: 0 !important;
}
.m_9df02822[data-full-screen] .m_54c44539 {
  --modal-content-flex: 0 0 100%;
  --modal-content-max-height: auto;
  --modal-content-height: 100dvh;
}
.m_9df02822[data-full-screen] .m_1f958f16 {
  --modal-inner-y-offset: 0;
  --modal-inner-x-offset: 0;
}
.m_9df02822[data-centered] .m_1f958f16 {
  --modal-inner-align: center;
}
.m_d0e2b9cd {
  border-start-start-radius: var(--modal-radius, var(--mantine-radius-default));
  border-start-end-radius: var(--modal-radius, var(--mantine-radius-default));
}
.m_54c44539 {
  flex: var(--modal-content-flex, 0 0 var(--modal-size));
  max-width: 100%;
  max-height: var(--modal-content-max-height, calc(100dvh - var(--modal-y-offset) * 2));
  height: var(--modal-content-height, auto);
  overflow-y: auto;
}
.m_54c44539[data-full-screen] {
  border-radius: 0;
}
.m_54c44539[data-hidden] {
  opacity: 0 !important;
  pointer-events: none;
}
.m_1f958f16 {
  display: flex;
  justify-content: center;
  align-items: var(--modal-inner-align, flex-start);
  padding-top: var(--modal-inner-y-offset, var(--modal-y-offset));
  padding-bottom: var(--modal-inner-y-offset, var(--modal-y-offset));
  padding-inline: var(--modal-inner-x-offset, var(--modal-x-offset));
}
.m_7cda1cd6 {
  --pill-fz-xs: calc(0.625rem * var(--mantine-scale));
  --pill-fz-sm: calc(0.75rem * var(--mantine-scale));
  --pill-fz-md: calc(0.875rem * var(--mantine-scale));
  --pill-fz-lg: calc(1rem * var(--mantine-scale));
  --pill-fz-xl: calc(1.125rem * var(--mantine-scale));
  --pill-height-xs: calc(1.125rem * var(--mantine-scale));
  --pill-height-sm: calc(1.375rem * var(--mantine-scale));
  --pill-height-md: calc(1.5625rem * var(--mantine-scale));
  --pill-height-lg: calc(1.75rem * var(--mantine-scale));
  --pill-height-xl: calc(2rem * var(--mantine-scale));
  --pill-fz: var(--pill-fz-sm);
  --pill-height: var(--pill-height-sm);
  font-size: var(--pill-fz);
  flex: 0;
  height: var(--pill-height);
  padding-inline: 0.8em;
  display: inline-flex;
  align-items: center;
  border-radius: var(--pill-radius, 1000rem);
  line-height: 1;
  white-space: nowrap;
  user-select: none;
  -webkit-user-select: none;
  max-width: 100%;
}
:where([data-mantine-color-scheme=dark]) .m_7cda1cd6 {
  background-color: var(--mantine-color-dark-7);
  color: var(--mantine-color-dark-0);
}
:where([data-mantine-color-scheme=light]) .m_7cda1cd6 {
  color: var(--mantine-color-black);
}
.m_7cda1cd6:where([data-with-remove]:not(:has(button:disabled))) {
  padding-inline-end: 0;
}
.m_7cda1cd6:where([data-disabled], :has(button:disabled)) {
  cursor: not-allowed;
}
:where([data-mantine-color-scheme=light]) .m_44da308b {
  background-color: var(--mantine-color-gray-1);
}
:where([data-mantine-color-scheme=light]) .m_44da308b:where([data-disabled], :has(button:disabled)) {
  background-color: var(--mantine-color-disabled);
}
:where([data-mantine-color-scheme=light]) .m_e3a01f8 {
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=light]) .m_e3a01f8:where([data-disabled], :has(button:disabled)) {
  background-color: var(--mantine-color-disabled);
}
.m_1e0e6180 {
  cursor: inherit;
  overflow: hidden;
  height: 100%;
  line-height: var(--pill-height);
  text-overflow: ellipsis;
}
.m_ae386778 {
  color: inherit;
  font-size: inherit;
  height: 100%;
  min-height: unset;
  min-width: 2em;
  width: unset;
  border-radius: 0;
  padding-inline-start: 0.1em;
  padding-inline-end: 0.3em;
  flex: 0;
  border-end-end-radius: var(--pill-radius, 50%);
  border-start-end-radius: var(--pill-radius, 50%);
}
.m_7cda1cd6[data-disabled] > .m_ae386778,
.m_ae386778:disabled {
  display: none;
  background-color: transparent;
  width: 0.8em;
  min-width: 0.8em;
  padding: 0;
  cursor: not-allowed;
}
.m_7cda1cd6[data-disabled] > .m_ae386778 > svg,
.m_ae386778:disabled > svg {
  display: none;
}
.m_ae386778 > svg {
  pointer-events: none;
}
.m_1dcfd90b {
  --pg-gap-xs: calc(0.375rem * var(--mantine-scale));
  --pg-gap-sm: calc(0.5rem * var(--mantine-scale));
  --pg-gap-md: calc(0.625rem * var(--mantine-scale));
  --pg-gap-lg: calc(0.75rem * var(--mantine-scale));
  --pg-gap-xl: calc(0.75rem * var(--mantine-scale));
  --pg-gap: var(--pg-gap-sm);
  display: flex;
  align-items: center;
  gap: var(--pg-gap);
  flex-wrap: wrap;
}
.m_45c4369d {
  background-color: transparent;
  appearance: none;
  min-width: calc(6.25rem * var(--mantine-scale));
  flex: 1;
  border: 0;
  font-size: inherit;
  height: 1.6em;
  color: inherit;
  padding: 0;
}
.m_45c4369d::placeholder {
  color: var(--input-placeholder-color);
  opacity: 1;
}
.m_45c4369d:where([data-type=hidden], [data-type=auto]) {
  height: calc(0.0625rem * var(--mantine-scale));
  width: calc(0.0625rem * var(--mantine-scale));
  top: 0;
  left: 0;
  pointer-events: none;
  position: absolute;
  opacity: 0;
}
.m_45c4369d:focus {
  outline: none;
}
.m_45c4369d:where([data-type=auto]:focus) {
  height: 1.6em;
  visibility: visible;
  opacity: 1;
  position: static;
}
.m_45c4369d:where([data-pointer]:not([data-disabled], :disabled)) {
  cursor: pointer;
}
.m_45c4369d:where([data-disabled], :disabled) {
  cursor: not-allowed;
}
.m_f0824112 {
  --nl-bg: var(--mantine-primary-color-light);
  --nl-hover: var(--mantine-primary-color-light-hover);
  --nl-color: var(--mantine-primary-color-light-color);
  display: flex;
  align-items: center;
  width: 100%;
  padding: 8px var(--mantine-spacing-sm);
  user-select: none;
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_f0824112:hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_f0824112:hover {
    background-color: var(--mantine-color-dark-6);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_f0824112:active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_f0824112:active {
    background-color: var(--mantine-color-dark-6);
  }
}
.m_f0824112:where([data-disabled]) {
  opacity: 0.4;
  pointer-events: none;
}
.m_f0824112:where([data-active], [aria-current=page]) {
  background-color: var(--nl-bg);
  color: var(--nl-color);
}
@media (hover: hover) {
  .m_f0824112:where([data-active], [aria-current=page]):hover {
    background-color: var(--nl-hover);
  }
}
@media (hover: none) {
  .m_f0824112:where([data-active], [aria-current=page]):active {
    background-color: var(--nl-hover);
  }
}
.m_f0824112:where([data-active], [aria-current=page]) .m_57492dcc {
  --description-opacity: 0.9;
  --description-color: var(--nl-color);
}
.m_690090b5 {
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 150ms ease;
}
.m_690090b5 > svg {
  display: block;
}
.m_690090b5:where([data-position=left]) {
  margin-inline-end: var(--mantine-spacing-sm);
}
.m_690090b5:where([data-position=right]) {
  margin-inline-start: var(--mantine-spacing-sm);
}
.m_690090b5:where([data-rotate]) {
  transform: rotate(90deg);
}
.m_1f6ac4c4 {
  font-size: var(--mantine-font-size-sm);
}
.m_f07af9d2 {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}
.m_f07af9d2:where([data-no-wrap]) {
  white-space: nowrap;
}
.m_57492dcc {
  display: block;
  font-size: var(--mantine-font-size-xs);
  opacity: var(--description-opacity, 1);
  color: var(--description-color, var(--mantine-color-dimmed));
  overflow: hidden;
  text-overflow: ellipsis;
}
:where([data-no-wrap]) .m_57492dcc {
  white-space: nowrap;
}
.m_e17b862f {
  padding-inline-start: var(--nl-offset, var(--mantine-spacing-lg));
}
.m_1fd8a00b {
  transform: rotate(-90deg);
}
.m_a513464 {
  --notification-radius: var(--mantine-radius-default);
  --notification-color: var(--mantine-primary-color-filled);
  overflow: hidden;
  box-sizing: border-box;
  position: relative;
  display: flex;
  align-items: center;
  padding-inline-start: calc(1.375rem * var(--mantine-scale));
  padding-inline-end: var(--mantine-spacing-xs);
  padding-top: var(--mantine-spacing-xs);
  padding-bottom: var(--mantine-spacing-xs);
  border-radius: var(--notification-radius);
  box-shadow: var(--mantine-shadow-lg);
}
.m_a513464::before {
  content: "";
  display: block;
  position: absolute;
  width: calc(0.375rem * var(--mantine-scale));
  top: var(--notification-radius);
  bottom: var(--notification-radius);
  inset-inline-start: calc(0.25rem * var(--mantine-scale));
  border-radius: var(--notification-radius);
  background-color: var(--notification-color);
}
:where([data-mantine-color-scheme=light]) .m_a513464 {
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_a513464 {
  background-color: var(--mantine-color-dark-6);
}
.m_a513464:where([data-with-icon])::before {
  display: none;
}
:where([data-mantine-color-scheme=light]) .m_a513464:where([data-with-border]) {
  border: 1px solid var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_a513464:where([data-with-border]) {
  border: 1px solid var(--mantine-color-dark-4);
}
.m_a4ceffb {
  box-sizing: border-box;
  margin-inline-end: var(--mantine-spacing-md);
  width: calc(1.75rem * var(--mantine-scale));
  height: calc(1.75rem * var(--mantine-scale));
  border-radius: calc(1.75rem * var(--mantine-scale));
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--notification-color);
  color: var(--mantine-color-white);
}
.m_b0920b15 {
  margin-inline-end: var(--mantine-spacing-md);
}
.m_a49ed24 {
  flex: 1;
  overflow: hidden;
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_3feedf16 {
  margin-bottom: calc(0.125rem * var(--mantine-scale));
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: var(--mantine-font-size-sm);
  line-height: var(--mantine-line-height-sm);
  font-weight: 500;
}
:where([data-mantine-color-scheme=light]) .m_3feedf16 {
  color: var(--mantine-color-gray-9);
}
:where([data-mantine-color-scheme=dark]) .m_3feedf16 {
  color: var(--mantine-color-white);
}
.m_3d733a3a {
  font-size: var(--mantine-font-size-sm);
  line-height: var(--mantine-line-height-sm);
  overflow: hidden;
  text-overflow: ellipsis;
}
:where([data-mantine-color-scheme=light]) .m_3d733a3a {
  color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=dark]) .m_3d733a3a {
  color: var(--mantine-color-dark-0);
}
:where([data-mantine-color-scheme=light]) .m_3d733a3a:where([data-with-title]) {
  color: var(--mantine-color-gray-6);
}
:where([data-mantine-color-scheme=dark]) .m_3d733a3a:where([data-with-title]) {
  color: var(--mantine-color-dark-2);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_919a4d88:hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_919a4d88:hover {
    background-color: var(--mantine-color-dark-8);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_919a4d88:active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_919a4d88:active {
    background-color: var(--mantine-color-dark-8);
  }
}
.m_e2f5cd4e {
  --ni-right-section-width-xs: calc(1.0625rem * var(--mantine-scale));
  --ni-right-section-width-sm: calc(1.5rem * var(--mantine-scale));
  --ni-right-section-width-md: calc(1.6875rem * var(--mantine-scale));
  --ni-right-section-width-lg: calc(1.9375rem * var(--mantine-scale));
  --ni-right-section-width-xl: calc(2.125rem * var(--mantine-scale));
}
.m_95e17d22 {
  --ni-chevron-size-xs: calc(0.625rem * var(--mantine-scale));
  --ni-chevron-size-sm: calc(0.875rem * var(--mantine-scale));
  --ni-chevron-size-md: calc(1rem * var(--mantine-scale));
  --ni-chevron-size-lg: calc(1.125rem * var(--mantine-scale));
  --ni-chevron-size-xl: calc(1.25rem * var(--mantine-scale));
  --ni-chevron-size: var(--ni-chevron-size-sm);
  display: flex;
  flex-direction: column;
  width: 100%;
  height: calc(var(--input-height) - calc(0.125rem * var(--mantine-scale)));
  max-width: calc(var(--ni-chevron-size) * 1.7);
  margin-inline-start: auto;
}
.m_80b4b171 {
  --control-border: 1px solid var(--input-bd);
  --control-radius: calc(var(--input-radius) - calc(0.0625rem * var(--mantine-scale)));
  flex: 0 0 50%;
  width: 100%;
  padding: 0;
  height: calc(var(--input-height) / 2 - calc(0.0625rem * var(--mantine-scale)));
  border-inline-start: var(--control-border);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--mantine-color-text);
  background-color: transparent;
  cursor: pointer;
}
.m_80b4b171:where(:disabled) {
  background-color: transparent;
  cursor: not-allowed;
  opacity: 0.6;
  color: var(--mantine-color-disabled-color);
}
.m_e2f5cd4e[data-error] :where(.m_80b4b171) {
  color: var(--mantine-color-error);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_80b4b171:hover {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_80b4b171:hover {
    background-color: var(--mantine-color-dark-4);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_80b4b171:active {
    background-color: var(--mantine-color-gray-0);
  }
  :where([data-mantine-color-scheme=dark]) .m_80b4b171:active {
    background-color: var(--mantine-color-dark-4);
  }
}
.m_80b4b171:where(:first-of-type) {
  border-radius: 0;
  border-start-end-radius: var(--control-radius);
}
.m_80b4b171:last-of-type {
  border-radius: 0;
  border-end-end-radius: var(--control-radius);
}
.m_4addd315 {
  --pagination-control-size-xs: calc(1.375rem * var(--mantine-scale));
  --pagination-control-size-sm: calc(1.625rem * var(--mantine-scale));
  --pagination-control-size-md: calc(2rem * var(--mantine-scale));
  --pagination-control-size-lg: calc(2.375rem * var(--mantine-scale));
  --pagination-control-size-xl: calc(2.75rem * var(--mantine-scale));
  --pagination-control-size: var(--pagination-control-size-md);
  --pagination-control-fz: var(--mantine-font-size-md);
  --pagination-active-bg: var(--mantine-primary-color-filled);
}
.m_326d024a {
  display: flex;
  align-items: center;
  justify-content: center;
  border: calc(0.0625rem * var(--mantine-scale)) solid;
  cursor: pointer;
  color: var(--mantine-color-text);
  height: var(--pagination-control-size);
  min-width: var(--pagination-control-size);
  font-size: var(--pagination-control-fz);
  line-height: 1;
  border-radius: var(--pagination-control-radius, var(--mantine-radius-default));
}
.m_326d024a:where([data-with-padding]) {
  padding: calc(var(--pagination-control-size) / 4);
}
.m_326d024a:where(:disabled, [data-disabled]) {
  cursor: not-allowed;
  opacity: 0.4;
}
:where([data-mantine-color-scheme=light]) .m_326d024a {
  border-color: var(--mantine-color-gray-4);
  background-color: var(--mantine-color-white);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_326d024a:hover:where(:not(:disabled, [data-disabled])) {
    background-color: var(--mantine-color-gray-0);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_326d024a:active:where(:not(:disabled, [data-disabled])) {
    background-color: var(--mantine-color-gray-0);
  }
}
:where([data-mantine-color-scheme=dark]) .m_326d024a {
  border-color: var(--mantine-color-dark-4);
  background-color: var(--mantine-color-dark-6);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=dark]) .m_326d024a:hover:where(:not(:disabled, [data-disabled])) {
    background-color: var(--mantine-color-dark-5);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=dark]) .m_326d024a:active:where(:not(:disabled, [data-disabled])) {
    background-color: var(--mantine-color-dark-5);
  }
}
.m_326d024a:where([data-active]) {
  background-color: var(--pagination-active-bg);
  border-color: var(--pagination-active-bg);
  color: var(--pagination-active-color, var(--mantine-color-white));
}
@media (hover: hover) {
  .m_326d024a:where([data-active]):hover {
    background-color: var(--pagination-active-bg);
  }
}
@media (hover: none) {
  .m_326d024a:where([data-active]):active {
    background-color: var(--pagination-active-bg);
  }
}
.m_4ad7767d {
  height: var(--pagination-control-size);
  min-width: var(--pagination-control-size);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
}
.m_f61ca620 {
  --psi-button-size-xs: calc(1.375rem * var(--mantine-scale));
  --psi-button-size-sm: calc(1.625rem * var(--mantine-scale));
  --psi-button-size-md: calc(1.75rem * var(--mantine-scale));
  --psi-button-size-lg: calc(2rem * var(--mantine-scale));
  --psi-button-size-xl: calc(2.5rem * var(--mantine-scale));
  --psi-icon-size-xs: calc(0.75rem * var(--mantine-scale));
  --psi-icon-size-sm: calc(0.9375rem * var(--mantine-scale));
  --psi-icon-size-md: calc(1.0625rem * var(--mantine-scale));
  --psi-icon-size-lg: calc(1.1875rem * var(--mantine-scale));
  --psi-icon-size-xl: calc(1.3125rem * var(--mantine-scale));
  --psi-button-size: var(--psi-button-size-sm);
  --psi-icon-size: var(--psi-icon-size-sm);
}
.m_ccf8da4c {
  position: relative;
  overflow: hidden;
}
.m_f2d85dd2 {
  font-family: var(--mantine-font-family);
  background-color: transparent;
  border: 0;
  padding-inline-end: var(--input-padding-inline-end);
  padding-inline-start: var(--input-padding-inline-start);
  position: absolute;
  inset: 0;
  outline: 0;
  font-size: inherit;
  line-height: var(--mantine-line-height);
  height: 100%;
  width: 100%;
  color: inherit;
}
.m_ccf8da4c[data-disabled] .m_f2d85dd2,
.m_f2d85dd2:disabled {
  cursor: not-allowed;
}
.m_f2d85dd2::placeholder {
  color: var(--input-placeholder-color);
  opacity: 1;
}
.m_f2d85dd2::-ms-reveal {
  display: none;
}
.m_b1072d44 {
  width: var(--psi-button-size);
  height: var(--psi-button-size);
  min-width: var(--psi-button-size);
  min-height: var(--psi-button-size);
}
.m_b1072d44:disabled {
  display: none;
}
.m_f1cb205a {
  --pin-input-size-xs: calc(1.875rem * var(--mantine-scale));
  --pin-input-size-sm: calc(2.25rem * var(--mantine-scale));
  --pin-input-size-md: calc(2.625rem * var(--mantine-scale));
  --pin-input-size-lg: calc(3.125rem * var(--mantine-scale));
  --pin-input-size-xl: calc(3.75rem * var(--mantine-scale));
  --pin-input-size: var(--pin-input-size-sm);
}
.m_cb288ead {
  width: var(--pin-input-size);
  height: var(--pin-input-size);
}
@keyframes m_81a374bd {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: calc(2.5rem * var(--mantine-scale)) 0;
  }
}
@keyframes m_e0fb7a86 {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 0 calc(2.5rem * var(--mantine-scale));
  }
}
.m_db6d6462 {
  --progress-radius: var(--mantine-radius-default);
  --progress-size: var(--progress-size-md);
  --progress-size-xs: calc(0.1875rem * var(--mantine-scale));
  --progress-size-sm: calc(0.3125rem * var(--mantine-scale));
  --progress-size-md: calc(0.5rem * var(--mantine-scale));
  --progress-size-lg: calc(0.75rem * var(--mantine-scale));
  --progress-size-xl: calc(1rem * var(--mantine-scale));
  position: relative;
  height: var(--progress-size);
  border-radius: var(--progress-radius);
  overflow: hidden;
  display: flex;
}
:where([data-mantine-color-scheme=light]) .m_db6d6462 {
  background-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_db6d6462 {
  background-color: var(--mantine-color-dark-4);
}
.m_db6d6462:where([data-orientation=vertical]) {
  height: auto;
  width: var(--progress-size);
  flex-direction: column-reverse;
}
.m_2242eb65 {
  background-color: var(--progress-section-color);
  height: 100%;
  width: var(--progress-section-size);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  background-size: calc(1.25rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));
  transition: width var(--progress-transition-duration, 100ms) ease;
}
.m_2242eb65:where([data-striped]) {
  background-image:
    linear-gradient(
      45deg,
      rgba(255, 255, 255, 0.15) 25%,
      transparent 25%,
      transparent 50%,
      rgba(255, 255, 255, 0.15) 50%,
      rgba(255, 255, 255, 0.15) 75%,
      transparent 75%,
      transparent);
}
.m_2242eb65:where([data-animated]) {
  animation: m_81a374bd 1s linear infinite;
}
.m_2242eb65:where(:last-of-type) {
  border-radius: 0;
  border-start-end-radius: var(--progress-radius);
  border-end-end-radius: var(--progress-radius);
}
.m_2242eb65:where(:first-of-type) {
  border-radius: 0;
  border-start-start-radius: var(--progress-radius);
  border-end-start-radius: var(--progress-radius);
}
.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65 {
  width: 100%;
  height: var(--progress-section-size);
  transition: height var(--progress-transition-duration, 100ms) ease;
}
.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where([data-striped]) {
  background-image:
    linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.15) 25%,
      transparent 25%,
      transparent 50%,
      rgba(255, 255, 255, 0.15) 50%,
      rgba(255, 255, 255, 0.15) 75%,
      transparent 75%,
      transparent);
}
.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where([data-animated]) {
  animation: m_e0fb7a86 1s linear infinite;
}
.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where(:last-of-type) {
  border-radius: 0;
  border-start-start-radius: var(--progress-radius);
  border-start-end-radius: var(--progress-radius);
}
.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where(:first-of-type) {
  border-radius: 0;
  border-end-start-radius: var(--progress-radius);
  border-end-end-radius: var(--progress-radius);
}
.m_91e40b74 {
  color: var(--progress-label-color, var(--mantine-color-white));
  font-weight: bold;
  user-select: none;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  font-size: min(calc(var(--progress-size) * 0.65), calc(1.125rem * var(--mantine-scale)));
  line-height: 1;
  padding-inline: calc(0.25rem * var(--mantine-scale));
}
.m_db6d6462:where([data-orientation=vertical]) .m_91e40b74 {
  writing-mode: vertical-rl;
}
.m_9dc8ae12 {
  --card-radius: var(--mantine-radius-default);
  display: block;
  width: 100%;
  border-radius: var(--card-radius);
  cursor: pointer;
}
.m_9dc8ae12 :where(*) {
  cursor: inherit;
}
.m_9dc8ae12:where([data-with-border]) {
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
}
:where([data-mantine-color-scheme=light]) .m_9dc8ae12:where([data-with-border]) {
  border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_9dc8ae12:where([data-with-border]) {
  border-color: var(--mantine-color-dark-4);
}
.m_717d7ff6 {
  --radio-size-xs: calc(1rem * var(--mantine-scale));
  --radio-size-sm: calc(1.25rem * var(--mantine-scale));
  --radio-size-md: calc(1.5rem * var(--mantine-scale));
  --radio-size-lg: calc(1.875rem * var(--mantine-scale));
  --radio-size-xl: calc(2.25rem * var(--mantine-scale));
  --radio-icon-size-xs: calc(0.375rem * var(--mantine-scale));
  --radio-icon-size-sm: calc(0.5rem * var(--mantine-scale));
  --radio-icon-size-md: calc(0.625rem * var(--mantine-scale));
  --radio-icon-size-lg: calc(0.875rem * var(--mantine-scale));
  --radio-icon-size-xl: calc(1rem * var(--mantine-scale));
  --radio-icon-size: var(--radio-icon-size-sm);
  --radio-size: var(--radio-size-sm);
  --radio-color: var(--mantine-primary-color-filled);
  --radio-icon-color: var(--mantine-color-white);
  position: relative;
  border: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  width: var(--radio-size);
  min-width: var(--radio-size);
  height: var(--radio-size);
  min-height: var(--radio-size);
  border-radius: var(--radio-radius, 10000px);
  transition: border-color 100ms ease, background-color 100ms ease;
  cursor: var(--mantine-cursor-type);
  -webkit-tap-highlight-color: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
}
:where([data-mantine-color-scheme=light]) .m_717d7ff6 {
  background-color: var(--mantine-color-white);
  border-color: var(--mantine-color-gray-4);
}
:where([data-mantine-color-scheme=dark]) .m_717d7ff6 {
  background-color: var(--mantine-color-dark-6);
  border-color: var(--mantine-color-dark-4);
}
.m_717d7ff6[data-indeterminate],
.m_717d7ff6[data-checked] {
  background-color: var(--radio-color);
  border-color: var(--radio-color);
}
.m_717d7ff6[data-indeterminate] > .m_3e4da632,
.m_717d7ff6[data-checked] > .m_3e4da632 {
  opacity: 1;
  transform: none;
  color: var(--radio-icon-color);
}
.m_717d7ff6[data-disabled] {
  cursor: not-allowed;
  background-color: var(--mantine-color-disabled);
  border-color: var(--mantine-color-disabled-border);
}
.m_717d7ff6[data-disabled][data-checked] > .m_3e4da632 {
  color: var(--mantine-color-disabled-color);
}
.m_2980836c[data-indeterminate]:not([data-disabled]),
.m_2980836c[data-checked]:not([data-disabled]) {
  background-color: transparent;
  border-color: var(--radio-color);
}
.m_2980836c[data-indeterminate]:not([data-disabled]) > .m_3e4da632,
.m_2980836c[data-checked]:not([data-disabled]) > .m_3e4da632 {
  color: var(--radio-color);
  opacity: 1;
  transform: none;
}
.m_3e4da632 {
  display: block;
  width: var(--radio-icon-size);
  height: var(--radio-icon-size);
  color: transparent;
  pointer-events: none;
  transform: translateY(calc(0.3125rem * var(--mantine-scale))) scale(0.5);
  opacity: 1;
  transition: transform 100ms ease, opacity 100ms ease;
}
.m_f3f1af94 {
  --radio-size-xs: calc(1rem * var(--mantine-scale));
  --radio-size-sm: calc(1.25rem * var(--mantine-scale));
  --radio-size-md: calc(1.5rem * var(--mantine-scale));
  --radio-size-lg: calc(1.875rem * var(--mantine-scale));
  --radio-size-xl: calc(2.25rem * var(--mantine-scale));
  --radio-size: var(--radio-size-sm);
  --radio-icon-size-xs: calc(0.375rem * var(--mantine-scale));
  --radio-icon-size-sm: calc(0.5rem * var(--mantine-scale));
  --radio-icon-size-md: calc(0.625rem * var(--mantine-scale));
  --radio-icon-size-lg: calc(0.875rem * var(--mantine-scale));
  --radio-icon-size-xl: calc(1rem * var(--mantine-scale));
  --radio-icon-size: var(--radio-icon-size-sm);
  --radio-icon-color: var(--mantine-color-white);
}
.m_89c4f5e4 {
  position: relative;
  width: var(--radio-size);
  height: var(--radio-size);
  order: 1;
}
.m_89c4f5e4:where([data-label-position=left]) {
  order: 2;
}
.m_f3ed6b2b {
  color: var(--radio-icon-color);
  opacity: var(--radio-icon-opacity, 0);
  transform: var(--radio-icon-transform, scale(0.2) translateY(calc(0.625rem * var(--mantine-scale))));
  transition: opacity 100ms ease, transform 200ms ease;
  pointer-events: none;
  width: var(--radio-icon-size);
  height: var(--radio-icon-size);
  position: absolute;
  top: calc(50% - var(--radio-icon-size) / 2);
  left: calc(50% - var(--radio-icon-size) / 2);
}
.m_8a3dbb89 {
  border: calc(0.0625rem * var(--mantine-scale)) solid;
  position: relative;
  appearance: none;
  width: var(--radio-size);
  height: var(--radio-size);
  border-radius: var(--radio-radius, var(--radio-size));
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transition-property: background-color, border-color;
  transition-timing-function: ease;
  transition-duration: 100ms;
  cursor: var(--mantine-cursor-type);
  -webkit-tap-highlight-color: transparent;
}
:where([data-mantine-color-scheme=light]) .m_8a3dbb89 {
  background-color: var(--mantine-color-white);
  border-color: var(--mantine-color-gray-4);
}
:where([data-mantine-color-scheme=dark]) .m_8a3dbb89 {
  background-color: var(--mantine-color-dark-6);
  border-color: var(--mantine-color-dark-4);
}
.m_8a3dbb89:checked {
  background-color: var(--radio-color, var(--mantine-primary-color-filled));
  border-color: var(--radio-color, var(--mantine-primary-color-filled));
}
.m_8a3dbb89:checked + .m_f3ed6b2b {
  --radio-icon-opacity: 1;
  --radio-icon-transform: scale(1);
}
.m_8a3dbb89:disabled {
  cursor: not-allowed;
  background-color: var(--mantine-color-disabled);
  border-color: var(--mantine-color-disabled-border);
}
.m_8a3dbb89:disabled + .m_f3ed6b2b {
  --radio-icon-color: var(--mantine-color-disabled-color);
}
.m_8a3dbb89:where([data-error]) {
  border-color: var(--mantine-color-error);
}
.m_1bfe9d39 + .m_f3ed6b2b {
  --radio-icon-color: var(--radio-color);
}
.m_1bfe9d39:checked:not(:disabled) {
  background-color: transparent;
  border-color: var(--radio-color);
}
.m_1bfe9d39:checked:not(:disabled) + .m_f3ed6b2b {
  --radio-icon-color: var(--radio-color);
  --radio-icon-opacity: 1;
  --radio-icon-transform: none;
}
.m_f8d312f2 {
  --rating-size-xs: calc(0.875rem * var(--mantine-scale));
  --rating-size-sm: calc(1.125rem * var(--mantine-scale));
  --rating-size-md: calc(1.25rem * var(--mantine-scale));
  --rating-size-lg: calc(1.75rem * var(--mantine-scale));
  --rating-size-xl: calc(2rem * var(--mantine-scale));
  display: flex;
  width: max-content;
}
.m_f8d312f2:where(:has(input:disabled)) {
  pointer-events: none;
}
.m_61734bb7 {
  position: relative;
  transition: transform 100ms ease;
}
.m_61734bb7:where([data-active]) {
  z-index: 1;
  transform: scale(1.1);
}
.m_5662a89a {
  width: var(--rating-size);
  height: var(--rating-size);
  display: block;
}
:where([data-mantine-color-scheme=light]) .m_5662a89a {
  fill: var(--mantine-color-gray-3);
  stroke: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_5662a89a {
  fill: var(--mantine-color-dark-3);
  stroke: var(--mantine-color-dark-3);
}
.m_5662a89a:where([data-filled]) {
  fill: var(--rating-color);
  stroke: var(--rating-color);
}
.m_211007ba {
  height: 0;
  width: 0;
  position: absolute;
  overflow: hidden;
  white-space: nowrap;
  opacity: 0;
  -webkit-tap-highlight-color: transparent;
}
.m_211007ba:focus-visible + label {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.m_21342ee4 {
  display: block;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  z-index: var(--rating-item-z-index, 0);
  -webkit-tap-highlight-color: transparent;
}
.m_21342ee4:where([data-read-only]) {
  cursor: default;
}
.m_21342ee4:where(:last-of-type) {
  position: relative;
}
.m_fae05d6a {
  clip-path: var(--rating-symbol-clip-path);
}
.m_1b3c8819 {
  --tooltip-radius: var(--mantine-radius-default);
  position: absolute;
  padding: calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-xs);
  pointer-events: none;
  font-size: var(--mantine-font-size-sm);
  white-space: nowrap;
  border-radius: var(--tooltip-radius);
}
:where([data-mantine-color-scheme=light]) .m_1b3c8819 {
  background-color: var(--tooltip-bg, var(--mantine-color-gray-9));
  color: var(--tooltip-color, var(--mantine-color-white));
}
:where([data-mantine-color-scheme=dark]) .m_1b3c8819 {
  background-color: var(--tooltip-bg, var(--mantine-color-gray-2));
  color: var(--tooltip-color, var(--mantine-color-black));
}
.m_1b3c8819:where([data-multiline]) {
  white-space: normal;
}
.m_1b3c8819:where([data-fixed]) {
  position: fixed;
}
.m_f898399f {
  background-color: inherit;
  border: 0;
  z-index: 1;
}
.m_b32e4812 {
  position: relative;
  width: var(--rp-size);
  height: var(--rp-size);
  min-width: var(--rp-size);
  min-height: var(--rp-size);
  --rp-transition-duration: 0ms;
}
.m_d43b5134 {
  width: var(--rp-size);
  height: var(--rp-size);
  min-width: var(--rp-size);
  min-height: var(--rp-size);
  transform: rotate(-90deg);
}
.m_b1ca1fbf {
  stroke: var(--curve-color, var(--rp-curve-root-color));
  transition:
    stroke-dashoffset var(--rp-transition-duration) ease,
    stroke-dasharray var(--rp-transition-duration) ease,
    stroke var(--rp-transition-duration);
}
[data-mantine-color-scheme=light] .m_b1ca1fbf {
  --rp-curve-root-color: var(--mantine-color-gray-2);
}
[data-mantine-color-scheme=dark] .m_b1ca1fbf {
  --rp-curve-root-color: var(--mantine-color-dark-4);
}
.m_b23f9dc4 {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  inset-inline: var(--rp-label-offset);
}
.m_cf365364 {
  --sc-padding-xs: calc(0.125rem * var(--mantine-scale)) calc(0.375rem * var(--mantine-scale));
  --sc-padding-sm: calc(0.1875rem * var(--mantine-scale)) calc(0.625rem * var(--mantine-scale));
  --sc-padding-md: calc(0.25rem * var(--mantine-scale)) calc(0.875rem * var(--mantine-scale));
  --sc-padding-lg: calc(0.4375rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));
  --sc-padding-xl: calc(0.625rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));
  --sc-transition-duration: 200ms;
  --sc-padding: var(--sc-padding-sm);
  --sc-transition-timing-function: ease;
  --sc-font-size: var(--mantine-font-size-sm);
  position: relative;
  display: inline-flex;
  flex-direction: row;
  width: auto;
  border-radius: var(--sc-radius, var(--mantine-radius-default));
  overflow: hidden;
  padding: calc(0.25rem * var(--mantine-scale));
}
.m_cf365364:where([data-full-width]) {
  display: flex;
}
.m_cf365364:where([data-orientation=vertical]) {
  display: flex;
  flex-direction: column;
  width: max-content;
}
.m_cf365364:where([data-orientation=vertical]):where([data-full-width]) {
  width: auto;
}
:where([data-mantine-color-scheme=light]) .m_cf365364 {
  background-color: var(--mantine-color-gray-1);
}
:where([data-mantine-color-scheme=dark]) .m_cf365364 {
  background-color: var(--mantine-color-dark-8);
}
.m_9e182ccd {
  position: absolute;
  display: block;
  z-index: 1;
  border-radius: var(--sc-radius, var(--mantine-radius-default));
}
:where([data-mantine-color-scheme=light]) .m_9e182ccd {
  box-shadow: var(--sc-shadow, none);
  background-color: var(--sc-color, var(--mantine-color-white));
}
:where([data-mantine-color-scheme=dark]) .m_9e182ccd {
  box-shadow: none;
  background-color: var(--sc-color, var(--mantine-color-dark-5));
}
.m_1738fcb2 {
  -webkit-tap-highlight-color: transparent;
  font-weight: 500;
  display: block;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: none;
  border-radius: var(--sc-radius, var(--mantine-radius-default));
  font-size: var(--sc-font-size);
  padding: var(--sc-padding);
  transition: color var(--sc-transition-duration) var(--sc-transition-timing-function);
  cursor: pointer;
  outline: var(--segmented-control-outline, none);
}
:where([data-mantine-color-scheme=light]) .m_1738fcb2 {
  color: var(--mantine-color-gray-7);
}
:where([data-mantine-color-scheme=dark]) .m_1738fcb2 {
  color: var(--mantine-color-dark-1);
}
.m_1738fcb2:where([data-read-only]) {
  cursor: default;
}
fieldset:disabled .m_1738fcb2,
.m_1738fcb2:where([data-disabled]) {
  cursor: not-allowed;
  color: var(--mantine-color-disabled-color);
}
:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active]) {
  color: var(--sc-label-color, var(--mantine-color-black));
}
:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active]) {
  color: var(--sc-label-color, var(--mantine-color-white));
}
.m_cf365364:where([data-initialized]) .m_1738fcb2:where([data-active])::before {
  display: none;
}
.m_1738fcb2:where([data-active])::before {
  content: "";
  inset: 0;
  z-index: 0;
  position: absolute;
  border-radius: var(--sc-radius, var(--mantine-radius-default));
}
:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active])::before {
  box-shadow: var(--sc-shadow, none);
  background-color: var(--sc-color, var(--mantine-color-white));
}
:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active])::before {
  box-shadow: none;
  background-color: var(--sc-color, var(--mantine-color-dark-5));
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled], [data-active], [data-read-only])):hover {
    color: var(--mantine-color-black);
  }
  :where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled], [data-active], [data-read-only])):hover {
    color: var(--mantine-color-white);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled], [data-active], [data-read-only])):active {
    color: var(--mantine-color-black);
  }
  :where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled], [data-active], [data-read-only])):active {
    color: var(--mantine-color-white);
  }
}
@media (hover: hover) {
  fieldset:disabled .m_1738fcb2:hover {
    color: var(--mantine-color-disabled-color) !important;
  }
}
@media (hover: none) {
  fieldset:disabled .m_1738fcb2:active {
    color: var(--mantine-color-disabled-color) !important;
  }
}
.m_1714d588 {
  height: 0;
  width: 0;
  position: absolute;
  overflow: hidden;
  white-space: nowrap;
  opacity: 0;
}
.m_1714d588[data-focus-ring=auto]:focus:focus-visible + .m_1738fcb2 {
  --segmented-control-outline: 2px solid var(--mantine-primary-color-filled);
}
.m_1714d588[data-focus-ring=always]:focus + .m_1738fcb2 {
  --segmented-control-outline: 2px solid var(--mantine-primary-color-filled);
}
.m_69686b9b {
  position: relative;
  flex: 1;
  z-index: 2;
  transition: border-color var(--sc-transition-duration) var(--sc-transition-timing-function);
}
.m_cf365364[data-with-items-borders] :where(.m_69686b9b)::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  inset-inline-start: 0;
  background-color: var(--separator-color);
  width: calc(0.0625rem * var(--mantine-scale));
  transition: background-color var(--sc-transition-duration) var(--sc-transition-timing-function);
}
.m_69686b9b[data-orientation=vertical]::before {
  top: 0;
  inset-inline: 0;
  bottom: auto;
  height: calc(0.0625rem * var(--mantine-scale));
  width: auto;
}
:where([data-mantine-color-scheme=light]) .m_69686b9b {
  --separator-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_69686b9b {
  --separator-color: var(--mantine-color-dark-4);
}
.m_69686b9b:first-of-type::before {
  --separator-color: transparent;
}
[data-mantine-color-scheme] .m_69686b9b[data-active]::before,
[data-mantine-color-scheme] .m_69686b9b[data-active] + .m_69686b9b::before {
  --separator-color: transparent;
}
.m_78882f40 {
  position: relative;
  z-index: 2;
}
.m_fa528724 {
  --scp-filled-segment-color: var(--mantine-primary-color-filled);
  --scp-transition-duration: 0ms;
  --scp-thickness: calc(0.625rem * var(--mantine-scale));
}
:where([data-mantine-color-scheme=light]) .m_fa528724 {
  --scp-empty-segment-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_fa528724 {
  --scp-empty-segment-color: var(--mantine-color-dark-4);
}
.m_fa528724 {
  position: relative;
  width: fit-content;
}
.m_62e9e7e2 {
  display: block;
  transform: var(--scp-rotation);
  overflow: hidden;
}
.m_c573fb6f {
  transition:
    stroke-dashoffset var(--scp-transition-duration) ease,
    stroke-dasharray var(--scp-transition-duration) ease,
    stroke var(--scp-transition-duration);
}
.m_4fa340f2 {
  position: absolute;
  margin: 0;
  padding: 0;
  inset-inline: 0;
  text-align: center;
  z-index: 1;
}
.m_4fa340f2:where([data-position=bottom]) {
  bottom: 0;
  padding-inline: calc(var(--scp-thickness) * 2);
}
.m_4fa340f2:where([data-position=bottom]):where([data-orientation=down]) {
  bottom: auto;
  top: 0;
}
.m_4fa340f2:where([data-position=center]) {
  top: 50%;
  padding-inline: calc(var(--scp-thickness) * 3);
}
.m_925c2d2c {
  container: simple-grid / inline-size;
}
.m_2415a157 {
  display: grid;
  grid-template-columns: repeat(var(--sg-cols), minmax(0, 1fr));
  gap: var(--sg-spacing-y) var(--sg-spacing-x);
}
@keyframes m_299c329c {
  0%, 100% {
    opacity: 0.4;
  }
  50% {
    opacity: 1;
  }
}
.m_18320242 {
  height: var(--skeleton-height, auto);
  width: var(--skeleton-width, 100%);
  border-radius: var(--skeleton-radius, var(--mantine-radius-default));
  position: relative;
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}
.m_18320242:where([data-animate])::after {
  animation: m_299c329c 1500ms linear infinite;
}
.m_18320242:where([data-visible]) {
  overflow: hidden;
}
.m_18320242:where([data-visible])::before {
  position: absolute;
  content: "";
  inset: 0;
  z-index: 10;
  background-color: var(--mantine-color-body);
}
.m_18320242:where([data-visible])::after {
  position: absolute;
  content: "";
  inset: 0;
  z-index: 11;
}
:where([data-mantine-color-scheme=light]) .m_18320242:where([data-visible])::after {
  background-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_18320242:where([data-visible])::after {
  background-color: var(--mantine-color-dark-4);
}
.m_dd36362e {
  --slider-size-xs: calc(0.25rem * var(--mantine-scale));
  --slider-size-sm: calc(0.375rem * var(--mantine-scale));
  --slider-size-md: calc(0.5rem * var(--mantine-scale));
  --slider-size-lg: calc(0.625rem * var(--mantine-scale));
  --slider-size-xl: calc(0.75rem * var(--mantine-scale));
  --slider-size: var(--slider-size-md);
  --slider-radius: calc(62.5rem * var(--mantine-scale));
  --slider-color: var(--mantine-primary-color-filled);
  --slider-track-disabled-bg: var(--mantine-color-disabled);
  -webkit-tap-highlight-color: transparent;
  outline: none;
  height: calc(var(--slider-size) * 2);
  padding-inline: var(--slider-size);
  display: flex;
  flex-direction: column;
  align-items: center;
  touch-action: none;
  position: relative;
}
[data-mantine-color-scheme=light] .m_dd36362e {
  --slider-track-bg: var(--mantine-color-gray-2);
}
[data-mantine-color-scheme=dark] .m_dd36362e {
  --slider-track-bg: var(--mantine-color-dark-4);
}
.m_c9357328 {
  position: absolute;
  top: calc(-2.25rem * var(--mantine-scale));
  font-size: var(--mantine-font-size-xs);
  color: var(--mantine-color-white);
  padding: calc(var(--mantine-spacing-xs) / 2);
  border-radius: var(--mantine-radius-sm);
  white-space: nowrap;
  pointer-events: none;
  user-select: none;
  touch-action: none;
}
:where([data-mantine-color-scheme=light]) .m_c9357328 {
  background-color: var(--mantine-color-gray-9);
}
:where([data-mantine-color-scheme=dark]) .m_c9357328 {
  background-color: var(--mantine-color-dark-4);
}
.m_c9a9a60a {
  position: absolute;
  display: flex;
  height: var(--slider-thumb-size);
  width: var(--slider-thumb-size);
  border: calc(0.25rem * var(--mantine-scale)) solid;
  transform: translate(-50%, -50%);
  top: 50%;
  cursor: pointer;
  border-radius: var(--slider-radius);
  align-items: center;
  justify-content: center;
  transition: box-shadow 100ms ease, transform 100ms ease;
  z-index: 3;
  user-select: none;
  touch-action: none;
  outline-offset: calc(0.125rem * var(--mantine-scale));
  left: var(--slider-thumb-offset);
}
:where([dir=rtl]) .m_c9a9a60a {
  left: auto;
  right: calc(var(--slider-thumb-offset) - var(--slider-thumb-size));
}
fieldset:disabled .m_c9a9a60a,
.m_c9a9a60a:where([data-disabled]) {
  display: none;
}
.m_c9a9a60a:where([data-dragging]) {
  transform: translate(-50%, -50%) scale(1.05);
  box-shadow: var(--mantine-shadow-sm);
}
:where([data-mantine-color-scheme=light]) .m_c9a9a60a {
  color: var(--slider-color);
  border-color: var(--slider-color);
  background-color: var(--mantine-color-white);
}
:where([data-mantine-color-scheme=dark]) .m_c9a9a60a {
  color: var(--mantine-color-white);
  border-color: var(--mantine-color-white);
  background-color: var(--slider-color);
}
.m_a8645c2 {
  display: flex;
  align-items: center;
  width: 100%;
  height: calc(var(--slider-size) * 2);
  cursor: pointer;
}
fieldset:disabled .m_a8645c2,
.m_a8645c2:where([data-disabled]) {
  cursor: not-allowed;
}
.m_c9ade57f {
  position: relative;
  width: 100%;
  height: var(--slider-size);
}
.m_c9ade57f:where([data-inverted]:not([data-disabled])) {
  --track-bg: var(--slider-color);
}
fieldset:disabled .m_c9ade57f:where([data-inverted]),
.m_c9ade57f:where([data-inverted][data-disabled]) {
  --track-bg: var(--slider-track-disabled-bg);
}
.m_c9ade57f::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  border-radius: var(--slider-radius);
  inset-inline: calc(var(--slider-size) * -1);
  background-color: var(--track-bg, var(--slider-track-bg));
  z-index: 0;
}
.m_38aeed47 {
  position: absolute;
  z-index: 1;
  top: 0;
  bottom: 0;
  background-color: var(--slider-color);
  border-radius: var(--slider-radius);
  width: var(--slider-bar-width);
  inset-inline-start: var(--slider-bar-offset);
}
.m_38aeed47:where([data-inverted]) {
  background-color: var(--slider-track-bg);
}
fieldset:disabled .m_38aeed47:where(:not([data-inverted])),
.m_38aeed47:where([data-disabled]:not([data-inverted])) {
  background-color: var(--mantine-color-disabled-color);
}
.m_b7b0423a {
  position: absolute;
  inset-inline-start: calc(var(--mark-offset) - var(--slider-size) / 2);
  top: 0;
  z-index: 2;
  height: 0;
  pointer-events: none;
}
.m_dd33bc19 {
  border: calc(0.125rem * var(--mantine-scale)) solid;
  height: var(--slider-size);
  width: var(--slider-size);
  border-radius: calc(62.5rem * var(--mantine-scale));
  background-color: var(--mantine-color-white);
  pointer-events: none;
}
:where([data-mantine-color-scheme=light]) .m_dd33bc19 {
  border-color: var(--mantine-color-gray-2);
}
:where([data-mantine-color-scheme=dark]) .m_dd33bc19 {
  border-color: var(--mantine-color-dark-4);
}
.m_dd33bc19:where([data-filled]) {
  border-color: var(--slider-color);
}
.m_dd33bc19:where([data-filled]):where([data-disabled]) {
  border-color: var(--mantine-color-disabled-border);
}
.m_68c77a5b {
  transform: translate(calc(-50% + var(--slider-size) / 2), calc(var(--mantine-spacing-xs) / 2));
  font-size: var(--mantine-font-size-sm);
  white-space: nowrap;
  cursor: pointer;
  user-select: none;
}
:where([data-mantine-color-scheme=light]) .m_68c77a5b {
  color: var(--mantine-color-gray-6);
}
:where([data-mantine-color-scheme=dark]) .m_68c77a5b {
  color: var(--mantine-color-dark-2);
}
.m_559cce2d {
  position: relative;
}
.m_559cce2d:where([data-has-spoiler]) {
  margin-bottom: calc(1.5rem * var(--mantine-scale));
}
.m_b912df4e {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: max-height var(--spoiler-transition-duration, 200ms) ease;
}
.m_b9131032 {
  position: absolute;
  inset-inline-start: 0;
  top: 100%;
  height: calc(1.5rem * var(--mantine-scale));
}
.m_6d731127 {
  display: flex;
  flex-direction: column;
  align-items: var(--stack-align, stretch);
  justify-content: var(--stack-justify, flex-start);
  gap: var(--stack-gap, var(--mantine-spacing-md));
}
.m_cbb4ea7e {
  --stepper-icon-size-xs: calc(2.125rem * var(--mantine-scale));
  --stepper-icon-size-sm: calc(2.25rem * var(--mantine-scale));
  --stepper-icon-size-md: calc(2.625rem * var(--mantine-scale));
  --stepper-icon-size-lg: calc(3rem * var(--mantine-scale));
  --stepper-icon-size-xl: calc(3.25rem * var(--mantine-scale));
  --stepper-icon-size: var(--stepper-icon-size-md);
  --stepper-color: var(--mantine-primary-color-filled);
  --stepper-content-padding: var(--mantine-spacing-md);
  --stepper-spacing: var(--mantine-spacing-md);
  --stepper-radius: calc(62.5rem * var(--mantine-scale));
  --stepper-fz: var(--mantine-font-size-md);
  --stepper-outline-thickness: calc(0.125rem * var(--mantine-scale));
}
[data-mantine-color-scheme=light] .m_cbb4ea7e {
  --stepper-outline-color: var(--mantine-color-gray-2);
}
[data-mantine-color-scheme=dark] .m_cbb4ea7e {
  --stepper-outline-color: var(--mantine-color-dark-5);
}
.m_aaf89d0b {
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
}
.m_aaf89d0b:where([data-wrap]) {
  flex-wrap: wrap;
  gap: var(--mantine-spacing-md) 0;
}
.m_aaf89d0b:where([data-orientation=vertical]) {
  flex-direction: column;
}
.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=left]) {
  align-items: flex-start;
}
.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=right]) {
  align-items: flex-end;
}
.m_aaf89d0b:where([data-orientation=horizontal]) {
  flex-direction: row;
}
.m_2a371ac9 {
  transition: background-color 150ms ease;
  flex: 1;
  height: var(--stepper-outline-thickness);
  margin-inline: var(--mantine-spacing-md);
  background-color: var(--stepper-outline-color);
}
.m_2a371ac9:where([data-active]) {
  background-color: var(--stepper-color);
}
.m_78da155d {
  padding-top: var(--stepper-content-padding);
}
.m_cbb57068 {
  --step-color: var(--stepper-color);
  display: flex;
  cursor: default;
}
.m_cbb57068:where([data-allow-click]) {
  cursor: pointer;
}
.m_cbb57068:where([data-icon-position=left]) {
  flex-direction: row;
}
.m_cbb57068:where([data-icon-position=right]) {
  flex-direction: row-reverse;
}
.m_f56b1e2c {
  align-items: center;
}
.m_833edb7e {
  --separator-spacing: calc(var(--mantine-spacing-xs) / 2);
  justify-content: flex-start;
  min-height: calc(var(--stepper-icon-size) + var(--mantine-spacing-xl) + var(--separator-spacing));
  margin-top: var(--separator-spacing);
  overflow: hidden;
}
.m_833edb7e:where(:first-of-type) {
  margin-top: 0;
}
.m_833edb7e:where(:last-of-type) {
  min-height: auto;
}
.m_833edb7e:where(:last-of-type) .m_6496b3f3 {
  display: none;
}
.m_818e70b {
  position: relative;
}
.m_6496b3f3 {
  top: calc(var(--stepper-icon-size) + var(--separator-spacing));
  inset-inline-start: calc(var(--stepper-icon-size) / 2);
  height: 100vh;
  position: absolute;
  border-inline-start: var(--stepper-outline-thickness) solid var(--stepper-outline-color);
}
.m_6496b3f3:where([data-active]) {
  border-color: var(--stepper-color);
}
.m_1959ad01 {
  height: var(--stepper-icon-size);
  width: var(--stepper-icon-size);
  min-height: var(--stepper-icon-size);
  min-width: var(--stepper-icon-size);
  border-radius: var(--stepper-radius);
  font-size: var(--stepper-fz);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  font-weight: bold;
  transition: background-color 150ms ease, border-color 150ms ease;
  border: var(--stepper-outline-thickness) solid var(--stepper-outline-color);
  background-color: var(--stepper-outline-color);
}
:where([data-mantine-color-scheme=light]) .m_1959ad01 {
  color: var(--mantine-color-gray-7);
}
:where([data-mantine-color-scheme=dark]) .m_1959ad01 {
  color: var(--mantine-color-dark-1);
}
.m_1959ad01:where([data-progress]) {
  border-color: var(--step-color);
}
.m_1959ad01:where([data-completed]) {
  color: var(--stepper-icon-color, var(--mantine-color-white));
  background-color: var(--step-color);
  border-color: var(--step-color);
}
.m_a79331dc {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--stepper-icon-color, var(--mantine-color-white));
}
.m_1956aa2a {
  display: flex;
  flex-direction: column;
}
.m_1956aa2a:where([data-icon-position=left]) {
  margin-inline-start: var(--mantine-spacing-sm);
}
.m_1956aa2a:where([data-icon-position=right]) {
  text-align: right;
  margin-inline-end: var(--mantine-spacing-sm);
}
:where([dir=rtl]) .m_1956aa2a:where([data-icon-position=right]) {
  text-align: left;
}
.m_12051f6c {
  font-weight: 500;
  font-size: var(--stepper-fz);
  line-height: 1;
}
.m_164eea74 {
  margin-top: calc(var(--stepper-spacing) / 3);
  margin-bottom: calc(var(--stepper-spacing) / 3);
  font-size: calc(var(--stepper-fz) - calc(0.125rem * var(--mantine-scale)));
  line-height: 1;
  color: var(--mantine-color-dimmed);
}
.m_5f93f3bb {
  --switch-height-xs: calc(1rem * var(--mantine-scale));
  --switch-height-sm: calc(1.25rem * var(--mantine-scale));
  --switch-height-md: calc(1.5rem * var(--mantine-scale));
  --switch-height-lg: calc(1.875rem * var(--mantine-scale));
  --switch-height-xl: calc(2.25rem * var(--mantine-scale));
  --switch-width-xs: calc(2rem * var(--mantine-scale));
  --switch-width-sm: calc(2.375rem * var(--mantine-scale));
  --switch-width-md: calc(2.875rem * var(--mantine-scale));
  --switch-width-lg: calc(3.5rem * var(--mantine-scale));
  --switch-width-xl: calc(4.5rem * var(--mantine-scale));
  --switch-thumb-size-xs: calc(0.75rem * var(--mantine-scale));
  --switch-thumb-size-sm: calc(0.875rem * var(--mantine-scale));
  --switch-thumb-size-md: calc(1.125rem * var(--mantine-scale));
  --switch-thumb-size-lg: calc(1.375rem * var(--mantine-scale));
  --switch-thumb-size-xl: calc(1.75rem * var(--mantine-scale));
  --switch-label-font-size-xs: calc(0.3125rem * var(--mantine-scale));
  --switch-label-font-size-sm: calc(0.375rem * var(--mantine-scale));
  --switch-label-font-size-md: calc(0.4375rem * var(--mantine-scale));
  --switch-label-font-size-lg: calc(0.5625rem * var(--mantine-scale));
  --switch-label-font-size-xl: calc(0.6875rem * var(--mantine-scale));
  --switch-track-label-padding-xs: calc(0.125rem * var(--mantine-scale));
  --switch-track-label-padding-sm: calc(0.15625rem * var(--mantine-scale));
  --switch-track-label-padding-md: calc(0.1875rem * var(--mantine-scale));
  --switch-track-label-padding-lg: calc(0.1875rem * var(--mantine-scale));
  --switch-track-label-padding-xl: calc(0.21875rem * var(--mantine-scale));
  --switch-height: var(--switch-height-sm);
  --switch-width: var(--switch-width-sm);
  --switch-thumb-size: var(--switch-thumb-size-sm);
  --switch-label-font-size: var(--switch-label-font-size-sm);
  --switch-track-label-padding: var(--switch-track-label-padding-sm);
  --switch-radius: calc(62.5rem * var(--mantine-scale));
  --switch-color: var(--mantine-primary-color-filled);
  --switch-disabled-color: var(--mantine-color-disabled);
  position: relative;
}
.m_926b4011 {
  height: 0;
  width: 0;
  opacity: 0;
  margin: 0;
  padding: 0;
  position: absolute;
  overflow: hidden;
  white-space: nowrap;
}
.m_9307d992 {
  -webkit-tap-highlight-color: transparent;
  cursor: var(--switch-cursor, var(--mantine-cursor-type));
  overflow: hidden;
  position: relative;
  border-radius: var(--switch-radius);
  background-color: var(--switch-bg);
  height: var(--switch-height);
  min-width: var(--switch-width);
  margin: 0;
  transition: background-color 150ms ease, border-color 150ms ease;
  appearance: none;
  display: flex;
  align-items: center;
  font-size: var(--switch-label-font-size);
  font-weight: 600;
  order: var(--switch-order, 1);
  user-select: none;
  z-index: 0;
  line-height: 0;
  color: var(--switch-text-color);
}
.m_9307d992:where([data-without-labels]) {
  width: var(--switch-width);
}
.m_926b4011:focus-visible + .m_9307d992 {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.m_926b4011:checked + .m_9307d992 {
  --switch-bg: var(--switch-color);
  --switch-text-color: var(--mantine-color-white);
}
.m_926b4011:disabled + .m_9307d992,
.m_926b4011[data-disabled] + .m_9307d992 {
  --switch-bg: var(--switch-disabled-color);
  --switch-cursor: not-allowed;
}
[data-mantine-color-scheme=light] .m_9307d992 {
  --switch-bg: var(--mantine-color-gray-3);
  --switch-text-color: var(--mantine-color-gray-6);
}
[data-mantine-color-scheme=dark] .m_9307d992 {
  --switch-bg: var(--mantine-color-dark-5);
  --switch-text-color: var(--mantine-color-dark-1);
}
.m_9307d992[data-label-position=left] {
  --switch-order: 2;
}
.m_93039a1d {
  position: absolute;
  z-index: 1;
  border-radius: var(--switch-radius);
  display: flex;
  background-color: var(--switch-thumb-bg, var(--mantine-color-white));
  height: var(--switch-thumb-size);
  width: var(--switch-thumb-size);
  inset-inline-start: var(--switch-thumb-start, var(--switch-track-label-padding));
  transition: inset-inline-start 150ms ease;
}
.m_93039a1d:where([data-with-thumb-indicator])::before {
  content: "";
  width: 40%;
  height: 40%;
  background-color: var(--switch-bg);
  position: absolute;
  border-radius: var(--switch-radius);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.m_93039a1d > * {
  margin: auto;
}
.m_926b4011:checked + * > .m_93039a1d {
  --switch-thumb-start: calc(100% - var(--switch-thumb-size) - var(--switch-track-label-padding));
}
.m_926b4011:disabled + * > .m_93039a1d,
.m_926b4011[data-disabled] + * > .m_93039a1d {
  --switch-thumb-bg: var(--switch-thumb-bg-disabled);
}
[data-mantine-color-scheme=light] .m_93039a1d {
  --switch-thumb-bg-disabled: var(--mantine-color-gray-0);
}
[data-mantine-color-scheme=dark] .m_93039a1d {
  --switch-thumb-bg-disabled: var(--mantine-color-dark-3);
}
.m_8277e082 {
  height: 100%;
  display: grid;
  place-content: center;
  min-width: calc(var(--switch-width) - var(--switch-thumb-size));
  padding-inline: var(--switch-track-label-padding);
  margin-inline-start: calc(var(--switch-thumb-size) + var(--switch-track-label-padding));
  transition: margin 150ms ease;
}
.m_926b4011:checked + * > .m_8277e082 {
  margin-inline-end: calc(var(--switch-thumb-size) + var(--switch-track-label-padding));
  margin-inline-start: 0;
}
.m_b23fa0ef {
  width: 100%;
  border-collapse: collapse;
  border-spacing: 0;
  line-height: var(--mantine-line-height);
  font-size: var(--mantine-font-size-sm);
  table-layout: var(--table-layout, auto);
  caption-side: var(--table-caption-side, bottom);
  border: none;
}
:where([data-mantine-color-scheme=light]) .m_b23fa0ef {
  --table-hover-color: var(--mantine-color-gray-1);
  --table-striped-color: var(--mantine-color-gray-0);
  --table-border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_b23fa0ef {
  --table-hover-color: var(--mantine-color-dark-5);
  --table-striped-color: var(--mantine-color-dark-6);
  --table-border-color: var(--mantine-color-dark-4);
}
.m_b23fa0ef:where([data-with-table-border]) {
  border: calc(0.0625rem * var(--mantine-scale)) solid var(--table-border-color);
}
.m_b23fa0ef:where([data-tabular-nums]) {
  font-variant-numeric: tabular-nums;
}
.m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3) {
  font-weight: 500;
}
:where([data-mantine-color-scheme=light]) .m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3) {
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3) {
  background-color: var(--mantine-color-dark-6);
}
.m_4e7aa4f3 {
  text-align: left;
}
:where([dir=rtl]) .m_4e7aa4f3 {
  text-align: right;
}
.m_4e7aa4fd {
  border-bottom: none;
  background-color: transparent;
}
@media (hover: hover) {
  .m_4e7aa4fd:hover:where([data-hover]) {
    background-color: var(--tr-hover-bg);
  }
}
@media (hover: none) {
  .m_4e7aa4fd:active:where([data-hover]) {
    background-color: var(--tr-hover-bg);
  }
}
.m_4e7aa4fd:where([data-with-row-border]) {
  border-bottom: calc(0.0625rem * var(--mantine-scale)) solid var(--table-border-color);
}
.m_4e7aa4ef,
.m_4e7aa4f3 {
  padding: var(--table-vertical-spacing) var(--table-horizontal-spacing, var(--mantine-spacing-xs));
}
.m_4e7aa4ef:where([data-with-column-border]:not(:first-child)),
.m_4e7aa4f3:where([data-with-column-border]:not(:first-child)) {
  border-inline-start: calc(0.0625rem * var(--mantine-scale)) solid var(--table-border-color);
}
.m_4e7aa4ef:where([data-with-column-border]:not(:last-child)),
.m_4e7aa4f3:where([data-with-column-border]:not(:last-child)) {
  border-inline-end: calc(0.0625rem * var(--mantine-scale)) solid var(--table-border-color);
}
.m_b2404537 > :where(tr):where([data-with-row-border]:last-of-type) {
  border-bottom: none;
}
.m_b2404537 > :where(tr):where([data-striped=odd]:nth-of-type(odd)) {
  background-color: var(--table-striped-color);
}
.m_b2404537 > :where(tr):where([data-striped=even]:nth-of-type(even)) {
  background-color: var(--table-striped-color);
}
.m_b2404537 > :where(tr)[data-hover] {
  --tr-hover-bg: var(--table-highlight-on-hover-color, var(--table-hover-color));
}
.m_b242d975 {
  top: var(--table-sticky-header-offset, 0);
  z-index: 3;
}
.m_b242d975:where([data-sticky]) {
  position: sticky;
}
.m_b242d975:where([data-sticky]) :where(.m_4e7aa4f3) {
  position: sticky;
  top: var(--table-sticky-header-offset, 0);
  background-color: var(--mantine-color-body);
}
:where([data-with-table-border]) .m_b242d975[data-sticky] {
  position: sticky;
  top: var(--table-sticky-header-offset, 0);
  z-index: 4;
  border-top: none;
}
:where([data-with-table-border]) .m_b242d975[data-sticky]::before {
  content: "";
  display: block;
  position: absolute;
  left: 0;
  top: calc(-0.03125rem * var(--mantine-scale));
  width: 100%;
  height: calc(0.0625rem * var(--mantine-scale));
  background-color: var(--table-border-color);
  z-index: 5;
}
:where([data-with-table-border]) .m_b242d975[data-sticky] .m_4e7aa4f3:first-child {
  border-top: none;
}
.m_9e5a3ac7 {
  color: var(--mantine-color-dimmed);
}
.m_9e5a3ac7:where([data-side=top]) {
  margin-bottom: var(--mantine-spacing-xs);
}
.m_9e5a3ac7:where([data-side=bottom]) {
  margin-top: var(--mantine-spacing-xs);
}
.m_a100c15 {
  overflow-x: var(--table-overflow);
}
.m_62259741 {
  min-width: var(--table-min-width);
  max-height: var(--table-max-height);
}
.m_bcaa9990 {
  display: flex;
  flex-direction: column;
  --toc-depth-offset: 0.8em;
}
.m_375a65ef {
  display: block;
  padding: 0.3em 0.8em;
  font-size: var(--toc-size, var(--mantine-font-size-md));
  border-radius: var(--toc-radius, var(--mantine-radius-default));
  padding-left: max(calc(var(--depth-offset) * var(--toc-depth-offset)), 0.8em);
}
@media (hover: hover) {
  :where([data-mantine-color-scheme=light]) .m_375a65ef:where(:hover):where(:not([data-variant=none])) {
    background-color: var(--mantine-color-gray-1);
  }
  :where([data-mantine-color-scheme=dark]) .m_375a65ef:where(:hover):where(:not([data-variant=none])) {
    background-color: var(--mantine-color-dark-5);
  }
}
@media (hover: none) {
  :where([data-mantine-color-scheme=light]) .m_375a65ef:where(:active):where(:not([data-variant=none])) {
    background-color: var(--mantine-color-gray-1);
  }
  :where([data-mantine-color-scheme=dark]) .m_375a65ef:where(:active):where(:not([data-variant=none])) {
    background-color: var(--mantine-color-dark-5);
  }
}
.m_375a65ef:where([data-active]) {
  background-color: var(--toc-bg);
  color: var(--toc-color);
}
[data-mantine-color-scheme=light] .m_89d60db1 {
  --tab-border-color: var(--mantine-color-gray-3);
}
[data-mantine-color-scheme=dark] .m_89d60db1 {
  --tab-border-color: var(--mantine-color-dark-4);
}
.m_89d60db1 {
  display: var(--tabs-display);
  flex-direction: var(--tabs-flex-direction);
  --tabs-list-direction: row;
  --tabs-panel-grow: unset;
  --tabs-display: block;
  --tabs-flex-direction: row;
  --tabs-list-border-width: 0;
  --tabs-list-border-size: 0 0 var(--tabs-list-border-width) 0;
  --tabs-list-gap: unset;
  --tabs-list-line-bottom: 0;
  --tabs-list-line-top: unset;
  --tabs-list-line-start: 0;
  --tabs-list-line-end: 0;
  --tab-radius: var(--tabs-radius) var(--tabs-radius) 0 0;
  --tab-border-width: 0 0 var(--tabs-list-border-width) 0;
}
.m_89d60db1[data-inverted] {
  --tabs-list-line-bottom: unset;
  --tabs-list-line-top: 0;
  --tab-radius: 0 0 var(--tabs-radius) var(--tabs-radius);
  --tab-border-width: var(--tabs-list-border-width) 0 0 0;
}
.m_89d60db1[data-inverted] .m_576c9d4::before {
  top: 0;
  bottom: unset;
}
.m_89d60db1[data-orientation=vertical] {
  --tabs-list-line-start: unset;
  --tabs-list-line-end: 0;
  --tabs-list-line-top: 0;
  --tabs-list-line-bottom: 0;
  --tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;
  --tab-border-width: 0 var(--tabs-list-border-width) 0 0;
  --tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius);
  --tabs-list-direction: column;
  --tabs-panel-grow: 1;
  --tabs-display: flex;
}
[dir=rtl] .m_89d60db1[data-orientation=vertical] {
  --tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);
  --tab-border-width: 0 0 0 var(--tabs-list-border-width);
  --tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0;
}
.m_89d60db1[data-orientation=vertical][data-placement=right] {
  --tabs-flex-direction: row-reverse;
  --tabs-list-line-start: 0;
  --tabs-list-line-end: unset;
  --tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);
  --tab-border-width: 0 0 0 var(--tabs-list-border-width);
  --tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0;
}
[dir=rtl] .m_89d60db1[data-orientation=vertical][data-placement=right] {
  --tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;
  --tab-border-width: 0 var(--tabs-list-border-width) 0 0;
  --tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius);
}
.m_89d60db1[data-variant=default] {
  --tabs-list-border-width: calc(0.125rem * var(--mantine-scale));
}
[data-mantine-color-scheme=light] .m_89d60db1[data-variant=default] {
  --tab-hover-color: var(--mantine-color-gray-0);
}
[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=default] {
  --tab-hover-color: var(--mantine-color-dark-6);
}
.m_89d60db1[data-variant=outline] {
  --tabs-list-border-width: calc(0.0625rem * var(--mantine-scale));
}
.m_89d60db1[data-variant=pills] {
  --tabs-list-gap: calc(var(--mantine-spacing-sm) / 2);
}
[data-mantine-color-scheme=light] .m_89d60db1[data-variant=pills] {
  --tab-hover-color: var(--mantine-color-gray-0);
}
[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=pills] {
  --tab-hover-color: var(--mantine-color-dark-6);
}
.m_89d33d6d {
  display: flex;
  flex-wrap: wrap;
  justify-content: var(--tabs-justify, flex-start);
  flex-direction: var(--tabs-list-direction);
  gap: var(--tabs-list-gap);
}
.m_89d33d6d:where([data-grow]) .m_4ec4dce6 {
  flex: 1;
}
.m_b0c91715 {
  flex-grow: var(--tabs-panel-grow);
}
.m_4ec4dce6 {
  position: relative;
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-md);
  font-size: var(--mantine-font-size-sm);
  white-space: nowrap;
  z-index: 0;
  display: flex;
  align-items: center;
  line-height: 1;
  user-select: none;
}
.m_4ec4dce6:where(:disabled, [data-disabled]) {
  opacity: 0.5;
  cursor: not-allowed;
}
.m_4ec4dce6:focus {
  z-index: 1;
}
.m_fc420b1f {
  display: flex;
  align-items: center;
  justify-content: center;
}
.m_fc420b1f:where([data-position=left]:not(:only-child)) {
  margin-inline-end: var(--mantine-spacing-xs);
}
.m_fc420b1f:where([data-position=right]:not(:only-child)) {
  margin-inline-start: var(--mantine-spacing-xs);
}
.m_42bbd1ae {
  flex: 1;
  text-align: center;
}
.m_576c9d4 {
  position: relative;
}
.m_576c9d4::before {
  content: "";
  position: absolute;
  border: 1px solid var(--tab-border-color);
  bottom: var(--tabs-list-line-bottom);
  inset-inline-start: var(--tabs-list-line-start);
  inset-inline-end: var(--tabs-list-line-end);
  top: var(--tabs-list-line-top);
}
.m_539e827b {
  border-radius: var(--tab-radius);
  border-width: var(--tab-border-width);
  border-style: solid;
  border-color: transparent;
  background-color: transparent;
}
.m_539e827b:where([data-active]) {
  border-color: var(--tabs-color);
}
@media (hover: hover) {
  .m_539e827b:hover {
    background-color: var(--tab-hover-color);
  }
  .m_539e827b:hover:where(:not([data-active])) {
    border-color: var(--tab-border-color);
  }
}
@media (hover: none) {
  .m_539e827b:active {
    background-color: var(--tab-hover-color);
  }
  .m_539e827b:active:where(:not([data-active])) {
    border-color: var(--tab-border-color);
  }
}
@media (hover: hover) {
  .m_539e827b:disabled:hover,
  .m_539e827b[data-disabled]:hover {
    background-color: transparent;
  }
}
@media (hover: none) {
  .m_539e827b:disabled:active,
  .m_539e827b[data-disabled]:active {
    background-color: transparent;
  }
}
.m_6772fbd5 {
  position: relative;
}
.m_6772fbd5::before {
  content: "";
  position: absolute;
  border-color: var(--tab-border-color);
  border-width: var(--tabs-list-border-size);
  border-style: solid;
  bottom: var(--tabs-list-line-bottom);
  inset-inline-start: var(--tabs-list-line-start);
  inset-inline-end: var(--tabs-list-line-end);
  top: var(--tabs-list-line-top);
}
.m_b59ab47c {
  border-top: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  border-bottom: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  border-right: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  border-left: calc(0.0625rem * var(--mantine-scale)) solid transparent;
  border-top-color: var(--tab-border-top-color);
  border-bottom-color: var(--tab-border-bottom-color);
  border-radius: var(--tab-radius);
  position: relative;
  --tab-border-bottom-color: transparent;
  --tab-border-top-color: transparent;
  --tab-border-inline-end-color: transparent;
  --tab-border-inline-start-color: transparent;
}
.m_b59ab47c:where([data-active])::before {
  content: "";
  position: absolute;
  background-color: var(--tab-border-color);
  bottom: var(--tab-before-bottom, calc(-0.0625rem * var(--mantine-scale)));
  left: var(--tab-before-left, calc(-0.0625rem * var(--mantine-scale)));
  right: var(--tab-before-right, auto);
  top: var(--tab-before-top, auto);
  width: calc(0.0625rem * var(--mantine-scale));
  height: calc(0.0625rem * var(--mantine-scale));
}
.m_b59ab47c:where([data-active])::after {
  content: "";
  position: absolute;
  background-color: var(--tab-border-color);
  bottom: var(--tab-after-bottom, calc(-0.0625rem * var(--mantine-scale)));
  right: var(--tab-after-right, calc(-0.0625rem * var(--mantine-scale)));
  left: var(--tab-after-left, auto);
  top: var(--tab-after-top, auto);
  width: calc(0.0625rem * var(--mantine-scale));
  height: calc(0.0625rem * var(--mantine-scale));
}
.m_b59ab47c:where([data-active]) {
  border-top-color: var(--tab-border-top-color);
  border-bottom-color: var(--tab-border-bottom-color);
  border-inline-start-color: var(--tab-border-inline-start-color);
  border-inline-end-color: var(--tab-border-inline-end-color);
  --tab-border-top-color: var(--tab-border-color);
  --tab-border-inline-start-color: var(--tab-border-color);
  --tab-border-inline-end-color: var(--tab-border-color);
  --tab-border-bottom-color: var(--mantine-color-body);
}
.m_b59ab47c:where([data-active])[data-inverted] {
  --tab-border-bottom-color: var(--tab-border-color);
  --tab-border-top-color: var(--mantine-color-body);
  --tab-before-bottom: auto;
  --tab-before-top: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-bottom: auto;
  --tab-after-top: calc(-0.0625rem * var(--mantine-scale));
}
.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left] {
  --tab-border-inline-end-color: var(--mantine-color-body);
  --tab-border-inline-start-color: var(--tab-border-color);
  --tab-border-bottom-color: var(--tab-border-color);
  --tab-before-right: calc(-0.0625rem * var(--mantine-scale));
  --tab-before-left: auto;
  --tab-before-bottom: auto;
  --tab-before-top: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-left: auto;
  --tab-after-right: calc(-0.0625rem * var(--mantine-scale));
}
[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left] {
  --tab-before-right: auto;
  --tab-before-left: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-left: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-right: auto;
}
.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right] {
  --tab-border-inline-start-color: var(--mantine-color-body);
  --tab-border-inline-end-color: var(--tab-border-color);
  --tab-border-bottom-color: var(--tab-border-color);
  --tab-before-left: calc(-0.0625rem * var(--mantine-scale));
  --tab-before-right: auto;
  --tab-before-bottom: auto;
  --tab-before-top: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-right: auto;
  --tab-after-left: calc(-0.0625rem * var(--mantine-scale));
}
[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right] {
  --tab-before-left: auto;
  --tab-before-right: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-right: calc(-0.0625rem * var(--mantine-scale));
  --tab-after-left: auto;
}
.m_c3381914 {
  border-radius: var(--tabs-radius);
  background-color: var(--tab-bg);
  color: var(--tab-color);
  --tab-bg: transparent;
  --tab-color: inherit;
}
@media (hover: hover) {
  .m_c3381914:not([data-disabled]):hover {
    --tab-bg: var(--tab-hover-color);
  }
}
@media (hover: none) {
  .m_c3381914:not([data-disabled]):active {
    --tab-bg: var(--tab-hover-color);
  }
}
.m_c3381914[data-active][data-active] {
  --tab-bg: var(--tabs-color);
  --tab-color: var(--tabs-text-color, var(--mantine-color-white));
}
@media (hover: hover) {
  .m_c3381914[data-active][data-active]:hover {
    --tab-bg: var(--tabs-color);
  }
}
@media (hover: none) {
  .m_c3381914[data-active][data-active]:active {
    --tab-bg: var(--tabs-color);
  }
}
.m_7341320d {
  --ti-size-xs: calc(1.125rem * var(--mantine-scale));
  --ti-size-sm: calc(1.375rem * var(--mantine-scale));
  --ti-size-md: calc(1.75rem * var(--mantine-scale));
  --ti-size-lg: calc(2.125rem * var(--mantine-scale));
  --ti-size-xl: calc(2.75rem * var(--mantine-scale));
  --ti-size: var(--ti-size-md);
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  user-select: none;
  width: var(--ti-size);
  height: var(--ti-size);
  min-width: var(--ti-size);
  min-height: var(--ti-size);
  border-radius: var(--ti-radius, var(--mantine-radius-default));
  background: var(--ti-bg, var(--mantine-primary-color-filled));
  color: var(--ti-color, var(--mantine-color-white));
  border: var(--ti-bd, 1px solid transparent);
}
.m_43657ece {
  --offset: calc(var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2);
  --tl-bullet-size: calc(1.25rem * var(--mantine-scale));
  --tl-line-width: calc(0.25rem * var(--mantine-scale));
  --tl-radius: calc(62.5rem * var(--mantine-scale));
  --tl-color: var(--mantine-primary-color-filled);
}
.m_43657ece:where([data-align=left]) {
  padding-inline-start: var(--offset);
}
.m_43657ece:where([data-align=right]) {
  padding-inline-end: var(--offset);
}
.m_2ebe8099 {
  font-weight: 500;
  line-height: 1;
  margin-bottom: calc(var(--mantine-spacing-xs) / 2);
}
.m_436178ff {
  --item-border: var(--tl-line-width) var(--tli-border-style, solid) var(--item-border-color);
  position: relative;
  color: var(--mantine-color-text);
}
.m_436178ff::before {
  content: "";
  pointer-events: none;
  position: absolute;
  top: 0;
  left: var(--timeline-line-left, 0);
  right: var(--timeline-line-right, 0);
  bottom: calc(var(--mantine-spacing-xl) * -1);
  border-inline-start: var(--item-border);
  display: var(--timeline-line-display, none);
}
.m_43657ece[data-align=left] .m_436178ff::before {
  --timeline-line-left: calc(var(--tl-line-width) * -1);
  --timeline-line-right: auto;
}
[dir=rtl] .m_43657ece[data-align=left] .m_436178ff::before {
  --timeline-line-left: auto;
  --timeline-line-right: calc(var(--tl-line-width) * -1);
}
.m_43657ece[data-align=right] .m_436178ff::before {
  --timeline-line-left: auto;
  --timeline-line-right: calc(var(--tl-line-width) * -1);
}
[dir=rtl] .m_43657ece[data-align=right] .m_436178ff::before {
  --timeline-line-left: calc(var(--tl-line-width) * -1);
  --timeline-line-right: auto;
}
.m_43657ece:where([data-align=left]) .m_436178ff {
  padding-inline-start: var(--offset);
  text-align: left;
}
.m_43657ece:where([data-align=right]) .m_436178ff {
  padding-inline-end: var(--offset);
  text-align: right;
}
:where([data-mantine-color-scheme=light]) .m_436178ff {
  --item-border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_436178ff {
  --item-border-color: var(--mantine-color-dark-4);
}
.m_436178ff:where([data-line-active])::before {
  border-color: var(--tli-color, var(--tl-color));
}
.m_436178ff:where(:not(:last-of-type)) {
  --timeline-line-display: block;
}
.m_436178ff:where(:not(:first-of-type)) {
  margin-top: var(--mantine-spacing-xl);
}
.m_8affcee1 {
  width: var(--tl-bullet-size);
  height: var(--tl-bullet-size);
  border-radius: var(--tli-radius, var(--tl-radius));
  border: var(--tl-line-width) solid;
  background-color: var(--mantine-color-body);
  position: absolute;
  top: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--mantine-color-text);
}
:where([data-mantine-color-scheme=light]) .m_8affcee1 {
  border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_8affcee1 {
  border-color: var(--mantine-color-dark-4);
}
.m_43657ece:where([data-align=left]) .m_8affcee1 {
  left: calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);
  right: auto;
}
:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_8affcee1 {
  left: auto;
  right: calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);
}
.m_43657ece:where([data-align=right]) .m_8affcee1 {
  left: auto;
  right: calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);
}
:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_8affcee1 {
  left: calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);
  right: auto;
}
.m_8affcee1:where([data-with-child]) {
  border-width: var(--tl-line-width);
}
:where([data-mantine-color-scheme=light]) .m_8affcee1:where([data-with-child]) {
  background-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_8affcee1:where([data-with-child]) {
  background-color: var(--mantine-color-dark-4);
}
.m_8affcee1:where([data-active]) {
  border-color: var(--tli-color, var(--tl-color));
  background-color: var(--mantine-color-white);
  color: var(--tl-icon-color, var(--mantine-color-white));
}
.m_8affcee1:where([data-active]):where([data-with-child]) {
  background-color: var(--tli-color, var(--tl-color));
  color: var(--tl-icon-color, var(--mantine-color-white));
}
.m_43657ece:where([data-align=left]) .m_540e8f41 {
  padding-inline-start: var(--offset);
  text-align: left;
}
:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_540e8f41 {
  text-align: right;
}
.m_43657ece:where([data-align=right]) .m_540e8f41 {
  padding-inline-end: var(--offset);
  text-align: right;
}
:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_540e8f41 {
  text-align: left;
}
.m_8a5d1357 {
  margin: 0;
  font-weight: var(--title-fw);
  font-size: var(--title-fz);
  line-height: var(--title-lh);
  font-family: var(--mantine-font-family-headings);
  text-wrap: var(--title-text-wrap, var(--mantine-heading-text-wrap));
}
.m_8a5d1357:where([data-line-clamp]) {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: var(--title-line-clamp);
  -webkit-box-orient: vertical;
}
.m_f698e191 {
  --level-offset: var(--mantine-spacing-lg);
  margin: 0;
  padding: 0;
  user-select: none;
}
.m_75f3ecf {
  margin: 0;
  padding: 0;
}
.m_f6970eb1 {
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding: 0;
  outline: 0;
}
.m_f6970eb1:focus-visible > .m_dc283425 {
  outline: 2px solid var(--mantine-primary-color-filled);
  outline-offset: calc(0.125rem * var(--mantine-scale));
}
.m_dc283425 {
  padding-inline-start: var(--label-offset);
}
:where([data-mantine-color-scheme=light]) .m_dc283425:where([data-selected]) {
  background-color: var(--mantine-color-gray-1);
}
:where([data-mantine-color-scheme=dark]) .m_dc283425:where([data-selected]) {
  background-color: var(--mantine-color-dark-5);
}
.m_d08caa0 :first-child {
  margin-top: 0;
}
.m_d08caa0 :last-child {
  margin-bottom: 0;
}
.m_d08caa0 :where(h1, h2, h3, h4, h5, h6) {
  margin-bottom: var(--mantine-spacing-xs);
  text-wrap: var(--mantine-heading-text-wrap);
  font-family: var(--mantine-font-family-headings);
}
.m_d08caa0 :where(h1) {
  margin-top: calc(1.5 * var(--mantine-spacing-xl));
  font-size: var(--mantine-h1-font-size);
  line-height: var(--mantine-h1-line-height);
  font-weight: var(--mantine-h1-font-weight);
}
.m_d08caa0 :where(h2) {
  margin-top: var(--mantine-spacing-xl);
  font-size: var(--mantine-h2-font-size);
  line-height: var(--mantine-h2-line-height);
  font-weight: var(--mantine-h2-font-weight);
}
.m_d08caa0 :where(h3) {
  margin-top: calc(0.8 * var(--mantine-spacing-xl));
  font-size: var(--mantine-h3-font-size);
  line-height: var(--mantine-h3-line-height);
  font-weight: var(--mantine-h3-font-weight);
}
.m_d08caa0 :where(h4) {
  margin-top: calc(0.8 * var(--mantine-spacing-xl));
  font-size: var(--mantine-h4-font-size);
  line-height: var(--mantine-h4-line-height);
  font-weight: var(--mantine-h4-font-weight);
}
.m_d08caa0 :where(h5) {
  margin-top: calc(0.5 * var(--mantine-spacing-xl));
  font-size: var(--mantine-h5-font-size);
  line-height: var(--mantine-h5-line-height);
  font-weight: var(--mantine-h5-font-weight);
}
.m_d08caa0 :where(h6) {
  margin-top: calc(0.5 * var(--mantine-spacing-xl));
  font-size: var(--mantine-h6-font-size);
  line-height: var(--mantine-h6-line-height);
  font-weight: var(--mantine-h6-font-weight);
}
.m_d08caa0 :where(img) {
  max-width: 100%;
  margin-bottom: var(--mantine-spacing-xs);
}
.m_d08caa0 :where(p) {
  margin-top: 0;
  margin-bottom: var(--mantine-spacing-lg);
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(mark) {
  background-color: var(--mantine-color-yellow-2);
  color: inherit;
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(mark) {
  background-color: var(--mantine-color-yellow-5);
  color: var(--mantine-color-black);
}
.m_d08caa0 :where(a) {
  color: var(--mantine-color-anchor);
  text-decoration: none;
}
@media (hover: hover) {
  .m_d08caa0 :where(a):hover {
    text-decoration: underline;
  }
}
@media (hover: none) {
  .m_d08caa0 :where(a):active {
    text-decoration: underline;
  }
}
.m_d08caa0 :where(hr) {
  margin-top: var(--mantine-spacing-md);
  margin-bottom: var(--mantine-spacing-md);
  border: 0;
  border-top: calc(0.0625rem * var(--mantine-scale)) solid;
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(hr) {
  border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(hr) {
  border-color: var(--mantine-color-dark-3);
}
.m_d08caa0 :where(pre) {
  padding: var(--mantine-spacing-xs);
  line-height: var(--mantine-line-height);
  margin: 0;
  margin-top: var(--mantine-spacing-md);
  margin-bottom: var(--mantine-spacing-md);
  overflow-x: auto;
  font-family: var(--mantine-font-family-monospace);
  font-size: var(--mantine-font-size-xs);
  border-radius: var(--mantine-radius-sm);
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(pre) {
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(pre) {
  background-color: var(--mantine-color-dark-8);
}
.m_d08caa0 :where(pre) :where(code) {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
  color: inherit;
  border: 0;
}
.m_d08caa0 :where(kbd) {
  --kbd-fz: calc(0.75rem * var(--mantine-scale));
  --kbd-padding: calc(0.1875rem * var(--mantine-scale)) calc(0.3125rem * var(--mantine-scale));
  font-family: var(--mantine-font-family-monospace);
  line-height: var(--mantine-line-height);
  font-weight: 700;
  padding: var(--kbd-padding);
  font-size: var(--kbd-fz);
  border-radius: var(--mantine-radius-sm);
  border: calc(0.0625rem * var(--mantine-scale)) solid;
  border-bottom-width: calc(0.1875rem * var(--mantine-scale));
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(kbd) {
  border-color: var(--mantine-color-gray-3);
  color: var(--mantine-color-gray-7);
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(kbd) {
  border-color: var(--mantine-color-dark-3);
  color: var(--mantine-color-dark-0);
  background-color: var(--mantine-color-dark-5);
}
.m_d08caa0 :where(code) {
  line-height: var(--mantine-line-height);
  padding: calc(0.0625rem * var(--mantine-scale)) calc(0.3125rem * var(--mantine-scale));
  border-radius: var(--mantine-radius-sm);
  font-family: var(--mantine-font-family-monospace);
  font-size: var(--mantine-font-size-xs);
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(code) {
  background-color: var(--mantine-color-gray-0);
  color: var(--mantine-color-black);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(code) {
  background-color: var(--mantine-color-dark-5);
  color: var(--mantine-color-white);
}
.m_d08caa0 :where(ul, ol):not([data-type=taskList]) {
  margin-bottom: var(--mantine-spacing-md);
  padding-inline-start: var(--mantine-spacing-xl);
  list-style-position: outside;
}
.m_d08caa0 :where(table) {
  width: 100%;
  border-collapse: collapse;
  caption-side: bottom;
  margin-bottom: var(--mantine-spacing-md);
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(table) {
  --table-border-color: var(--mantine-color-gray-3);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(table) {
  --table-border-color: var(--mantine-color-dark-4);
}
.m_d08caa0 :where(table) :where(caption) {
  margin-top: var(--mantine-spacing-xs);
  font-size: var(--mantine-font-size-sm);
  color: var(--mantine-color-dimmed);
}
.m_d08caa0 :where(table) :where(th) {
  text-align: left;
  font-weight: bold;
  font-size: var(--mantine-font-size-sm);
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-sm);
}
.m_d08caa0 :where(table) :where(thead th) {
  border-bottom: calc(0.0625rem * var(--mantine-scale)) solid;
  border-color: var(--table-border-color);
}
.m_d08caa0 :where(table) :where(tfoot th) {
  border-top: calc(0.0625rem * var(--mantine-scale)) solid;
  border-color: var(--table-border-color);
}
.m_d08caa0 :where(table) :where(td) {
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-sm);
  border-bottom: calc(0.0625rem * var(--mantine-scale)) solid;
  border-color: var(--table-border-color);
  font-size: var(--mantine-font-size-sm);
}
.m_d08caa0 :where(table) :where(tr:last-of-type td) {
  border-bottom: 0;
}
.m_d08caa0 :where(blockquote) {
  font-size: var(--mantine-font-size-lg);
  line-height: var(--mantine-line-height);
  margin: var(--mantine-spacing-md) 0;
  border-radius: var(--mantine-radius-sm);
  padding: var(--mantine-spacing-md) var(--mantine-spacing-lg);
}
:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(blockquote) {
  background-color: var(--mantine-color-gray-0);
}
:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(blockquote) {
  background-color: var(--mantine-color-dark-8);
}

/* node_modules/@mantine/carousel/styles.css */
.m_17884d0f {
  --carousel-height: auto;
  position: relative;
}
.m_a2dae653 {
  height: var(--carousel-height);
  overflow: hidden;
}
.m_a2dae653[data-type=container] {
  container: carousel / inline-size;
}
.m_fcd81474 {
  display: flex;
  flex-direction: row;
  height: var(--carousel-height);
}
:where([data-include-gap-in-size]) .m_fcd81474:where([data-orientation=vertical]) {
  margin-bottom: calc(var(--carousel-slide-gap) * -1);
}
:where([data-include-gap-in-size]) .m_fcd81474:where([data-orientation=horizontal]) {
  margin-inline-end: calc(var(--carousel-slide-gap) * -1);
}
.m_fcd81474:where([data-orientation=vertical]) {
  flex-direction: column;
}
.m_39bc3463 {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: space-between;
  z-index: 1;
  pointer-events: none;
}
.m_39bc3463:where([data-orientation=vertical]) {
  inset-inline-start: calc(50% - var(--carousel-control-size) / 2);
  top: 0;
  bottom: 0;
  flex-direction: column;
  padding: var(--carousel-controls-offset) 0;
}
.m_39bc3463:where([data-orientation=horizontal]) {
  inset-inline-start: 0;
  inset-inline-end: 0;
  top: calc(50% - var(--carousel-control-size) / 2);
  flex-direction: row;
  padding: 0 var(--carousel-controls-offset);
}
.m_64f58e10 {
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: var(--carousel-control-size);
  min-height: var(--carousel-control-size);
  border-radius: var(--carousel-control-size);
  pointer-events: all;
  background-color: var(--mantine-color-white);
  color: var(--mantine-color-black);
  box-shadow: var(--mantine-shadow-md);
  border: 1px solid var(--mantine-color-gray-3);
  transition: opacity 100ms ease;
}
:where([data-mantine-color-scheme=light]) .m_64f58e10 {
  opacity: 0.85;
}
:where([data-mantine-color-scheme=dark]) .m_64f58e10 {
  opacity: 0.65;
}
@media (hover: hover) {
  .m_64f58e10:hover {
    opacity: 1;
  }
}
@media (hover: none) {
  .m_64f58e10:active {
    opacity: 1;
  }
}
.m_71ea3ab1 {
  position: absolute;
  display: flex;
  justify-content: center;
  gap: calc(0.5rem * var(--mantine-scale));
  pointer-events: none;
}
.m_71ea3ab1:where([data-orientation=vertical]) {
  bottom: 0;
  top: 0;
  inset-inline-end: var(--mantine-spacing-md);
  flex-direction: column;
}
.m_71ea3ab1:where([data-orientation=horizontal]) {
  bottom: var(--mantine-spacing-md);
  inset-inline-start: 0;
  inset-inline-end: 0;
  flex-direction: row;
}
.m_eae68602 {
  pointer-events: all;
  border-radius: var(--mantine-radius-xl);
  box-shadow: var(--mantine-shadow-sm);
  opacity: 0.6;
  background-color: var(--mantine-color-white);
}
@media (hover: hover) {
  .m_eae68602:hover {
    opacity: 1;
  }
}
@media (hover: none) {
  .m_eae68602:active {
    opacity: 1;
  }
}
.m_eae68602:where([data-active]) {
  opacity: 1;
}
.m_eae68602:where([data-orientation=vertical]) {
  width: calc(0.3125rem * var(--mantine-scale));
  height: calc(1.5625rem * var(--mantine-scale));
}
.m_eae68602:where([data-orientation=horizontal]) {
  width: calc(1.5625rem * var(--mantine-scale));
  height: calc(0.3125rem * var(--mantine-scale));
}
.m_d98df724 {
  position: relative;
  flex: 0 0 var(--carousel-slide-size, 100%);
}
.m_17884d0f:where([data-include-gap-in-size]) .m_d98df724:where([data-orientation=vertical]) {
  padding-bottom: var(--carousel-slide-gap);
}
.m_17884d0f:where([data-include-gap-in-size]) .m_d98df724:where([data-orientation=horizontal]) {
  padding-inline-end: var(--carousel-slide-gap);
}
.m_17884d0f:where(:not([data-include-gap-in-size])) .m_d98df724:where([data-orientation=vertical]) {
  margin-bottom: var(--carousel-slide-gap);
}
.m_17884d0f:where(:not([data-include-gap-in-size])) .m_d98df724:where([data-orientation=horizontal]) {
  margin-inline-end: var(--carousel-slide-gap);
}

/* node_modules/mapbox-gl/dist/mapbox-gl.css */
.mapboxgl-map {
  -webkit-tap-highlight-color: rgb(0 0 0/0);
  font:
    12px/20px Helvetica Neue,
    Arial,
    Helvetica,
    sans-serif;
  overflow: hidden;
  position: relative;
}
.mapboxgl-canvas {
  left: 0;
  position: absolute;
  top: 0;
}
.mapboxgl-map:-webkit-full-screen {
  height: 100%;
  width: 100%;
}
.mapboxgl-canary {
  background-color: salmon;
}
.mapboxgl-canvas-container.mapboxgl-interactive,
.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass {
  cursor: grab;
  -webkit-user-select: none;
  user-select: none;
}
.mapboxgl-canvas-container.mapboxgl-interactive.mapboxgl-track-pointer {
  cursor: pointer;
}
.mapboxgl-canvas-container.mapboxgl-interactive:active,
.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass:active {
  cursor: grabbing;
}
.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate,
.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate .mapboxgl-canvas {
  touch-action: pan-x pan-y;
}
.mapboxgl-canvas-container.mapboxgl-touch-drag-pan,
.mapboxgl-canvas-container.mapboxgl-touch-drag-pan .mapboxgl-canvas {
  touch-action: pinch-zoom;
}
.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,
.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas {
  touch-action: none;
}
.mapboxgl-ctrl-bottom-left,
.mapboxgl-ctrl-bottom-right,
.mapboxgl-ctrl-top-left,
.mapboxgl-ctrl-top-right {
  pointer-events: none;
  position: absolute;
  z-index: 2;
}
.mapboxgl-ctrl-top-left {
  left: 0;
  top: 0;
}
.mapboxgl-ctrl-top-right {
  right: 0;
  top: 0;
}
.mapboxgl-ctrl-bottom-left {
  bottom: 0;
  left: 0;
}
.mapboxgl-ctrl-bottom-right {
  bottom: 0;
  right: 0;
}
.mapboxgl-ctrl {
  clear: both;
  pointer-events: auto;
  transform: translate(0);
}
.mapboxgl-ctrl-top-left .mapboxgl-ctrl {
  float: left;
  margin: 10px 0 0 10px;
}
.mapboxgl-ctrl-top-right .mapboxgl-ctrl {
  float: right;
  margin: 10px 10px 0 0;
}
.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl {
  float: left;
  margin: 0 0 10px 10px;
}
.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl {
  float: right;
  margin: 0 10px 10px 0;
}
.mapboxgl-ctrl-group {
  background: #fff;
  border-radius: 4px;
}
.mapboxgl-ctrl-group:not(:empty) {
  box-shadow: 0 0 0 2px rgba(0, 0, 0, .1);
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl-group:not(:empty) {
    box-shadow: 0 0 0 2px ButtonText;
  }
}
.mapboxgl-ctrl-group button {
  background-color: transparent;
  border: 0;
  box-sizing: border-box;
  cursor: pointer;
  display: block;
  height: 29px;
  outline: none;
  overflow: hidden;
  padding: 0;
  width: 29px;
}
.mapboxgl-ctrl-group button + button {
  border-top: 1px solid #ddd;
}
.mapboxgl-ctrl button .mapboxgl-ctrl-icon {
  background-position: 50%;
  background-repeat: no-repeat;
  display: block;
  height: 100%;
  width: 100%;
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl-icon {
    background-color: transparent;
  }
  .mapboxgl-ctrl-group button + button {
    border-top: 1px solid ButtonText;
  }
}
.mapboxgl-ctrl-attrib-button:focus,
.mapboxgl-ctrl-group button:focus {
  box-shadow: 0 0 2px 2px #0096ff;
}
.mapboxgl-ctrl button:disabled {
  cursor: not-allowed;
}
.mapboxgl-ctrl button:disabled .mapboxgl-ctrl-icon {
  opacity: .25;
}
.mapboxgl-ctrl-group button:first-child {
  border-radius: 4px 4px 0 0;
}
.mapboxgl-ctrl-group button:last-child {
  border-radius: 0 0 4px 4px;
}
.mapboxgl-ctrl-group button:only-child {
  border-radius: inherit;
}
.mapboxgl-ctrl button:not(:disabled):hover {
  background-color: rgb(0 0 0/5%);
}
.mapboxgl-ctrl-group button:focus:focus-visible {
  box-shadow: 0 0 2px 2px #0096ff;
}
.mapboxgl-ctrl-group button:focus:not(:focus-visible) {
  box-shadow: none;
}
.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E");
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E");
  }
}
@media (-ms-high-contrast:black-on-white) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E");
  }
}
.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E");
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E");
  }
}
@media (-ms-high-contrast:black-on-white) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E");
  }
}
.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E");
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23999'/%3E%3C/svg%3E");
  }
}
@media (-ms-high-contrast:black-on-white) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E");
  }
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23aaa'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
}
.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-waiting .mapboxgl-ctrl-icon {
  animation: mapboxgl-spin 2s linear infinite;
}
@media (-ms-high-contrast:active) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23999'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
}
@media (-ms-high-contrast:black-on-white) {
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23000'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E");
  }
  .mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23666'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E");
  }
}
@keyframes mapboxgl-spin {
  0% {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(1turn);
  }
}
a.mapboxgl-ctrl-logo {
  background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='0.3' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='0.9' fill='%23fff'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E");
  background-repeat: no-repeat;
  cursor: pointer;
  display: block;
  height: 23px;
  margin: 0 0 -4px -4px;
  overflow: hidden;
  width: 88px;
}
a.mapboxgl-ctrl-logo.mapboxgl-compact {
  width: 23px;
}
@media (-ms-high-contrast:active) {
  a.mapboxgl-ctrl-logo {
    background-color: transparent;
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='1' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='1' fill='%23fff'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E");
  }
}
@media (-ms-high-contrast:black-on-white) {
  a.mapboxgl-ctrl-logo {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='1' stroke='%23fff' stroke-width='3' fill='%23fff'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='1' fill='%23000'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E");
  }
}
.mapboxgl-ctrl.mapboxgl-ctrl-attrib {
  background-color: hsla(0, 0%, 100%, .5);
  margin: 0;
  padding: 0 5px;
}
@media screen {
  .mapboxgl-ctrl-attrib.mapboxgl-compact {
    background-color: #fff;
    border-radius: 12px;
    margin: 10px;
    min-height: 20px;
    padding: 2px 24px 2px 0;
    position: relative;
  }
  .mapboxgl-ctrl-attrib.mapboxgl-compact-show {
    padding: 2px 28px 2px 8px;
    visibility: visible;
  }
  .mapboxgl-ctrl-bottom-left > .mapboxgl-ctrl-attrib.mapboxgl-compact-show,
  .mapboxgl-ctrl-top-left > .mapboxgl-ctrl-attrib.mapboxgl-compact-show {
    border-radius: 12px;
    padding: 2px 8px 2px 28px;
  }
  .mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-inner {
    display: none;
  }
  .mapboxgl-ctrl-attrib-button {
    background-color: hsla(0, 0%, 100%, .5);
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");
    border: 0;
    border-radius: 12px;
    box-sizing: border-box;
    cursor: pointer;
    display: none;
    height: 24px;
    outline: none;
    position: absolute;
    right: 0;
    top: 0;
    width: 24px;
  }
  .mapboxgl-ctrl-bottom-left .mapboxgl-ctrl-attrib-button,
  .mapboxgl-ctrl-top-left .mapboxgl-ctrl-attrib-button {
    left: 0;
  }
  .mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-button,
  .mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-inner {
    display: block;
  }
  .mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-button {
    background-color: rgb(0 0 0/5%);
  }
  .mapboxgl-ctrl-bottom-right > .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    bottom: 0;
    right: 0;
  }
  .mapboxgl-ctrl-top-right > .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    right: 0;
    top: 0;
  }
  .mapboxgl-ctrl-top-left > .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    left: 0;
    top: 0;
  }
  .mapboxgl-ctrl-bottom-left > .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    bottom: 0;
    left: 0;
  }
}
@media screen and (-ms-high-contrast:active) {
  .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' fill='%23fff'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");
  }
}
@media screen and (-ms-high-contrast:black-on-white) {
  .mapboxgl-ctrl-attrib.mapboxgl-compact:after {
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");
  }
}
.mapboxgl-ctrl-attrib a {
  color: rgba(0, 0, 0, .75);
  text-decoration: none;
}
.mapboxgl-ctrl-attrib a:hover {
  color: inherit;
  text-decoration: underline;
}
.mapboxgl-ctrl-attrib .mapbox-improve-map {
  font-weight: 700;
  margin-left: 2px;
}
.mapboxgl-attrib-empty {
  display: none;
}
.mapboxgl-ctrl-scale {
  background-color: hsla(0, 0%, 100%, .75);
  border: 2px solid #333;
  border-top: #333;
  box-sizing: border-box;
  color: #333;
  font-size: 10px;
  padding: 0 5px;
  white-space: nowrap;
}
.mapboxgl-popup {
  display: flex;
  left: 0;
  pointer-events: none;
  position: absolute;
  top: 0;
  will-change: transform;
}
.mapboxgl-popup-anchor-top,
.mapboxgl-popup-anchor-top-left,
.mapboxgl-popup-anchor-top-right {
  flex-direction: column;
}
.mapboxgl-popup-anchor-bottom,
.mapboxgl-popup-anchor-bottom-left,
.mapboxgl-popup-anchor-bottom-right {
  flex-direction: column-reverse;
}
.mapboxgl-popup-anchor-left {
  flex-direction: row;
}
.mapboxgl-popup-anchor-right {
  flex-direction: row-reverse;
}
.mapboxgl-popup-tip {
  border: 10px solid transparent;
  height: 0;
  width: 0;
  z-index: 1;
}
.mapboxgl-popup-anchor-top .mapboxgl-popup-tip {
  align-self: center;
  border-bottom-color: #fff;
  border-top: none;
}
.mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip {
  align-self: flex-start;
  border-bottom-color: #fff;
  border-left: none;
  border-top: none;
}
.mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip {
  align-self: flex-end;
  border-bottom-color: #fff;
  border-right: none;
  border-top: none;
}
.mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip {
  align-self: center;
  border-bottom: none;
  border-top-color: #fff;
}
.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip {
  align-self: flex-start;
  border-bottom: none;
  border-left: none;
  border-top-color: #fff;
}
.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip {
  align-self: flex-end;
  border-bottom: none;
  border-right: none;
  border-top-color: #fff;
}
.mapboxgl-popup-anchor-left .mapboxgl-popup-tip {
  align-self: center;
  border-left: none;
  border-right-color: #fff;
}
.mapboxgl-popup-anchor-right .mapboxgl-popup-tip {
  align-self: center;
  border-left-color: #fff;
  border-right: none;
}
.mapboxgl-popup-close-button {
  background-color: transparent;
  border: 0;
  border-radius: 0 3px 0 0;
  cursor: pointer;
  position: absolute;
  right: 0;
  top: 0;
}
.mapboxgl-popup-close-button:hover {
  background-color: rgb(0 0 0/5%);
}
.mapboxgl-popup-content {
  background: #fff;
  border-radius: 3px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, .1);
  padding: 10px 10px 15px;
  pointer-events: auto;
  position: relative;
}
.mapboxgl-popup-anchor-top-left .mapboxgl-popup-content {
  border-top-left-radius: 0;
}
.mapboxgl-popup-anchor-top-right .mapboxgl-popup-content {
  border-top-right-radius: 0;
}
.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-content {
  border-bottom-left-radius: 0;
}
.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-content {
  border-bottom-right-radius: 0;
}
.mapboxgl-popup-track-pointer {
  display: none;
}
.mapboxgl-popup-track-pointer * {
  pointer-events: none;
  user-select: none;
}
.mapboxgl-map:hover .mapboxgl-popup-track-pointer {
  display: flex;
}
.mapboxgl-map:active .mapboxgl-popup-track-pointer {
  display: none;
}
.mapboxgl-marker {
  left: 0;
  opacity: 1;
  position: absolute;
  top: 0;
  transition: opacity .2s;
  will-change: transform;
}
.mapboxgl-user-location-dot,
.mapboxgl-user-location-dot:before {
  background-color: #1da1f2;
  border-radius: 50%;
  height: 15px;
  width: 15px;
}
.mapboxgl-user-location-dot:before {
  animation: mapboxgl-user-location-dot-pulse 2s infinite;
  content: "";
  position: absolute;
}
.mapboxgl-user-location-dot:after {
  border: 2px solid #fff;
  border-radius: 50%;
  box-shadow: 0 0 3px rgba(0, 0, 0, .35);
  box-sizing: border-box;
  content: "";
  height: 19px;
  left: -2px;
  position: absolute;
  top: -2px;
  width: 19px;
}
.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading {
  height: 0;
  width: 0;
}
.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:after,
.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:before {
  border-bottom: 7.5px solid #4aa1eb;
  content: "";
  position: absolute;
}
.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:before {
  border-left: 7.5px solid transparent;
  transform: translateY(-28px) skewY(-20deg);
}
.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:after {
  border-right: 7.5px solid transparent;
  transform: translate(7.5px, -28px) skewY(20deg);
}
@keyframes mapboxgl-user-location-dot-pulse {
  0% {
    opacity: 1;
    transform: scale(1);
  }
  70% {
    opacity: 0;
    transform: scale(3);
  }
  to {
    opacity: 0;
    transform: scale(1);
  }
}
.mapboxgl-user-location-dot-stale {
  background-color: #aaa;
}
.mapboxgl-user-location-dot-stale:after {
  display: none;
}
.mapboxgl-user-location-accuracy-circle {
  background-color: #1da1f233;
  border-radius: 100%;
  height: 1px;
  width: 1px;
}
.mapboxgl-crosshair,
.mapboxgl-crosshair .mapboxgl-interactive,
.mapboxgl-crosshair .mapboxgl-interactive:active {
  cursor: crosshair;
}
.mapboxgl-boxzoom {
  background: #fff;
  border: 2px dotted #202020;
  height: 0;
  left: 0;
  opacity: .5;
  position: absolute;
  top: 0;
  width: 0;
}
@media print {
  .mapbox-improve-map {
    display: none;
  }
}
.mapboxgl-scroll-zoom-blocker,
.mapboxgl-touch-pan-blocker {
  align-items: center;
  background: rgba(0, 0, 0, .7);
  color: #fff;
  display: flex;
  font-family:
    -apple-system,
    BlinkMacSystemFont,
    Segoe UI,
    Helvetica,
    Arial,
    sans-serif;
  height: 100%;
  justify-content: center;
  left: 0;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  text-align: center;
  top: 0;
  transition: opacity .75s ease-in-out;
  transition-delay: 1s;
  width: 100%;
}
.mapboxgl-scroll-zoom-blocker-show,
.mapboxgl-touch-pan-blocker-show {
  opacity: 1;
  transition: opacity .1s ease-in-out;
}
.mapboxgl-canvas-container.mapboxgl-touch-pan-blocker-override.mapboxgl-scrollable-page,
.mapboxgl-canvas-container.mapboxgl-touch-pan-blocker-override.mapboxgl-scrollable-page .mapboxgl-canvas {
  touch-action: pan-x pan-y;
}
</style>
</head>
<body>
  <div id="homeflow-root" data-homeflow-config="__HOMEFLOW_CONFIG_JSON__"></div>
  <script type="module">
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function noop() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          oldElement.props,
          oldElement._owner,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ioInfo = payload._ioInfo;
          null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
          ioInfo = payload._result;
          var thenable = ioInfo();
          thenable.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status) {
                payload._status = 1;
                payload._result = moduleObject;
                var _ioInfo = payload._ioInfo;
                null != _ioInfo && (_ioInfo.end = performance.now());
                void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
              }
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status) {
                payload._status = 2;
                payload._result = error;
                var _ioInfo2 = payload._ioInfo;
                null != _ioInfo2 && (_ioInfo2.end = performance.now());
                void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            }
          );
          ioInfo = payload._ioInfo;
          if (null != ioInfo) {
            ioInfo.value = thenable;
            var displayName = thenable.displayName;
            "string" === typeof displayName && (ioInfo.name = displayName);
          }
          -1 === payload._status && (payload._status = 0, payload._result = thenable);
        }
        if (1 === payload._status)
          return ioInfo = payload._result, void 0 === ioInfo && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ioInfo
          ), "default" in ioInfo || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ioInfo
          ), ioInfo.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function releaseAsyncTransition() {
        ReactSharedInternals.asyncTransitions--;
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(
              module,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      };
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        asyncTransitions: 0,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
        deprecatedAPIs,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      var fnName = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = fnName;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          props,
          owner,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          validateChildKeys(arguments[key]);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        for (var i = 2; i < arguments.length; i++)
          validateChildKeys(arguments[i]);
        i = {};
        var key = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        key && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          key,
          i,
          getOwner(),
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        ctor = { _status: -1, _result: ctor };
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: ctor,
          _init: lazyInitializer
        }, ioInfo = {
          name: "lazy",
          start: -1,
          end: -1,
          value: null,
          owner: null,
          debugStack: Error("react-stack-top-frame"),
          debugTask: console.createTask ? console.createTask("lazy()") : null
        };
        ctor._ioInfo = ioInfo;
        lazyType._debugInfo = [{ awaited: ioInfo }];
        return lazyType;
      };
      exports.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
            "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
          ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useEffect(create, deps);
      };
      exports.useEffectEvent = function(callback) {
        return resolveDispatcher().useEffectEvent(callback);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.2.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    (function() {
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
          }
      }
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      if ("function" === typeof localSetImmediate)
        var schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    (function() {
      function noop() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container2, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports.version = "19.2.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-client.development.js
var require_react_dom_client_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
    "use strict";
    (function() {
      function findHook(fiber, id) {
        for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
          fiber = fiber.next, id--;
        return fiber;
      }
      function copyWithSetImpl(obj, path, index, value) {
        if (index >= path.length) return value;
        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
        return updated;
      }
      function copyWithRename(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length)
          console.warn("copyWithRename() expects paths of the same length");
        else {
          for (var i = 0; i < newPath.length - 1; i++)
            if (oldPath[i] !== newPath[i]) {
              console.warn(
                "copyWithRename() expects paths to be the same except for the deepest key"
              );
              return;
            }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        }
      }
      function copyWithRenameImpl(obj, oldPath, newPath, index) {
        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
          obj[oldKey],
          oldPath,
          newPath,
          index + 1
        );
        return updated;
      }
      function copyWithDeleteImpl(obj, path, index) {
        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        if (index + 1 === path.length)
          return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
        return updated;
      }
      function shouldSuspendImpl() {
        return false;
      }
      function shouldErrorImpl() {
        return null;
      }
      function warnInvalidHookAccess() {
        console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
      }
      function warnInvalidContextAccess() {
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      }
      function noop() {
      }
      function warnForMissingKey() {
      }
      function setToSortedString(set) {
        var array = [];
        set.forEach(function(value) {
          array.push(value);
        });
        return array.sort().join(", ");
      }
      function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function scheduleRoot(root2, element) {
        root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
      }
      function scheduleRefresh(root2, update) {
        if (null !== resolveFamily) {
          var staleFamilies = update.staleFamilies;
          update = update.updatedFamilies;
          flushPendingEffects();
          scheduleFibersWithFamiliesRecursively(
            root2.current,
            update,
            staleFamilies
          );
          flushSyncWork$1();
        }
      }
      function setRefreshHandler(handler) {
        resolveFamily = handler;
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState) return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error("Unable to find node on an unmounted component.");
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate)
            throw Error("Unable to find node on an unmounted component.");
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, _child = parentA.child; _child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              for (_child = parentB.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild)
                throw Error(
                  "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                );
            }
          }
          if (a.alternate !== b)
            throw Error(
              "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
            );
        }
        if (3 !== a.tag)
          throw Error("Unable to find node on an unmounted component.");
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function getComponentNameFromOwner(owner) {
        return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
      }
      function getComponentNameFromFiber(fiber) {
        var type = fiber.type;
        switch (fiber.tag) {
          case 31:
            return "Activity";
          case 24:
            return "Cache";
          case 9:
            return (type._context.displayName || "Context") + ".Consumer";
          case 10:
            return type.displayName || "Context";
          case 18:
            return "DehydratedFragment";
          case 11:
            return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 26:
          case 27:
          case 5:
            return type;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return getComponentNameFromType(type);
          case 8:
            return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 14:
          case 15:
            if ("function" === typeof type)
              return type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            break;
          case 29:
            type = fiber._debugInfo;
            if (null != type) {
              for (var i = type.length - 1; 0 <= i; i--)
                if ("string" === typeof type[i].name) return type[i].name;
            }
            if (null !== fiber.return)
              return getComponentNameFromFiber(fiber.return);
        }
        return null;
      }
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor, fiber) {
        0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
      }
      function push(cursor, value, fiber) {
        index$jscomp$0++;
        valueStack[index$jscomp$0] = cursor.current;
        fiberStack[index$jscomp$0] = fiber;
        cursor.current = value;
      }
      function requiredContext(c) {
        null === c && console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        );
        return c;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, null, fiber);
        var nextRootContext = nextRootInstance.nodeType;
        switch (nextRootContext) {
          case 9:
          case 11:
            nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
            nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
            break;
          default:
            if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                nextRootInstance,
                nextRootContext
              );
            else
              switch (nextRootContext) {
                case "svg":
                  nextRootInstance = HostContextNamespaceSvg;
                  break;
                case "math":
                  nextRootInstance = HostContextNamespaceMath;
                  break;
                default:
                  nextRootInstance = HostContextNamespaceNone;
              }
        }
        nextRootContext = nextRootContext.toLowerCase();
        nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
        nextRootContext = {
          context: nextRootInstance,
          ancestorInfo: nextRootContext
        };
        pop(contextStackCursor, fiber);
        push(contextStackCursor, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        return requiredContext(contextStackCursor.current);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
        var context = requiredContext(contextStackCursor.current);
        var type = fiber.type;
        var nextContext = getChildHostContextProd(context.context, type);
        type = updatedAncestorInfoDev(context.ancestorInfo, type);
        nextContext = { context: nextContext, ancestorInfo: type };
        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do {
            info += describeFiber(workInProgress2, previous);
            var debugInfo = workInProgress2._debugInfo;
            if (debugInfo)
              for (var i = debugInfo.length - 1; 0 <= i; i--) {
                var entry = debugInfo[i];
                if ("string" === typeof entry.name) {
                  var JSCompiler_temp_const = info;
                  a: {
                    var name = entry.name, env = entry.env, location = entry.debugLocation;
                    if (null != location) {
                      var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                      if (-1 !== lastLine.indexOf(name)) {
                        var JSCompiler_inline_result = "\n" + lastLine;
                        break a;
                      }
                    }
                    JSCompiler_inline_result = describeBuiltInComponentFrame(
                      name + (env ? " [" + env + "]" : "")
                    );
                  }
                  info = JSCompiler_temp_const + JSCompiler_inline_result;
                }
              }
            previous = workInProgress2;
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function describeFunctionComponentFrameWithoutLineNumber(fn) {
        return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
      }
      function getCurrentFiberOwnerNameInDevOrNull() {
        if (null === current) return null;
        var owner = current._debugOwner;
        return null != owner ? getComponentNameFromOwner(owner) : null;
      }
      function getCurrentFiberStackInDev() {
        if (null === current) return "";
        var workInProgress2 = current;
        try {
          var info = "";
          6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
          switch (workInProgress2.tag) {
            case 26:
            case 27:
            case 5:
              info += describeBuiltInComponentFrame(workInProgress2.type);
              break;
            case 13:
              info += describeBuiltInComponentFrame("Suspense");
              break;
            case 19:
              info += describeBuiltInComponentFrame("SuspenseList");
              break;
            case 31:
              info += describeBuiltInComponentFrame("Activity");
              break;
            case 30:
            case 0:
            case 15:
            case 1:
              workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress2.type
              ));
              break;
            case 11:
              workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress2.type.render
              ));
          }
          for (; workInProgress2; )
            if ("number" === typeof workInProgress2.tag) {
              var fiber = workInProgress2;
              workInProgress2 = fiber._debugOwner;
              var debugStack = fiber._debugStack;
              if (workInProgress2 && debugStack) {
                var formattedStack = formatOwnerStack(debugStack);
                "" !== formattedStack && (info += "\n" + formattedStack);
              }
            } else if (null != workInProgress2.debugStack) {
              var ownerStack = workInProgress2.debugStack;
              (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
            } else break;
          var JSCompiler_inline_result = info;
        } catch (x) {
          JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result;
      }
      function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
        var previousFiber = current;
        setCurrentFiber(fiber);
        try {
          return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
            callback.bind(null, arg0, arg1, arg2, arg3, arg4)
          ) : callback(arg0, arg1, arg2, arg3, arg4);
        } finally {
          setCurrentFiber(previousFiber);
        }
        throw Error(
          "runWithFiberInDEV should never be called in production. This is a bug in React."
        );
      }
      function setCurrentFiber(fiber) {
        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
        isRendering = false;
        current = fiber;
      }
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e) {
          return true;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkFormFieldValueStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      function injectInternals(internals) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) return true;
        if (!hook.supportsFiber)
          return console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ), true;
        try {
          rendererID = hook.inject(internals), injectedHook = hook;
        } catch (err) {
          console.error("React instrumentation encountered an error: %o.", err);
        }
        return hook.checkDCE ? true : false;
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
          }
      }
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index = 31 - clz32(remainingLanes), lane = 1 << index;
          entanglements[index] = 0;
          expirationTimes[index] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
              var update = hiddenUpdatesForLane[index];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
          lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function addFiberToLanesMap(root2, fiber, lanes) {
        if (isDevToolsPresent)
          for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            root2[index].add(fiber);
            lanes &= ~lane;
          }
      }
      function movePendingFibersToMemoized(root2, lanes) {
        if (isDevToolsPresent)
          for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
            var index = 31 - clz32(lanes);
            root2 = 1 << index;
            index = pendingUpdatersLaneMap[index];
            0 < index.size && (index.forEach(function(fiber) {
              var alternate = fiber.alternate;
              null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
            }), index.clear());
            lanes &= ~root2;
          }
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey])
                  return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
          return inst.stateNode;
        throw Error("getNodeFromInstance: Invalid argument.");
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] && console.error(
          "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
          registrationName
        );
        registrationNameDependencies[registrationName] = dependencies;
        var lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames[lowerCasedName] = registrationName;
        "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      function getValueForAttributeOnCustomComponent(node, name, expected) {
        if (isAttributeNameSafe(name)) {
          if (!node.hasAttribute(name)) {
            switch (typeof expected) {
              case "symbol":
              case "object":
                return expected;
              case "function":
                return expected;
              case "boolean":
                if (false === expected) return expected;
            }
            return void 0 === expected ? void 0 : null;
          }
          node = node.getAttribute(name);
          if ("" === node && true === expected) return true;
          checkAttributeStringCoercion(expected, name);
          return node === "" + expected ? expected : node;
        }
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix2 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix2 && "aria-" !== prefix2) {
                  node.removeAttribute(name);
                  return;
                }
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          checkAttributeStringCoercion(value, name);
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return checkFormFieldValueStringCoercion(value), value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              checkFormFieldValueStringCoercion(value);
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              checkFormFieldValueStringCoercion(value);
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function validateInputProps(element, props) {
        void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
          "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ), didWarnCheckedDefaultChecked = true);
        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
          "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ), didWarnValueDefaultValue$1 = true);
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function validateOptionProps(element, props) {
        null == props.value && ("object" === typeof props.children && null !== props.children ? React3.Children.forEach(props.children, function(child) {
          null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          ));
        }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
          "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
        )));
        null == props.selected || didWarnSelectedSetOnOption || (console.error(
          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
        ), didWarnSelectedSetOnOption = true);
      }
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function validateSelectProps(element, props) {
        for (element = 0; element < valuePropNames.length; element++) {
          var propName = valuePropNames[element];
          if (null != props[propName]) {
            var propNameIsArray = isArrayImpl(props[propName]);
            props.multiple && !propNameIsArray ? console.error(
              "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
              propName,
              getDeclarationErrorAddendum()
            ) : !props.multiple && propNameIsArray && console.error(
              "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
              propName,
              getDeclarationErrorAddendum()
            );
          }
        }
        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
          "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
        ), didWarnValueDefaultValue = true);
      }
      function validateTextareaProps(element, props) {
        void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
          "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component"
        ), didWarnValDefaultVal = true);
        null != props.children && null == props.value && console.error(
          "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
        );
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue)
              throw Error(
                "If you supply `defaultValue` on a <textarea>, do not pass children."
              );
            if (isArrayImpl(children)) {
              if (1 < children.length)
                throw Error("<textarea> can only have at most one child.");
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
        track(element);
      }
      function findNotableNode(node, indent) {
        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
      }
      function indentation(indent) {
        return "  " + "  ".repeat(indent);
      }
      function added(indent) {
        return "+ " + "  ".repeat(indent);
      }
      function removed(indent) {
        return "- " + "  ".repeat(indent);
      }
      function describeFiberType(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return fiber.type;
          case 16:
            return "Lazy";
          case 31:
            return "Activity";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 0:
          case 15:
            return fiber = fiber.type, fiber.displayName || fiber.name || null;
          case 11:
            return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
          case 1:
            return fiber = fiber.type, fiber.displayName || fiber.name || null;
          default:
            return null;
        }
      }
      function describeTextNode(content, maxLength) {
        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
      }
      function describeTextDiff(clientText, serverProps, indent) {
        var maxLength = 120 - 2 * indent;
        if (null === serverProps)
          return added(indent) + describeTextNode(clientText, maxLength) + "\n";
        if ("string" === typeof serverProps) {
          for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
          firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
          return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
        }
        return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
      }
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      function describeValue(value, maxLength) {
        switch (typeof value) {
          case "string":
            return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
          case "object":
            if (null === value) return "null";
            if (isArrayImpl(value)) return "[...]";
            if (value.$$typeof === REACT_ELEMENT_TYPE)
              return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
            var name = objectName(value);
            if ("Object" === name) {
              name = "";
              maxLength -= 2;
              for (var propName in value)
                if (value.hasOwnProperty(propName)) {
                  var jsonPropName = JSON.stringify(propName);
                  jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                  maxLength -= propName.length - 2;
                  jsonPropName = describeValue(
                    value[propName],
                    15 > maxLength ? maxLength : 15
                  );
                  maxLength -= jsonPropName.length;
                  if (0 > maxLength) {
                    name += "" === name ? "..." : ", ...";
                    break;
                  }
                  name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                }
              return "{" + name + "}";
            }
            return name;
          case "function":
            return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
          default:
            return String(value);
        }
      }
      function describePropValue(value, maxLength) {
        return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
      }
      function describeExpandedElement(type, props, rowPrefix) {
        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
        for (propName in props)
          if (props.hasOwnProperty(propName) && "children" !== propName) {
            var propValue = describePropValue(
              props[propName],
              120 - rowPrefix.length - propName.length - 1
            );
            remainingRowLength -= propName.length + propValue.length + 2;
            properties.push(propName + "=" + propValue);
          }
        return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
      }
      function describePropertiesDiff(clientObject, serverObject, indent) {
        var properties = "", remainingServerProperties = assign({}, serverObject), propName;
        for (propName in clientObject)
          if (clientObject.hasOwnProperty(propName)) {
            delete remainingServerProperties[propName];
            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
          }
        for (var _propName in remainingServerProperties)
          remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
            remainingServerProperties[_propName],
            120 - 2 * indent - _propName.length - 2
          ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
        return properties;
      }
      function describeElementDiff(type, clientProps, serverProps, indent) {
        var content = "", serverPropNames = /* @__PURE__ */ new Map();
        for (propName$jscomp$0 in serverProps)
          serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
            propName$jscomp$0.toLowerCase(),
            propName$jscomp$0
          );
        if (1 === serverPropNames.size && serverPropNames.has("children"))
          content += describeExpandedElement(
            type,
            clientProps,
            indentation(indent)
          );
        else {
          for (var _propName2 in clientProps)
            if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
              var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
              if (void 0 !== serverPropName) {
                serverPropNames.delete(_propName2.toLowerCase());
                var propName$jscomp$0 = clientProps[_propName2];
                serverPropName = serverProps[serverPropName];
                var clientPropValue = describePropValue(
                  propName$jscomp$0,
                  maxLength$jscomp$0
                );
                maxLength$jscomp$0 = describePropValue(
                  serverPropName,
                  maxLength$jscomp$0
                );
                "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                  propName$jscomp$0,
                  serverPropName,
                  indent + 2
                ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
              } else
                content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
            }
          serverPropNames.forEach(function(propName) {
            if ("children" !== propName) {
              var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
              content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
            }
          });
          content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
        }
        type = serverProps.children;
        clientProps = clientProps.children;
        if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
          serverPropNames = "";
          if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            serverPropNames = "" + clientProps;
          content += describeTextDiff(serverPropNames, "" + type, indent + 1);
        } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
          content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
        return content;
      }
      function describeSiblingFiber(fiber, indent) {
        var type = describeFiberType(fiber);
        if (null === type) {
          type = "";
          for (fiber = fiber.child; fiber; )
            type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
          return type;
        }
        return indentation(indent) + "<" + type + ">\n";
      }
      function describeNode(node, indent) {
        var skipToNode = findNotableNode(node, indent);
        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
          return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
        skipToNode = "";
        var debugInfo = node.fiber._debugInfo;
        if (debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var serverComponentName = debugInfo[i].name;
            "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
          }
        debugInfo = "";
        i = node.fiber.pendingProps;
        if (6 === node.fiber.tag)
          debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
          if (void 0 === node.serverProps) {
            debugInfo = indent;
            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
            for (propName in i)
              if (i.hasOwnProperty(propName) && "children" !== propName) {
                var propValue = describePropValue(i[propName], 15);
                maxLength -= propName.length + propValue.length + 2;
                if (0 > maxLength) {
                  content += " ...";
                  break;
                }
                content += " " + propName + "=" + propValue;
              }
            debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
            indent++;
          } else
            null === node.serverProps ? (debugInfo = describeExpandedElement(
              serverComponentName,
              i,
              added(indent)
            ), indent++) : "string" === typeof node.serverProps ? console.error(
              "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
            ) : (debugInfo = describeElementDiff(
              serverComponentName,
              i,
              node.serverProps,
              indent
            ), indent++);
        var propName = "";
        i = node.fiber.child;
        for (serverComponentName = 0; i && serverComponentName < node.children.length; )
          maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
        i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
        i = node.serverTail;
        null === node.serverProps && indent--;
        for (node = 0; node < i.length; node++)
          serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
            serverComponentName.type,
            serverComponentName.props,
            removed(indent)
          );
        return skipToNode + debugInfo + propName;
      }
      function describeDiff(rootNode) {
        try {
          return "\n\n" + describeNode(rootNode, 0);
        } catch (x) {
          return "";
        }
      }
      function describeAncestors(ancestor, child, props) {
        for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
          fiber === ancestor && (distanceFromLeaf = 0), node = {
            fiber,
            children: null !== node ? [node] : [],
            serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
            serverTail: [],
            distanceFromLeaf
          }, distanceFromLeaf++, fiber = fiber.return;
        return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
      }
      function updatedAncestorInfoDev(oldInfo, tag) {
        var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
        -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
        -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
        -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
        ancestorInfo.current = info;
        "form" === tag && (ancestorInfo.formTag = info);
        "a" === tag && (ancestorInfo.aTagInScope = info);
        "button" === tag && (ancestorInfo.buttonTagInScope = info);
        "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
        "p" === tag && (ancestorInfo.pTagInButtonScope = info);
        "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
        if ("dd" === tag || "dt" === tag)
          ancestorInfo.dlItemTagAutoclosing = info;
        "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
        null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
        return ancestorInfo;
      }
      function isTagValidWithParent(tag, parentTag, implicitRootScope) {
        switch (parentTag) {
          case "select":
            return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
          case "optgroup":
            return "option" === tag || "#text" === tag;
          case "option":
            return "#text" === tag;
          case "tr":
            return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
          case "tbody":
          case "thead":
          case "tfoot":
            return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
          case "colgroup":
            return "col" === tag || "template" === tag;
          case "table":
            return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
          case "head":
            return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
          case "html":
            if (implicitRootScope) break;
            return "head" === tag || "body" === tag || "frameset" === tag;
          case "frameset":
            return "frame" === tag;
          case "#document":
            if (!implicitRootScope) return "html" === tag;
        }
        switch (tag) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
          case "rp":
          case "rt":
            return -1 === impliedEndTags.indexOf(parentTag);
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return null == parentTag;
          case "head":
            return implicitRootScope || null === parentTag;
          case "html":
            return implicitRootScope && "#document" === parentTag || null === parentTag;
          case "body":
            return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
        }
        return true;
      }
      function findInvalidAncestorForTag(tag, ancestorInfo) {
        switch (tag) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ancestorInfo.pTagInButtonScope;
          case "form":
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case "li":
            return ancestorInfo.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ancestorInfo.dlItemTagAutoclosing;
          case "button":
            return ancestorInfo.buttonTagInScope;
          case "a":
            return ancestorInfo.aTagInScope;
          case "nobr":
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      }
      function findAncestor(parent, tagName) {
        for (; parent; ) {
          switch (parent.tag) {
            case 5:
            case 26:
            case 27:
              if (parent.type === tagName) return parent;
          }
          parent = parent.return;
        }
        return null;
      }
      function validateDOMNesting(childTag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
        var parentInfo = ancestorInfo.current;
        ancestorInfo = (parentInfo = isTagValidWithParent(
          childTag,
          parentInfo && parentInfo.tag,
          ancestorInfo.implicitRootScope
        ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        ancestorInfo = parentInfo || ancestorInfo;
        if (!ancestorInfo) return true;
        var ancestorTag = ancestorInfo.tag;
        ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
        if (didWarn[ancestorInfo]) return false;
        didWarn[ancestorInfo] = true;
        var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
        parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
          "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
          tagDisplayName,
          ancestorTag,
          parentInfo,
          ancestorDescription
        )) : console.error(
          "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
          tagDisplayName,
          ancestorTag,
          ancestorDescription
        );
        ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
          console.error(
            "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
            ancestorTag,
            tagDisplayName
          );
        }));
        return false;
      }
      function validateTextNesting(childText, parentTag, implicitRootScope) {
        if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
          return true;
        implicitRootScope = "#text|" + parentTag;
        if (didWarn[implicitRootScope]) return false;
        didWarn[implicitRootScope] = true;
        var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
        implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
          ancestor,
          implicitRootScope,
          6 !== implicitRootScope.tag ? { children: null } : null
        ) : "";
        /\S/.test(childText) ? console.error(
          "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
          parentTag,
          implicitRootScope
        ) : console.error(
          "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
          parentTag,
          implicitRootScope
        );
        return false;
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
          return character.toUpperCase();
        });
      }
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
          "Unsupported style property %s. Did you mean %s?",
          styleName,
          camelize(styleName.replace(msPattern, "ms-"))
        )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
          "Unsupported vendor-prefixed style property %s. Did you mean %s?",
          styleName,
          styleName.charAt(0).toUpperCase() + styleName.slice(1)
        )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
          `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
          styleName,
          value.replace(badStyleValueWithSemicolonPattern, "")
        )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
          "`NaN` is an invalid value for the `%s` css style property.",
          styleName
        )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
          "`Infinity` is an invalid value for the `%s` css style property.",
          styleName
        ))));
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        styles && Object.freeze(styles);
        node = node.style;
        if (null != prevStyles) {
          if (styles) {
            var expandedUpdates = {};
            if (prevStyles) {
              for (var key in prevStyles)
                if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                  for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                    expandedUpdates[longhands[i]] = key;
            }
            for (var _key in styles)
              if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                  expandedUpdates[key[longhands]] = _key;
            _key = {};
            for (var key$jscomp$0 in styles)
              for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                _key[key[longhands]] = key$jscomp$0;
            key$jscomp$0 = {};
            for (var _key2 in expandedUpdates)
              if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                key$jscomp$0[i] = true;
                i = console;
                var value = styles[key];
                i.error.call(
                  i,
                  "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                  null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                  key,
                  longhands
                );
              }
          }
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var _styleName in styles)
            _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
        } else
          for (expandedUpdates in styles)
            styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      function getAttributeAlias(name) {
        return aliases.get(name) || name;
      }
      function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
          return true;
        if (rARIACamel$1.test(name)) {
          tagName = "aria-" + name.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ), warnedProperties$1[name] = true;
          if (name !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true;
        }
        if (rARIA$1.test(name)) {
          tagName = name.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName) return warnedProperties$1[name] = true, false;
          name !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ), warnedProperties$1[name] = true);
        }
        return true;
      }
      function validateProperties$2(type, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        );
      }
      function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
          return true;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ), warnedProperties[name] = true;
          if (EVENT_NAME_REGEX.test(name))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ), warnedProperties[name] = true;
        } else if (EVENT_NAME_REGEX.test(name))
          return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name
          ), warnedProperties[name] = true;
        if (rARIA.test(name) || rARIACamel.test(name)) return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ), warnedProperties[name] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
        } else if (name !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ), warnedProperties[name] = true;
        switch (name) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name,
                  name,
                  value,
                  name
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name,
                  name,
                  value,
                  name,
                  name,
                  name
                );
                return warnedProperties[name] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name,
                value
              );
              warnedProperties[name] = true;
            }
        }
        return true;
      }
      function warnUnknownProperties(type, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        );
      }
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$1() {
      }
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                checkAttributeStringCoercion(internalInstance, "name");
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps)
                      throw Error(
                        "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                      );
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
          );
        return stateNode;
      }
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (nativeEvent.which !== SPACEBAR_CODE) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which)
                return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM2) return false;
        eventNameSuffix = "on" + eventNameSuffix;
        var isSupported = eventNameSuffix in document;
        isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
        return isSupported;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      function getArrayKind(array) {
        for (var kind = EMPTY_ARRAY, i = 0; i < array.length; i++) {
          var value = array[i];
          if ("object" === typeof value && null !== value)
            if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
              if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                return COMPLEX_ARRAY;
              kind = ENTRIES_ARRAY;
            } else return COMPLEX_ARRAY;
          else {
            if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
              return COMPLEX_ARRAY;
            kind = PRIMITIVE_ARRAY;
          }
        }
        return kind;
      }
      function addObjectToProperties(object, properties, indent, prefix2) {
        for (var key in object)
          hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
      }
      function addValueToProperties(propertyName, value, properties, indent, prefix2) {
        switch (typeof value) {
          case "object":
            if (null === value) {
              value = "null";
              break;
            } else {
              if (value.$$typeof === REACT_ELEMENT_TYPE) {
                var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                value = value.props;
                var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                if (null == key && 0 === propsLength) {
                  value = "<" + typeName2 + " />";
                  break;
                }
                if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                  value = "<" + typeName2 + " \u2026 />";
                  break;
                }
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "<" + typeName2
                ]);
                null !== key && addValueToProperties(
                  "key",
                  key,
                  properties,
                  indent + 1,
                  prefix2
                );
                propertyName = false;
                for (var propKey in value)
                  "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                    propKey,
                    value[propKey],
                    properties,
                    indent + 1,
                    prefix2
                  );
                properties.push([
                  "",
                  propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                ]);
                return;
              }
              typeName2 = Object.prototype.toString.call(value);
              typeName2 = typeName2.slice(8, typeName2.length - 1);
              if ("Array" === typeName2) {
                if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                  value = JSON.stringify(value);
                  break;
                } else if (propKey === ENTRIES_ARRAY) {
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    ""
                  ]);
                  for (propertyName = 0; propertyName < value.length; propertyName++)
                    typeName2 = value[propertyName], addValueToProperties(
                      typeName2[0],
                      typeName2[1],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  return;
                }
              }
              if ("Promise" === typeName2) {
                if ("fulfilled" === value.status) {
                  if (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.value,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2) {
                    properties = properties[typeName2];
                    properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                    return;
                  }
                } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                  propertyName,
                  value.reason,
                  properties,
                  indent,
                  prefix2
                ), properties.length > typeName2)) {
                  properties = properties[typeName2];
                  properties[1] = "Rejected Promise<" + properties[1] + ">";
                  return;
                }
                properties.push([
                  "\xA0\xA0".repeat(indent) + propertyName,
                  "Promise"
                ]);
                return;
              }
              "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
              properties.push([
                prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
              ]);
              3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
              return;
            }
          case "function":
            value = "" === value.name ? "() => {}" : value.name + "() {}";
            break;
          case "string":
            value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
            break;
          case "undefined":
            value = "undefined";
            break;
          case "boolean":
            value = value ? "true" : "false";
            break;
          default:
            value = String(value);
        }
        properties.push([
          prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
          value
        ]);
      }
      function addObjectDiffToProperties(prev, next, properties, indent) {
        var isDeeplyEqual = true;
        for (key in prev)
          key in next || (properties.push([
            REMOVED + "\xA0\xA0".repeat(indent) + key,
            "\u2026"
          ]), isDeeplyEqual = false);
        for (var _key in next)
          if (_key in prev) {
            var key = prev[_key];
            var nextValue = next[_key];
            if (key !== nextValue) {
              if (0 === indent && "children" === _key)
                isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                  [REMOVED + isDeeplyEqual, "\u2026"],
                  [ADDED + isDeeplyEqual, "\u2026"]
                );
              else {
                if (!(3 <= indent)) {
                  if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                    if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                      if (key.type === nextValue.type && key.key === nextValue.key) {
                        key = getComponentNameFromType(nextValue.type) || "\u2026";
                        isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                        key = "<" + key + " \u2026 />";
                        properties.push(
                          [REMOVED + isDeeplyEqual, key],
                          [ADDED + isDeeplyEqual, key]
                        );
                        isDeeplyEqual = false;
                        continue;
                      }
                    } else {
                      var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                      if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                        prevKind = [
                          UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                          "[object Array]" === nextKind ? "Array" : ""
                        ];
                        properties.push(prevKind);
                        nextKind = properties.length;
                        addObjectDiffToProperties(
                          key,
                          nextValue,
                          properties,
                          indent + 1
                        ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                        continue;
                      }
                    }
                  else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                    key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                    properties.push([
                      UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                      key + " Referentially unequal function closure. Consider memoization."
                    ]);
                    continue;
                  }
                }
                addValueToProperties(_key, key, properties, indent, REMOVED);
                addValueToProperties(_key, nextValue, properties, indent, ADDED);
              }
              isDeeplyEqual = false;
            }
          } else
            properties.push([
              ADDED + "\xA0\xA0".repeat(indent) + _key,
              "\u2026"
            ]), isDeeplyEqual = false;
        return isDeeplyEqual;
      }
      function setCurrentTrackFromLanes(lanes) {
        currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
      }
      function logComponentTrigger(fiber, startTime, endTime, trigger) {
        supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
          performance.measure.bind(
            performance,
            trigger,
            reusableComponentOptions
          )
        ) : performance.measure(trigger, reusableComponentOptions));
      }
      function logComponentReappeared(fiber, startTime, endTime) {
        logComponentTrigger(fiber, startTime, endTime, "Reconnect");
      }
      function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
        var name = getComponentNameFromFiber(fiber);
        if (null !== name && supportsUserTiming) {
          var alternate = fiber.alternate, selfTime = fiber.actualDuration;
          if (null === alternate || alternate.child !== fiber.child)
            for (var child = fiber.child; null !== child; child = child.sibling)
              selfTime -= child.actualDuration;
          wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
          var props = fiber.memoizedProps;
          selfTime = fiber._debugTask;
          null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
            alternate.memoizedProps,
            props,
            child,
            0
          ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
            performance.measure.bind(
              performance,
              "\u200B" + name,
              reusableComponentOptions
            )
          ) : performance.measure(
            "\u200B" + name,
            reusableComponentOptions
          ))) : null != selfTime ? selfTime.run(
            console.timeStamp.bind(
              console,
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            )
          ) : console.timeStamp(
            name,
            startTime,
            endTime,
            COMPONENTS_TRACK,
            void 0,
            wasHydrated
          );
        }
      }
      function logComponentErrored(fiber, startTime, endTime, errors) {
        if (supportsUserTiming) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name) {
            for (var debugTask = null, properties = [], i = 0; i < errors.length; i++) {
              var capturedValue = errors[i];
              null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
              capturedValue = capturedValue.value;
              properties.push([
                "Error",
                "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
              ]);
            }
            null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
            null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
            null == debugTask && (debugTask = fiber._debugTask);
            fiber = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: COMPONENTS_TRACK,
                  tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "\u200B" + name, fiber)
            ) : performance.measure("\u200B" + name, fiber);
          }
        }
      }
      function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
        if (null !== errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              selfTime = [];
              for (var i = 0; i < errors.length; i++) {
                var error = errors[i].value;
                selfTime.push([
                  "Error",
                  "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
              startTime = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: "A lifecycle or effect errored",
                    properties: selfTime
                  }
                }
              };
              (fiber = fiber._debugTask) ? fiber.run(
                performance.measure.bind(
                  performance,
                  "\u200B" + name,
                  startTime
                )
              ) : performance.measure("\u200B" + name, startTime);
            }
          }
        } else
          name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
            console.timeStamp.bind(
              console,
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            )
          ) : console.timeStamp(
            name,
            startTime,
            endTime,
            COMPONENTS_TRACK,
            void 0,
            errors
          ));
      }
      function logRenderPhase(startTime, endTime, lanes, debugTask) {
        if (supportsUserTiming && !(endTime <= startTime)) {
          var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
          lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
          debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            )
          ) : console.timeStamp(
            lanes,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            color
          );
        }
      }
      function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
        !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
          console.timeStamp.bind(
            console,
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          )
        ) : console.timeStamp(
          "Prewarm",
          startTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          lanes
        ));
      }
      function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
        !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
          console.timeStamp.bind(
            console,
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          )
        ) : console.timeStamp(
          "Suspended",
          startTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          lanes
        ));
      }
      function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
        if (supportsUserTiming && !(endTime <= startTime)) {
          lanes = [];
          for (var i = 0; i < recoverableErrors.length; i++) {
            var error = recoverableErrors[i].value;
            lanes.push([
              "Recoverable Error",
              "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
            ]);
          }
          startTime = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "primary-dark",
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                properties: lanes
              }
            }
          };
          debugTask ? debugTask.run(
            performance.measure.bind(performance, "Recovered", startTime)
          ) : performance.measure("Recovered", startTime);
        }
      }
      function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
        !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
          console.timeStamp.bind(
            console,
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          )
        ) : console.timeStamp(
          "Errored",
          startTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          "error"
        ));
      }
      function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
        !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
          console.timeStamp.bind(
            console,
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          )
        ) : console.timeStamp(
          reason,
          startTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          "secondary-light"
        ));
      }
      function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
        if (supportsUserTiming && !(endTime <= startTime)) {
          for (var properties = [], i = 0; i < errors.length; i++) {
            var error = errors[i].value;
            properties.push([
              "Error",
              "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
            ]);
          }
          startTime = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "error",
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                properties
              }
            }
          };
          debugTask ? debugTask.run(
            performance.measure.bind(performance, "Errored", startTime)
          ) : performance.measure("Errored", startTime);
        }
      }
      function logAnimatingPhase(startTime, endTime, debugTask) {
        !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
          console.timeStamp.bind(
            console,
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          )
        ) : console.timeStamp(
          "Animating",
          startTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          "secondary-dark"
        ));
      }
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
          throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          );
        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        ));
        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        for (var node = sourceFiber, parent = node.return; null !== parent; )
          null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
        return 3 === node.tag ? node.stateNode : null;
      }
      function resolveFunctionForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? type : family.current;
      }
      function resolveForwardRefForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        if (null === resolveFamily) return false;
        var prevType = fiber.elementType;
        element = element.type;
        var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
        switch (fiber.tag) {
          case 1:
            "function" === typeof element && (needsCompareFamilies = true);
            break;
          case 0:
            "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          case 11:
            $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          case 14:
          case 15:
            $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          default:
            return false;
        }
        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
      }
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        do {
          var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
          _fiber = _fiber.type;
          var candidateType = null;
          switch (tag) {
            case 0:
            case 15:
            case 1:
              candidateType = _fiber;
              break;
            case 11:
              candidateType = _fiber.render;
          }
          if (null === resolveFamily)
            throw Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = false;
          _fiber = false;
          null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
          null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
          _fiber && (fiber._debugNeedsRemount = true);
          if (_fiber || needsRender)
            alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
          null === child || _fiber || scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
          if (null === sibling) break;
          fiber = sibling;
        } while (1);
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
        this.actualDuration = -0;
        this.actualStartTime = -1.1;
        this.treeBaseDuration = this.selfBaseDuration = -0;
        this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
        this._debugNeedsRemount = false;
        this._debugHookTypes = null;
        hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiber(
          current2.tag,
          pendingProps,
          current2.key,
          current2.mode
        ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
        workInProgress2.flags = current2.flags & 65011712;
        workInProgress2.childLanes = current2.childLanes;
        workInProgress2.lanes = current2.lanes;
        workInProgress2.child = current2.child;
        workInProgress2.memoizedProps = current2.memoizedProps;
        workInProgress2.memoizedState = current2.memoizedState;
        workInProgress2.updateQueue = current2.updateQueue;
        pendingProps = current2.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : {
          lanes: pendingProps.lanes,
          firstContext: pendingProps.firstContext,
          _debugThenableState: pendingProps._debugThenableState
        };
        workInProgress2.sibling = current2.sibling;
        workInProgress2.index = current2.index;
        workInProgress2.ref = current2.ref;
        workInProgress2.refCleanup = current2.refCleanup;
        workInProgress2.selfBaseDuration = current2.selfBaseDuration;
        workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        workInProgress2._debugInfo = current2._debugInfo;
        workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
        switch (workInProgress2.tag) {
          case 0:
          case 15:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case 1:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case 11:
            workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current2 = workInProgress2.alternate;
        null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext,
          _debugThenableState: renderLanes2._debugThenableState
        }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0, resolvedType = type;
        if ("function" === typeof type)
          shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
        else if ("string" === typeof type)
          fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(
                pendingProps.children,
                mode,
                lanes,
                key
              );
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= StrictLegacyMode;
              mode |= StrictEffectsMode;
              break;
            case REACT_PROFILER_TYPE:
              return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                typeof type.id
              ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            case REACT_SUSPENSE_TYPE:
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                }
              resolvedType = "";
              if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = Error(
                "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
              );
              resolvedType = null;
          }
        key = createFiber(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = resolvedType;
        key.lanes = lanes;
        key._debugOwner = owner;
        return key;
      }
      function createFiberFromElement(element, mode, lanes) {
        mode = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          element._owner,
          mode,
          lanes
        );
        mode._debugOwner = element._owner;
        mode._debugStack = element._debugStack;
        mode._debugTask = element._debugTask;
        return mode;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiber(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiber(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(18, null, null, NoMode);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiber(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function getSuspendedTreeContext() {
        warnIfNotHydrating();
        return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        isHydrating || console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
      }
      function buildHydrationDiffNode(fiber, distanceFromLeaf) {
        if (null === fiber.return) {
          if (null === hydrationDiffRootDEV)
            hydrationDiffRootDEV = {
              fiber,
              children: [],
              serverProps: void 0,
              serverTail: [],
              distanceFromLeaf
            };
          else {
            if (hydrationDiffRootDEV.fiber !== fiber)
              throw Error(
                "Saw multiple hydration diff roots in a pass. This is a bug in React."
              );
            hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
          }
          return hydrationDiffRootDEV;
        }
        var siblings = buildHydrationDiffNode(
          fiber.return,
          distanceFromLeaf + 1
        ).children;
        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
          return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
        distanceFromLeaf = {
          fiber,
          children: [],
          serverProps: void 0,
          serverTail: [],
          distanceFromLeaf
        };
        siblings.push(distanceFromLeaf);
        return distanceFromLeaf;
      }
      function warnIfHydrating() {
        isHydrating && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        );
      }
      function warnNonHydratedInstance(fiber, rejectedCandidate) {
        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
      }
      function throwOnHydrationMismatch(fiber) {
        var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
        queueHydrationError(
          createCapturedValueAtFiber(
            Error(
              "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
            ),
            fiber
          )
        );
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var didHydrate = fiber.stateNode;
        var type = fiber.type, props = fiber.memoizedProps;
        didHydrate[internalInstanceKey] = fiber;
        didHydrate[internalPropsKey] = props;
        validatePropertiesInDevelopment(type, props);
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", didHydrate);
            listenToNonDelegatedEvent("close", didHydrate);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", didHydrate);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
            break;
          case "source":
            listenToNonDelegatedEvent("error", didHydrate);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", didHydrate);
            listenToNonDelegatedEvent("load", didHydrate);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", didHydrate);
            break;
          case "input":
            checkControlledValueProps("input", props);
            listenToNonDelegatedEvent("invalid", didHydrate);
            validateInputProps(didHydrate, props);
            initInput(
              didHydrate,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "option":
            validateOptionProps(didHydrate, props);
            break;
          case "select":
            checkControlledValueProps("select", props);
            listenToNonDelegatedEvent("invalid", didHydrate);
            validateSelectProps(didHydrate, props);
            break;
          case "textarea":
            checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
              didHydrate,
              props.value,
              props.defaultValue,
              props.children
            );
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
        didHydrate || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating)
          return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        if (JSCompiler_temp && nextHydratableInstance) {
          for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
            var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
            diffNode.serverTail.push(description);
            JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
          }
          throwOnHydrationMismatch(fiber);
        }
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber)
            throw Error(
              "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
            );
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber)
            throw Error(
              "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
            );
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        didSuspendOrErrorDEV = isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      function emitPendingHydrationWarnings() {
        var diffRoot = hydrationDiffRootDEV;
        if (null !== diffRoot) {
          hydrationDiffRootDEV = null;
          for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
            diffRoot = diffRoot.children[0];
          runWithFiberInDEV(diffRoot.fiber, function() {
            console.error(
              "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
              "https://react.dev/link/hydration-mismatch",
              diff
            );
          });
        }
      }
      function resetContextDependencies() {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        isDisallowedContextReadInDEV = false;
      }
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue, providerFiber);
        context._currentValue = nextValue;
        push(rendererCursorDEV, context._currentRenderer, providerFiber);
        void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
        context._currentRenderer = rendererSigil;
      }
      function popProvider(context, providerFiber) {
        context._currentValue = valueCursor.current;
        var currentRenderer = rendererCursorDEV.current;
        pop(rendererCursorDEV, providerFiber);
        context._currentRenderer = currentRenderer;
        pop(valueCursor, providerFiber);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
        parent !== propagationRoot && console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber)
              throw Error(
                "We just came from a parent so we must have had a parent. This is a bug in React."
              );
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(
              nextFiber,
              renderLanes2,
              workInProgress2
            );
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current2 = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent)
              throw Error("Should have a current fiber. This is a bug in React.");
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent)
              throw Error("Should have a current fiber. This is a bug in React.");
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current2 && propagateContextChanges(
          workInProgress2,
          current2,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        isDisallowedContextReadInDEV && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer)
            throw Error(
              "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
            );
          lastContextDependency = context;
          consumer.dependencies = {
            lanes: 0,
            firstContext: context,
            _debugThenableState: null
          };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function retainCache(cache) {
        cache.controller.signal.aborted && console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        );
        cache.refCount++;
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 > cache.refCount && console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        );
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      function startUpdateTimerByLane(lane, method, fiber) {
        if (0 !== (lane & 127))
          0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
        else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
          lane = resolveEventTimeStamp();
          method = resolveEventType();
          if (lane !== transitionEventRepeatTime || method !== transitionEventType)
            transitionEventRepeatTime = -1.1;
          transitionEventTime = lane;
          transitionEventType = method;
        }
      }
      function startHostActionTimer(fiber) {
        if (0 > blockingUpdateTime) {
          blockingUpdateTime = now();
          blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
          (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
          var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
          newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
          blockingEventTime = newEventTime;
          blockingEventType = newEventType;
        }
        if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
          fiber = resolveEventTimeStamp();
          newEventTime = resolveEventType();
          if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
            transitionEventRepeatTime = -1.1;
          transitionEventTime = fiber;
          transitionEventType = newEventTime;
        }
      }
      function pushNestedEffectDurations() {
        var prevEffectDuration = profilerEffectDuration;
        profilerEffectDuration = 0;
        return prevEffectDuration;
      }
      function popNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration = prevEffectDuration;
        return elapsedTime;
      }
      function bubbleNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration += prevEffectDuration;
        return elapsedTime;
      }
      function resetComponentEffectTimers() {
        componentEffectEndTime = componentEffectStartTime = -1.1;
      }
      function pushComponentEffectStart() {
        var prevEffectStart = componentEffectStartTime;
        componentEffectStartTime = -1.1;
        return prevEffectStart;
      }
      function popComponentEffectStart(prevEffectStart) {
        0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
      }
      function pushComponentEffectDuration() {
        var prevEffectDuration = componentEffectDuration;
        componentEffectDuration = -0;
        return prevEffectDuration;
      }
      function popComponentEffectDuration(prevEffectDuration) {
        0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
      }
      function pushComponentEffectErrors() {
        var prevErrors = componentEffectErrors;
        componentEffectErrors = null;
        return prevErrors;
      }
      function pushComponentEffectDidSpawnUpdate() {
        var prev = componentEffectSpawnedUpdate;
        componentEffectSpawnedUpdate = false;
        return prev;
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now();
        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
      }
      function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
        if (0 <= profilerStartTime) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          fiber.selfBaseDuration = elapsedTime;
          profilerStartTime = -1;
        }
      }
      function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
        if (0 <= profilerStartTime) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          profilerStartTime = -1;
        }
      }
      function recordEffectDuration() {
        if (0 <= profilerStartTime) {
          var endTime = now(), elapsedTime = endTime - profilerStartTime;
          profilerStartTime = -1;
          profilerEffectDuration += elapsedTime;
          componentEffectDuration += elapsedTime;
          componentEffectEndTime = endTime;
        }
      }
      function recordEffectError(errorInfo) {
        null === componentEffectErrors && (componentEffectErrors = []);
        componentEffectErrors.push(errorInfo);
        null === commitErrors && (commitErrors = []);
        commitErrors.push(errorInfo);
      }
      function startEffectTimer() {
        profilerStartTime = now();
        0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
      }
      function transferActualDuration(fiber) {
        for (var child = fiber.child; child; )
          fiber.actualDuration += child.actualDuration, child = child.sibling;
      }
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      function createThenableState() {
        return { didWarnAboutUncachedPromise: false, thenables: [] };
      }
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index) {
        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
        var trackedThenables = thenableState2.thenables;
        index = trackedThenables[index];
        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
          "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
        )), thenable.then(noop$1, noop$1), thenable = index);
        if (void 0 === thenable._debugInfo) {
          thenableState2 = performance.now();
          trackedThenables = thenable.displayName;
          var ioInfo = {
            name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
            start: thenableState2,
            end: thenableState2,
            value: thenable
          };
          thenable._debugInfo = [{ awaited: ioInfo }];
          "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
            ioInfo.end = performance.now();
          }, thenable.then(thenableState2, thenableState2));
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status)
              thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(
                  "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                );
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            needsToResetSuspendedThenableDEV = true;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          return callLazyInitInDEV(lazyType);
        } catch (x) {
          if (null !== x && "object" === typeof x && "function" === typeof x.then)
            throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
          throw x;
        }
      }
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        needsToResetSuspendedThenableDEV = false;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(
            "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
          );
      }
      function pushDebugInfo(debugInfo) {
        var previousDebugInfo = currentDebugInfo;
        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
        return previousDebugInfo;
      }
      function getCurrentDebugTask() {
        var debugInfo = currentDebugInfo;
        if (null != debugInfo) {
          for (var i = debugInfo.length - 1; 0 <= i; i--)
            if (null != debugInfo[i].name) {
              var debugTask = debugInfo[i].debugTask;
              if (null != debugTask) return debugTask;
            }
        }
        return null;
      }
      function validateFragmentProps(element, fiber, returnFiber) {
        for (var keys2 = Object.keys(element.props), i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          if ("children" !== key && "key" !== key) {
            null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
            runWithFiberInDEV(
              fiber,
              function(erroredKey) {
                console.error(
                  "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                  erroredKey
                );
              },
              key
            );
            break;
          }
        }
      }
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = createThenableState());
        return trackUsedThenable(thenableState$1, thenable, index);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(
            'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
          );
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var debugTask = getCurrentDebugTask();
        null !== debugTask ? debugTask.run(
          throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
        ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
          "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
          invalidChild,
          invalidChild,
          invalidChild
        ) : console.error(
          "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
          invalidChild,
          invalidChild,
          parentName,
          invalidChild,
          parentName
        ));
      }
      function warnOnFunctionType(returnFiber, invalidChild) {
        var debugTask = getCurrentDebugTask();
        null !== debugTask ? debugTask.run(
          warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
        ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
      }
      function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
          "Symbols are not valid as a React child.\n  root.render(%s)",
          invalidChild
        ) : console.error(
          "Symbols are not valid as a React child.\n  <%s>%s</%s>",
          parentName,
          invalidChild,
          parentName
        ));
      }
      function warnOnSymbolType(returnFiber, invalidChild) {
        var debugTask = getCurrentDebugTask();
        null !== debugTask ? debugTask.run(
          warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
        ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (null === current2 || 6 !== current2.tag)
            return current2 = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes
            ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, textContent);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return current2 = updateFragment(
              returnFiber,
              current2,
              element.props.children,
              lanes,
              element.key
            ), validateFragmentProps(element, current2, returnFiber), current2;
          if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
            return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
          current2 = createFiberFromElement(element, returnFiber.mode, lanes);
          coerceRef(current2, element);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
            return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, portal.children || []);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updateFragment(returnFiber, current2, fragment, lanes, key) {
          if (null === current2 || 7 !== current2.tag)
            return current2 = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, fragment);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromElement(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
              case REACT_LAZY_TYPE:
                var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                newChild = resolveLazy(newChild);
                returnFiber = createChild(returnFiber, newChild, lanes);
                currentDebugInfo = _prevDebugInfo;
                return returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return lanes = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            if ("function" === typeof newChild.then)
              return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                returnFiber,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = _prevDebugInfo, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                ), currentDebugInfo = key, returnFiber) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                ), currentDebugInfo = key, returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
              if (null !== key) return null;
              key = pushDebugInfo(newChild._debugInfo);
              returnFiber = updateFragment(
                returnFiber,
                oldFiber,
                newChild,
                lanes,
                null
              );
              currentDebugInfo = key;
              return returnFiber;
            }
            if ("function" === typeof newChild.then)
              return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = key, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newIdx = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                ), currentDebugInfo = existingChildren, returnFiber;
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                newChild = resolveLazy(newChild);
                returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
                currentDebugInfo = _prevDebugInfo7;
                return returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                returnFiber,
                newIdx,
                newChild,
                lanes,
                null
              ), currentDebugInfo = existingChildren, returnFiber;
            if ("function" === typeof newChild.then)
              return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = _prevDebugInfo7, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
          if ("object" !== typeof child || null === child) return knownKeys;
          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(returnFiber, workInProgress2, child);
              var key = child.key;
              if ("string" !== typeof key) break;
              if (null === knownKeys) {
                knownKeys = /* @__PURE__ */ new Set();
                knownKeys.add(key);
                break;
              }
              if (!knownKeys.has(key)) {
                knownKeys.add(key);
                break;
              }
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                  key
                );
              });
              break;
            case REACT_LAZY_TYPE:
              child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            knownKeys = warnOnInvalidKey(
              returnFiber,
              newFiber,
              newChildren[newIdx],
              knownKeys
            );
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                knownKeys
              ), currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
              returnFiber,
              nextOldFiber,
              newChildren[newIdx],
              knownKeys
            ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren)
            throw Error("An iterable object provided no iterator.");
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            knownKeys = warnOnInvalidKey(
              returnFiber,
              newFiber,
              step.value,
              knownKeys
            );
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                oldFiber,
                step.value,
                knownKeys
              ), currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              step.value,
              lanes
            ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
              returnFiber,
              nextOldFiber,
              step.value,
              knownKeys
            ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          validateFragmentProps(newChild, lanes, returnFiber);
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                        currentFirstChild,
                        newChild
                      ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                }
                returnFiber = placeSingleChild(returnFiber);
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              case REACT_PORTAL_TYPE:
                a: {
                  prevDebugInfo = newChild;
                  for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === newChild)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          prevDebugInfo.children || []
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(
                    prevDebugInfo,
                    returnFiber.mode,
                    lanes
                  );
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
            }
            if (isArrayImpl(newChild))
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              ), currentDebugInfo = prevDebugInfo, returnFiber;
            if (getIteratorFn(newChild)) {
              prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              key = getIteratorFn(newChild);
              if ("function" !== typeof key)
                throw Error(
                  "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                );
              var newChildren = key.call(newChild);
              if (newChildren === newChild) {
                if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                newChild.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              returnFiber = reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChildren,
                lanes
              );
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            }
            if ("function" === typeof newChild.then)
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = prevDebugInfo, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
              returnFiber,
              currentFirstChild.sibling
            ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
              prevDebugInfo,
              returnFiber.mode,
              lanes
            ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          var prevDebugInfo = currentDebugInfo;
          currentDebugInfo = null;
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiber(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            var debugInfo = fiber._debugInfo = currentDebugInfo;
            fiber._debugOwner = returnFiber._debugOwner;
            fiber._debugTask = returnFiber._debugTask;
            if (null != debugInfo) {
              for (var i = debugInfo.length - 1; 0 <= i; i--)
                if ("string" === typeof debugInfo[i].stack) {
                  fiber._debugOwner = debugInfo[i];
                  fiber._debugTask = debugInfo[i].debugTask;
                  break;
                }
            }
            return fiber;
          } finally {
            currentDebugInfo = prevDebugInfo;
          }
        };
      }
      function validateSuspenseListNestedChild(childSlot, index) {
        var isAnArray = isArrayImpl(childSlot);
        childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
        return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
          "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
          isAnArray,
          index,
          isAnArray
        ), false) : true;
      }
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        current2 = current2.updateQueue;
        workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
          baseState: current2.baseState,
          firstBaseUpdate: current2.firstBaseUpdate,
          lastBaseUpdate: current2.lastBaseUpdate,
          shared: current2.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return {
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
          var componentName2 = getComponentNameFromFiber(fiber);
          console.error(
            "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
            componentName2
          );
          didWarnUpdateInsideUpdate = true;
        }
        if ((executionContext & RenderContext) !== NoContext)
          return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
        if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current2.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current2.shared,
            callbacks: current2.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = false;
        currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current2 = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current2 && (current2 = current2.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                updateLane = workInProgress2;
                var partialState = pendingQueue;
                var nextProps = props, instance = instance$jscomp$0;
                switch (partialState.tag) {
                  case ReplaceState:
                    partialState = partialState.payload;
                    if ("function" === typeof partialState) {
                      isDisallowedContextReadInDEV = true;
                      var nextState = partialState.call(
                        instance,
                        newState,
                        nextProps
                      );
                      if (updateLane.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                          partialState.call(instance, newState, nextProps);
                        } finally {
                          setIsStrictModeForDevtools(false);
                        }
                      }
                      isDisallowedContextReadInDEV = false;
                      newState = nextState;
                      break a;
                    }
                    newState = partialState;
                    break a;
                  case CaptureUpdate:
                    updateLane.flags = updateLane.flags & -65537 | 128;
                  case UpdateState:
                    nextState = partialState.payload;
                    if ("function" === typeof nextState) {
                      isDisallowedContextReadInDEV = true;
                      partialState = nextState.call(
                        instance,
                        newState,
                        nextProps
                      );
                      if (updateLane.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                          nextState.call(instance, newState, nextProps);
                        } finally {
                          setIsStrictModeForDevtools(false);
                        }
                      }
                      isDisallowedContextReadInDEV = false;
                    } else partialState = nextState;
                    if (null === partialState || void 0 === partialState) break a;
                    newState = assign({}, newState, partialState);
                    break a;
                  case ForceUpdate:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current2 && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current2;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress2.lanes = lastBaseUpdate;
          workInProgress2.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(
            "Invalid argument passed as callback. Expected a function. Instead received: " + callback
          );
        callback.call(context);
      }
      function commitHiddenCallbacks(updateQueue, context) {
        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
        if (null !== hiddenCallbacks)
          for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
            callCallback(hiddenCallbacks[updateQueue], context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      function pushHiddenContext(fiber, context) {
        var prevEntangledRenderLanes = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
        push(currentTreeHiddenStackCursor, context, fiber);
        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
      }
      function reuseHiddenContextOnStack(fiber) {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
        push(
          currentTreeHiddenStackCursor,
          currentTreeHiddenStackCursor.current,
          fiber
        );
      }
      function popHiddenContext(fiber) {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor, fiber);
        pop(prevEntangledRenderLanesCursor, fiber);
      }
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current2 = handler.alternate;
        push(
          suspenseStackCursor,
          suspenseStackCursor.current & SubtreeSuspenseContextMask,
          handler
        );
        push(suspenseHandlerStackCursor, handler, handler);
        null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current, fiber);
        push(suspenseHandlerStackCursor, fiber, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current, fiber);
        push(
          suspenseHandlerStackCursor,
          suspenseHandlerStackCursor.current,
          fiber
        );
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor, fiber);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor, fiber);
      }
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function mountHookTypesDev() {
        var hookName = currentHookNameInDev;
        null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
      }
      function updateHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
            for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
              var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
              for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                oldHookName += " ";
              oldHookName += newHookName + "\n";
              table += oldHookName;
            }
            console.error(
              "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
              componentName2,
              table
            );
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          currentHookNameInDev,
          typeof deps
        );
      }
      function warnOnUseFormStateInDev() {
        var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          componentName2
        ));
      }
      function throwInvalidHookError() {
        throw Error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies) return false;
        if (null === prevDeps)
          return console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            currentHookNameInDev
          ), false;
        nextDeps.length !== prevDeps.length && console.error(
          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
          currentHookNameInDev,
          "[" + prevDeps.join(", ") + "]",
          "[" + nextDeps.join(", ") + "]"
        );
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
        if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
          nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
            "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
            null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
          ));
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
        var children = callComponentInDEV(Component, props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        if (nextRenderLanes) {
          setIsStrictModeForDevtools(true);
          try {
            children = renderWithHooksAgain(
              workInProgress2,
              Component,
              props,
              secondArg
            );
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        finishRenderingHooks(current2, workInProgress2);
        return children;
      }
      function finishRenderingHooks(current2, workInProgress2) {
        workInProgress2._debugHookTypes = hookTypesDev;
        null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
          lanes: 0,
          firstContext: null,
          _debugThenableState: thenableState
        }) : workInProgress2.dependencies._debugThenableState = thenableState;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
        hookTypesUpdateIndexDev = -1;
        null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        );
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks)
          throw Error(
            "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
          );
        null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
        current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
          "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
        )));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (numberOfReRenders >= RE_RENDER_LIMIT)
            throw Error(
              "Too many re-renders. React limits the number of renders to prevent an infinite loop."
            );
          numberOfReRenders += 1;
          ignorePreviousDependencies = false;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          hookTypesUpdateIndexDev = -1;
          ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
          children = callComponentInDEV(Component, props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue;
        workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
        current2.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
        hookTypesUpdateIndexDev = -1;
        currentHookNameInDev = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(
                "Update hook called on initial render. This is likely a bug in React. Please file an issue."
              );
            throw Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = createThenableState());
        thenable = trackUsedThenable(thenableState, thenable, index);
        index = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current2 = currentlyRenderingFiber.alternate;
          null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
            data: current2.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue || ignorePreviousDependencies)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
            updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
        else
          updateQueue.length !== size && console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            updateQueue.length,
            size
          );
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current2, reducer) {
        var queue = hook.queue;
        if (null === queue)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current2.baseQueue !== baseQueue && console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          );
          current2.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current2 = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current2);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          var nextSnapshot = getServerSnapshot();
          didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        } else {
          nextSnapshot = getSnapshot();
          didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true));
          if (null === workInProgressRoot)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
        }
        hook.memoizedState = nextSnapshot;
        getServerSnapshot = { value: nextSnapshot, getSnapshot };
        hook.queue = getServerSnapshot;
        mountEffect(
          subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
          [subscribe]
        );
        fiber.flags |= 2048;
        pushSimpleEffect(
          HasEffect | Passive,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            getServerSnapshot,
            nextSnapshot,
            getSnapshot
          ),
          null
        );
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          getServerSnapshot = getServerSnapshot();
        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
          var cachedSnapshot = getSnapshot();
          objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        if (cachedSnapshot = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        ))
          hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, Passive, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function mountState(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      }
      function mountOptimistic(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      }
      function updateOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      }
      function updateOptimisticImpl(hook, current2, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function rerenderOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber))
          throw Error("Cannot update form state while rendering.");
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        } else
          try {
            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
          } catch (error$4) {
            onActionError(actionQueue, node, error$4);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ), node.isTransition || console.error(
          "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
        )) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var isMatching = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var markerInstance = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                      if (!inRootOrSingleton) {
                        markerInstance = null;
                        break b;
                      }
                      markerInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      if (null === markerInstance) {
                        markerInstance = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = markerInstance.data;
                    markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                  }
                  if (markerInstance) {
                    nextHydratableInstance = getNextHydratable(
                      markerInstance.nextSibling
                    );
                    isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                    break a;
                  }
                }
                throwOnHydrationMismatch(isMatching);
              }
              isMatching = false;
            }
            isMatching && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        isMatching = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = isMatching;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          isMatching
        );
        isMatching.dispatch = ssrFormState;
        isMatching = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          isMatching.queue
        );
        isMatching = mountWorkInProgressHook();
        markerInstance = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        isMatching.queue = markerInstance;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          markerInstance,
          inRootOrSingleton,
          ssrFormState
        );
        markerInstance.dispatch = ssrFormState;
        isMatching.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          HasEffect | Passive,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, deps) {
        tag = { tag, create, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          HasEffect | hookFlags,
          { destroy: void 0 },
          create,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          HasEffect | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, deps) {
        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function mountEvent(callback) {
        var hook = mountWorkInProgressHook(), ref = { impl: callback };
        hook.memoizedState = ref;
        return function() {
          if ((executionContext & RenderContext) !== NoContext)
            throw Error(
              "A function wrapped in useEffectEvent can't be called during rendering."
            );
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateEvent(callback) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback });
        return function() {
          if ((executionContext & RenderContext) !== NoContext)
            throw Error(
              "A function wrapped in useEffectEvent can't be called during rendering."
            );
          return ref.impl.apply(void 0, arguments);
        };
      }
      function mountLayoutEffect(create, deps) {
        var fiberFlags = 4194308;
        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
        return mountEffectImpl(fiberFlags, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return ref.hasOwnProperty("current") || console.error(
            "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
            "an object with keys {" + Object.keys(ref).join(", ") + "}"
          ), create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function mountImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        var fiberFlags = 4194308;
        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
        mountEffectImpl(
          fiberFlags,
          Layout,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }
      function updateImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(
          4,
          Layout,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }
      function mountCallback(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValue(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      }
      function updateDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }
      function rerenderDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function releaseAsyncTransition() {
        ReactSharedInternals.asyncTransitions--;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            ReactSharedInternals.asyncTransitions++;
            returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane(fiber)
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
            "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
          ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag)
          throw Error(
            "Expected the form instance to be a HostComponent. This is a bug in React."
          );
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startHostActionTimer(formFiber);
        startTransition(
          formFiber,
          queue,
          pendingState,
          NotPendingTransition,
          null === action ? noop : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: NotPendingTransition,
          baseState: NotPendingTransition,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: NotPendingTransition
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        null === ReactSharedInternals.T && console.error(
          "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
        );
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane(formFiber)
        );
      }
      function mountTransition() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      }
      function updateTransition() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }
      function rerenderTransition() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function mountId() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var treeId = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
          identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
          treeId = localIdCounter++;
          0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
          identifierPrefix += "_";
        } else
          treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      }
      function mountRefresh() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      }
      function refreshCache(fiber, seedKey) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root2 = enqueueUpdate(provider, refreshUpdate, lane);
              null !== root2 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
              fiber = createCache();
              null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                "The seed argument is not enabled outside experimental channels."
              );
              refreshUpdate.payload = { cache: fiber };
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var args = arguments;
        "function" === typeof args[3] && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
        args = requestUpdateLane(fiber);
        var update = {
          lane: args,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
      }
      function dispatchSetState(fiber, queue, action) {
        var args = arguments;
        "function" === typeof args[3] && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
        args = requestUpdateLane(fiber);
        dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender)
            throw Error("Cannot update optimistic state while rendering.");
          console.error("Cannot call startTransition while rendering.");
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            partialState = getDerivedStateFromProps(nextProps, prevState);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
          ctor
        )));
        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
        workInProgress2.memoizedState = prevState;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
      }
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if ("function" === typeof instance.shouldComponentUpdate) {
          oldProps = instance.shouldComponentUpdate(
            newProps,
            newState,
            nextContext
          );
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              oldProps = instance.shouldComponentUpdate(
                newProps,
                newState,
                nextContext
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === oldProps && console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            getComponentNameFromType(ctor) || "Component"
          );
          return oldProps;
        }
        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
          "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          workInProgress2
        )), classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ));
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var _propName in Component)
            void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
        console.warn(
          "%s\n\n%s\n",
          componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
        );
      }
      function defaultOnCaughtError(error) {
        var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [
            "%o\n\n%s\n\n%s\n",
            error,
            componentNameMessage,
            recreateMessage
          ].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            badgeFormat + " " + error[0],
            badgeStyle,
            pad + JSCompiler_inline_result + pad,
            resetStyle
          ) : error.splice(
            0,
            0,
            badgeFormat,
            badgeStyle,
            pad + JSCompiler_inline_result + pad,
            resetStyle
          );
          error.unshift(console);
          JSCompiler_inline_result = bind.apply(console.error, error);
          JSCompiler_inline_result();
        } else
          console.error(
            "%o\n\n%s\n\n%s\n",
            error,
            componentNameMessage,
            recreateMessage
          );
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
          errorBoundaryName = null;
          var error = errorInfo.value;
          if (null !== ReactSharedInternals.actQueue)
            ReactSharedInternals.thrownErrors.push(error);
          else {
            var onUncaughtError = root2.onUncaughtError;
            onUncaughtError(error, { componentStack: errorInfo.stack });
          }
        } catch (e$5) {
          setTimeout(function() {
            throw e$5;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
          errorBoundaryName = getComponentNameFromFiber(boundary);
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$6) {
          setTimeout(function() {
            throw e$6;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        lane.payload = { element: null };
        lane.callback = function() {
          runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root2,
            fiber,
            errorInfo
          );
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          callComponentDidCatchInDEV(this, errorInfo);
          "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
            "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
            getComponentNameFromFiber(fiber) || "Unknown"
          );
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          isHydrating && (didSuspendOrErrorDEV = true);
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(
              "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
            );
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                { cause: value }
              ),
              sourceFiber
            )
          )) : (value !== HydrationMismatchException && queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                { cause: value }
              ),
              sourceFiber
            )
          ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
        var error = createCapturedValueAtFiber(
          Error(
            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
            { cause: value }
          ),
          sourceFiber
        );
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root2
              ), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current2.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current2,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current2) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
              current2,
              workInProgress2,
              Component,
              nextProps,
              renderLanes2
            );
          current2 = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        type = current2.child;
        if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
        }
        workInProgress2.flags |= 1;
        current2 = createWorkInProgress(type, nextProps);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current2) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
              0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current2,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
        null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: OffscreenVisible,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current2) {
              nextProps = workInProgress2.child = current2.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current2,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current2,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current2, workInProgress2) {
        null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: OffscreenVisible,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
          parent: CacheContext._currentValue,
          pool: JSCompiler_inline_result
        };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current2 && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack(workInProgress2);
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        var hiddenProp = nextProps.hidden;
        void 0 !== hiddenProp && console.error(
          `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
          true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
          hiddenProp ? 'mode="hidden"' : 'mode="visible"'
        );
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        current2 = mountActivityChildren(
          workInProgress2,
          workInProgress2.pendingProps
        );
        current2.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current2;
      }
      function updateActivityComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current2) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
              current2,
              rootOrSingletonContext
            ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
              dehydrated: renderLanes2,
              treeContext: getSuspendedTreeContext(),
              retryLane: 536870912,
              hydrationErrors: null
            }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
            if (null === renderLanes2)
              throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current2.memoizedState;
        if (null !== prevState) {
          var activityInstance = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else
              throw Error(
                "Client rendering an Activity suspended it again. This is a bug in React."
              );
          else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
            current2,
            workInProgress2,
            renderLanes2,
            false
          ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
              nextProps,
              renderLanes2
            ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
              throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2
            );
          } else
            current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              activityInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        prevState = current2.child;
        nextProps = { mode: nextProps.mode, children: nextProps.children };
        0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
        current2 = createWorkInProgress(prevState, nextProps);
        current2.ref = workInProgress2.ref;
        workInProgress2.child = current2;
        current2.return = workInProgress2;
        return current2;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(
              "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
            );
          if (null === current2 || current2.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (Component.prototype && "function" === typeof Component.prototype.render) {
          var componentName2 = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutBadClass[componentName2] || (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName2,
            componentName2
          ), didWarnAboutBadClass[componentName2] = true);
        }
        workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress2,
          null
        );
        null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
          componentName2
        ))));
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current2,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current2, workInProgress2);
        Component = checkDidRenderIdHook();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        switch (shouldErrorImpl(workInProgress2)) {
          case false:
            var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
              workInProgress2.memoizedProps,
              _instance.context
            ).state;
            _instance.updater.enqueueSetState(_instance, state, null);
            break;
          case true:
            workInProgress2.flags |= 128;
            workInProgress2.flags |= 65536;
            _instance = Error("Simulated error coming from DevTools");
            var lane = renderLanes2 & -renderLanes2;
            workInProgress2.lanes |= lane;
            state = workInProgressRoot;
            if (null === state)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            lane = createClassErrorUpdate(lane);
            initializeClassErrorUpdate(
              lane,
              state,
              workInProgress2,
              createCapturedValueAtFiber(_instance, workInProgress2)
            );
            enqueueCapturedUpdate(workInProgress2, lane);
        }
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          state = emptyContextObject;
          _instance = Component.contextType;
          "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            getComponentNameFromType(Component) || "Component",
            lane
          ));
          "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
          _instance = new Component(nextProps, state);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              _instance = new Component(nextProps, state);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
          _instance.updater = classComponentUpdater;
          workInProgress2.stateNode = _instance;
          _instance._reactInternals = workInProgress2;
          _instance._reactInternalInstance = fakeInternalInstance;
          "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
            "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
            state,
            null === _instance.state ? "null" : "undefined",
            state
          )));
          if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
            var foundWillUpdateName = lane = state = null;
            "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
            "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
            "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
            if (null !== state || null !== lane || null !== foundWillUpdateName) {
              _instance = getComponentNameFromType(Component) || "Component";
              var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                _instance,
                newApiName,
                null !== state ? "\n  " + state : "",
                null !== lane ? "\n  " + lane : "",
                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
              ));
            }
          }
          _instance = workInProgress2.stateNode;
          state = getComponentNameFromType(Component) || "Component";
          _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
            "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
            state
          ) : console.error(
            "No `render` method found on the %s instance: you may have forgotten to define `render`.",
            state
          ));
          !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            state
          );
          _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            state
          );
          _instance.contextType && console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            state
          );
          Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            state
          ));
          Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            state
          ));
          "function" === typeof _instance.componentShouldUpdate && console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            state
          );
          Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            getComponentNameFromType(Component) || "A pure component"
          );
          "function" === typeof _instance.componentDidUnmount && console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            state
          );
          "function" === typeof _instance.componentDidReceiveProps && console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            state
          );
          "function" === typeof _instance.componentWillRecieveProps && console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            state
          );
          "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            state
          );
          lane = _instance.props !== nextProps;
          void 0 !== _instance.props && lane && console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            state
          );
          _instance.defaultProps && console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            state,
            state
          );
          "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            getComponentNameFromType(Component)
          ));
          "function" === typeof _instance.getDerivedStateFromProps && console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
          "function" === typeof _instance.getDerivedStateFromError && console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
          "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            state
          );
          (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
          "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            state
          );
          _instance = workInProgress2.stateNode;
          _instance.props = nextProps;
          _instance.state = workInProgress2.memoizedState;
          _instance.refs = {};
          initializeUpdateQueue(workInProgress2);
          state = Component.contextType;
          _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
          _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
            "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
            state
          )));
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            _instance
          );
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
            workInProgress2,
            _instance
          );
          _instance.state = workInProgress2.memoizedState;
          state = Component.getDerivedStateFromProps;
          "function" === typeof state && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            state,
            nextProps
          ), _instance.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
            "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            getComponentNameFromFiber(workInProgress2) || "Component"
          ), classComponentUpdater.enqueueReplaceState(
            _instance,
            _instance.state,
            null
          )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
          "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
          (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
          _instance = true;
        } else if (null === current2) {
          _instance = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps;
          lane = resolveClassComponentProps(Component, unresolvedOldProps);
          _instance.props = lane;
          var oldContext = _instance.context;
          foundWillUpdateName = Component.contextType;
          state = emptyContextObject;
          "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
          newApiName = Component.getDerivedStateFromProps;
          foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
            workInProgress2,
            _instance,
            nextProps,
            state
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          _instance.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            newApiName,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            lane,
            nextProps,
            oldState,
            oldContext,
            state
          )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
        } else {
          _instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          state = workInProgress2.memoizedProps;
          foundWillUpdateName = resolveClassComponentProps(Component, state);
          _instance.props = foundWillUpdateName;
          newApiName = workInProgress2.pendingProps;
          oldState = _instance.context;
          oldContext = Component.contextType;
          lane = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
            workInProgress2,
            _instance,
            nextProps,
            lane
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          _instance.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            foundWillUpdateName,
            nextProps,
            oldState,
            newState,
            lane
          ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            lane
          )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
        }
        lane = _instance;
        markRef(current2, workInProgress2);
        state = 0 !== (workInProgress2.flags & 128);
        if (lane || state) {
          lane = workInProgress2.stateNode;
          setCurrentFiber(workInProgress2);
          if (state && "function" !== typeof Component.getDerivedStateFromError)
            Component = null, profilerStartTime = -1;
          else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          workInProgress2.flags |= 1;
          null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            current2.child,
            null,
            renderLanes2
          ), workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            Component,
            renderLanes2
          )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          workInProgress2.memoizedState = lane.state;
          current2 = workInProgress2.child;
        } else
          current2 = bailoutOnAlreadyFinishedWork(
            current2,
            workInProgress2,
            renderLanes2
          );
        renderLanes2 = workInProgress2.stateNode;
        _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
          "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
          getComponentNameFromFiber(workInProgress2) || "a component"
        ), didWarnAboutReassigningProps = true);
        return current2;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        Component && Component.childContextTypes && console.error(
          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
          Component.displayName || Component.name || "Component"
        );
        "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
          "%s: Function components do not support getDerivedStateFromProps.",
          workInProgress2
        ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
        "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
          "%s: Function components do not support contextType.",
          Component
        ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
      }
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
        current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
        return current2;
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var JSCompiler_object_inline_digest_2724;
        var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
        shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
        var JSCompiler_object_inline_message_2723 = false;
        var didSuspend = 0 !== (workInProgress2.flags & 128);
        (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
        JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
        JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current2) {
          if (isHydrating) {
            JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
              current2,
              rootOrSingletonContext
            ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
              dehydrated: renderLanes2,
              treeContext: getSuspendedTreeContext(),
              retryLane: 536870912,
              hydrationErrors: null
            }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
            if (null === renderLanes2)
              throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
          JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
          if (JSCompiler_object_inline_message_2723) {
            reuseSuspenseHandlerOnStack(workInProgress2);
            var mode = workInProgress2.mode;
            nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              mode
            );
            JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
              JSCompiler_object_inline_stack_2725,
              mode,
              renderLanes2,
              null
            );
            nextPrimaryChildren.return = workInProgress2;
            JSCompiler_object_inline_stack_2725.return = workInProgress2;
            nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
            workInProgress2.child = nextPrimaryChildren;
            JSCompiler_object_inline_stack_2725 = workInProgress2.child;
            JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            );
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return bailoutOffscreenComponent(
              null,
              JSCompiler_object_inline_stack_2725
            );
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(
            workInProgress2,
            nextPrimaryChildren
          );
        }
        var prevState = current2.memoizedState;
        if (null !== prevState) {
          var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
          if (null !== JSCompiler_object_inline_componentStack_2726) {
            if (didSuspend)
              workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "visible",
                  children: JSCompiler_object_inline_stack_2725.children
                },
                mode
              ), nextPrimaryChildren = createFiberFromFragment(
                nextPrimaryChildren,
                mode,
                renderLanes2,
                null
              ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                workInProgress2,
                current2.child,
                null,
                renderLanes2
              ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              ));
            else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
              JSCompiler_object_inline_componentStack_2726
            )) {
              JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
              if (JSCompiler_object_inline_digest_2724) {
                nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                var message = JSCompiler_object_inline_digest_2724.msg;
                mode = JSCompiler_object_inline_digest_2724.stck;
                var componentStack = JSCompiler_object_inline_digest_2724.cstck;
              }
              JSCompiler_object_inline_message_2723 = message;
              JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = mode;
              JSCompiler_object_inline_componentStack_2726 = componentStack;
              nextPrimaryChildren = JSCompiler_object_inline_message_2723;
              mode = JSCompiler_object_inline_componentStack_2726;
              nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
              );
              nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
              nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
              JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
              JSCompiler_object_inline_stack_2725 = {
                value: nextPrimaryChildren,
                source: null,
                stack: JSCompiler_object_inline_digest_2724
              };
              "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                nextPrimaryChildren,
                JSCompiler_object_inline_stack_2725
              );
              queueHydrationError(JSCompiler_object_inline_stack_2725);
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else if (didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
              JSCompiler_object_inline_digest_2724 = workInProgressRoot;
              if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                  current2,
                  JSCompiler_object_inline_stack_2725
                ), scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2724,
                  current2,
                  JSCompiler_object_inline_stack_2725
                ), SelectiveHydrationException;
              isSuspenseInstancePending(
                JSCompiler_object_inline_componentStack_2726
              ) || renderDidSuspendDelayIfPossible();
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              isSuspenseInstancePending(
                JSCompiler_object_inline_componentStack_2726
              ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_componentStack_2726.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_stack_2725.children
              ), workInProgress2.flags |= 4096);
            return workInProgress2;
          }
        }
        if (JSCompiler_object_inline_message_2723)
          return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
            componentStack,
            {
              mode: "hidden",
              children: JSCompiler_object_inline_stack_2725.children
            }
          ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
            JSCompiler_object_inline_componentStack_2726,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            mode,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: mode
          }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
            current2,
            JSCompiler_object_inline_digest_2724,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
            current2.child,
            JSCompiler_object_inline_stack_2725
          );
        null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current2.child;
        current2 = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: JSCompiler_object_inline_stack_2725.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiber(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        current2 = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current2.flags |= 2;
        workInProgress2.memoizedState = null;
        return current2;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(
          fiber.return,
          renderLanes2,
          propagationRoot
        );
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
        (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
        push(suspenseStackCursor, suspenseContext, workInProgress2);
        suspenseContext = null == revealOrder ? "null" : revealOrder;
        if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
          if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
            console.error(
              'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
            );
          else if ("backwards" === revealOrder)
            console.error(
              'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
            );
          else if ("string" === typeof revealOrder)
            switch (revealOrder.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards":
              case "independent":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                  revealOrder,
                  revealOrder.toLowerCase()
                );
                break;
              case "forward":
              case "backward":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                  revealOrder,
                  revealOrder.toLowerCase()
                );
                break;
              default:
                console.error(
                  '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                  revealOrder
                );
            }
          else
            console.error(
              '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
              revealOrder
            );
        suspenseContext = null == tailMode ? "null" : tailMode;
        if (!didWarnAboutTailOptions[suspenseContext])
          if (null == tailMode) {
            if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
              didWarnAboutTailOptions[suspenseContext] = true, console.error(
                'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
              );
          } else
            "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
              tailMode
            )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
              tailMode
            ));
        a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
          if (isArrayImpl(newChildren))
            for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
              if (!validateSuspenseListNestedChild(
                newChildren[suspenseContext],
                suspenseContext
              ))
                break a;
            }
          else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
            if (suspenseContext = suspenseContext.call(newChildren))
              for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                _i++;
              }
          } else
            console.error(
              'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
              revealOrder
            );
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
        if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
          a: for (current2 = workInProgress2.child; null !== current2; ) {
            if (13 === current2.tag)
              null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (19 === current2.tag)
              scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (null !== current2.child) {
              current2.child.return = current2;
              current2 = current2.child;
              continue;
            }
            if (current2 === workInProgress2) break a;
            for (; null === current2.sibling; ) {
              if (null === current2.return || current2.return === workInProgress2)
                break a;
              current2 = current2.return;
            }
            current2.sibling.return = current2.return;
            current2 = current2.sibling;
          }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              newChildren
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current2 = revealOrder.alternate;
              if (null !== current2 && null === findFirstSuspended(current2)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current2 = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current2;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              newChildren
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              newChildren
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        null !== current2 && (workInProgress2.dependencies = current2.dependencies);
        profilerStartTime = -1;
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current2) {
            if (propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current2 && workInProgress2.child !== current2.child)
          throw Error("Resuming work not yet implemented.");
        if (null !== workInProgress2.child) {
          current2 = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
            current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        if (0 !== (current2.lanes & renderLanes2)) return true;
        current2 = current2.dependencies;
        return null !== current2 && checkIfContextChanged(current2) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            pushProvider(
              workInProgress2,
              CacheContext,
              current2.memoizedState.cache
            );
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 12:
            0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
            workInProgress2.flags |= 2048;
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = -0;
            stateNode.passiveEffectDuration = -0;
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            stateNode = workInProgress2.memoizedState;
            if (null !== stateNode) {
              if (null !== stateNode.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current2 = bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
              return null !== current2 ? current2.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current2.flags & 128);
            stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
            stateNode || (propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (stateNode)
                return updateSuspenseListComponent(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(
              suspenseStackCursor,
              suspenseStackCursor.current,
              workInProgress2
            );
            if (stateNode) break;
            else return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current2,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(
              workInProgress2,
              CacheContext,
              current2.memoizedState.cache
            );
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        if (workInProgress2._debugNeedsRemount && null !== current2) {
          renderLanes2 = createFiberFromTypeAndProps(
            workInProgress2.type,
            workInProgress2.key,
            workInProgress2.pendingProps,
            workInProgress2._debugOwner || null,
            workInProgress2.mode,
            workInProgress2.lanes
          );
          renderLanes2._debugStack = workInProgress2._debugStack;
          renderLanes2._debugTask = workInProgress2._debugTask;
          var returnFiber = workInProgress2.return;
          if (null === returnFiber) throw Error("Cannot swap the root fiber.");
          current2.alternate = null;
          workInProgress2.alternate = null;
          renderLanes2.index = workInProgress2.index;
          renderLanes2.sibling = workInProgress2.sibling;
          renderLanes2.return = workInProgress2.return;
          renderLanes2.ref = workInProgress2.ref;
          renderLanes2._debugInfo = workInProgress2._debugInfo;
          if (workInProgress2 === returnFiber.child)
            returnFiber.child = renderLanes2;
          else {
            var prevSibling = returnFiber.child;
            if (null === prevSibling)
              throw Error("Expected parent to have a child.");
            for (; prevSibling.sibling !== workInProgress2; )
              if (prevSibling = prevSibling.sibling, null === prevSibling)
                throw Error("Expected to find the previous sibling.");
            prevSibling.sibling = renderLanes2;
          }
          workInProgress2 = returnFiber.deletions;
          null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
          renderLanes2.flags |= 2;
          return renderLanes2;
        }
        if (null !== current2)
          if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current2,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
          }
        else {
          didReceiveUpdate = false;
          if (returnFiber = isHydrating)
            warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
          returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
        }
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                current2,
                returnFiber
              ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current2,
                returnFiber,
                renderLanes2
              )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current2,
                returnFiber,
                renderLanes2
              ));
            else {
              if (void 0 !== current2 && null !== current2) {
                if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                } else if (prevSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = "";
              null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              renderLanes2 = getComponentNameFromType(current2) || current2;
              throw Error(
                "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
              );
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
              returnFiber,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current2,
              workInProgress2,
              returnFiber,
              prevSibling,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current2)
                throw Error(
                  "Should have a current fiber. This is a bug in React."
                );
              returnFiber = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              prevSibling = prevState.element;
              cloneUpdateQueue(current2, workInProgress2);
              processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              returnFiber = nextState.cache;
              pushProvider(workInProgress2, CacheContext, returnFiber);
              returnFiber !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              returnFiber = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: returnFiber,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                } else if (returnFiber !== prevSibling) {
                  prevSibling = createCapturedValueAtFiber(
                    Error(
                      "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                    ),
                    workInProgress2
                  );
                  queueHydrationError(prevSibling);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                } else {
                  current2 = workInProgress2.stateNode.containerInfo;
                  switch (current2.nodeType) {
                    case 9:
                      current2 = current2.body;
                      break;
                    default:
                      current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                  }
                  nextHydratableInstance = getNextHydratable(current2.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  didSuspendOrErrorDEV = false;
                  hydrationDiffRootDEV = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    returnFiber,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (returnFiber === prevSibling) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current2,
                  workInProgress2,
                  returnFiber,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
              rootInstanceStackCursor.current
            ), returnFiber = getOwnerDocumentFromRootContainer(
              returnFiber
            ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current2.memoizedProps,
              workInProgress2.pendingProps,
              current2.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              returnFiber,
              prevSibling,
              false
            ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
              returnFiber,
              workInProgress2.type,
              workInProgress2.pendingProps,
              prevSibling
            ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
              returnFiber.firstChild
            )) : nextHydratableInstance = prevSibling), reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
              workInProgress2.type,
              prevState.ancestorInfo
            ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
              prevSibling,
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
              nextState,
              workInProgress2.type,
              workInProgress2.pendingProps,
              prevState
            ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
              nextState.firstChild
            ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
              current2,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 6:
            return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
              renderLanes2,
              returnFiber.tag,
              current2.ancestorInfo.implicitRootScope
            ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
              current2,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
          case 13:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              returnFiber,
              renderLanes2
            ) : reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
              "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
            )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
              current2,
              workInProgress2,
              prevSibling.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
              "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
            ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
              returnFiber,
              prevSibling,
              void 0
            ), workInProgress2.flags |= 1, reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(
              current2,
              workInProgress2,
              renderLanes2
            );
          case 31:
            return updateActivityComponent(current2, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current2,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
              parent: returnFiber,
              cache: prevSibling
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
              parent: returnFiber,
              cache: returnFiber
            }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(
          "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
          type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var _lastTailNode = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
              newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        else if ((completedWork.mode & ProfileMode) !== NoMode) {
          _treeBaseDuration = completedWork.actualDuration;
          _child2 = completedWork.selfBaseDuration;
          for (var child = completedWork.child; null !== child; )
            newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
          completedWork.actualDuration = _treeBaseDuration;
          completedWork.treeBaseDuration = _child2;
        } else
          for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current2 && (newProps = current2.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext, workInProgress2);
            popHostContainer(workInProgress2);
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current2 || null === current2.child)
              popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
              workInProgress2,
              nextResource
            )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
              workInProgress2,
              nextResource
            )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current2,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = requiredContext(rootInstanceStackCursor.current);
            type = workInProgress2.type;
            if (null !== current2 && null != workInProgress2.stateNode)
              current2.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                bubbleProperties(workInProgress2);
                return null;
              }
              current2 = getHostContext();
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                type,
                newProps,
                renderLanes2,
                current2,
                true
              ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current2 && null != workInProgress2.stateNode)
              current2.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                bubbleProperties(workInProgress2);
                return null;
              }
              var _currentHostContext = getHostContext();
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
              else {
                nextResource = requiredContext(rootInstanceStackCursor.current);
                validateDOMNesting(type, _currentHostContext.ancestorInfo);
                _currentHostContext = _currentHostContext.context;
                nextResource = getOwnerDocumentFromRootContainer(nextResource);
                switch (_currentHostContext) {
                  case HostContextNamespaceSvg:
                    nextResource = nextResource.createElementNS(
                      SVG_NAMESPACE,
                      type
                    );
                    break;
                  case HostContextNamespaceMath:
                    nextResource = nextResource.createElementNS(
                      MATH_NAMESPACE,
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = nextResource.createElementNS(
                          SVG_NAMESPACE,
                          type
                        );
                        break;
                      case "math":
                        nextResource = nextResource.createElementNS(
                          MATH_NAMESPACE,
                          type
                        );
                        break;
                      case "script":
                        nextResource = nextResource.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                          is: newProps.is
                        }) : nextResource.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                          is: newProps.is
                        }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                          type
                        ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                          "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                          type
                        )));
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                  if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                    nextResource.appendChild(_currentHostContext.stateNode);
                  else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                    _currentHostContext.child.return = _currentHostContext;
                    _currentHostContext = _currentHostContext.child;
                    continue;
                  }
                  if (_currentHostContext === workInProgress2) break a;
                  for (; null === _currentHostContext.sibling; ) {
                    if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                      break a;
                    _currentHostContext = _currentHostContext.return;
                  }
                  _currentHostContext.sibling.return = _currentHostContext.return;
                  _currentHostContext = _currentHostContext.sibling;
                }
                workInProgress2.stateNode = nextResource;
                a: switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current2 ? null : current2.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current2 && null != workInProgress2.stateNode)
              current2.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              current2 = requiredContext(rootInstanceStackCursor.current);
              renderLanes2 = getHostContext();
              if (popHydrationState(workInProgress2)) {
                current2 = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                type = !didSuspendOrErrorDEV;
                newProps = null;
                nextResource = hydrationParentFiber;
                if (null !== nextResource)
                  switch (nextResource.tag) {
                    case 3:
                      type && (type = diffHydratedTextForDevWarnings(
                        current2,
                        renderLanes2,
                        newProps
                      ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                      break;
                    case 27:
                    case 5:
                      newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                        current2,
                        renderLanes2,
                        newProps
                      ), null !== type && (buildHydrationDiffNode(
                        workInProgress2,
                        0
                      ).serverProps = type));
                  }
                current2[internalInstanceKey] = workInProgress2;
                current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                current2 || throwOnHydrationMismatch(workInProgress2, true);
              } else
                type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                  newProps,
                  type.tag,
                  renderLanes2.ancestorInfo.implicitRootScope
                ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                  newProps
                ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current2 || null !== current2.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current2) {
                  if (!newProps)
                    throw Error(
                      "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                    );
                  current2 = workInProgress2.memoizedState;
                  current2 = null !== current2 ? current2.dehydrated : null;
                  if (!current2)
                    throw Error(
                      "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                    );
                  current2[internalInstanceKey] = workInProgress2;
                  bubbleProperties(workInProgress2);
                  (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                } else
                  emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                current2 = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
              if (!current2) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
              type = newProps;
              nextResource = popHydrationState(workInProgress2);
              if (null !== type && null !== type.dehydrated) {
                if (null === current2) {
                  if (!nextResource)
                    throw Error(
                      "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                    );
                  nextResource = workInProgress2.memoizedState;
                  nextResource = null !== nextResource ? nextResource.dehydrated : null;
                  if (!nextResource)
                    throw Error(
                      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                    );
                  nextResource[internalInstanceKey] = workInProgress2;
                  bubbleProperties(workInProgress2);
                  (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                } else
                  emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
            renderLanes2 = null !== newProps;
            current2 = null !== current2 && null !== current2.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
            return null;
          case 4:
            return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
              workInProgress2.stateNode.containerInfo
            ), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor, workInProgress2);
            newProps = workInProgress2.memoizedState;
            if (null === newProps) return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type) cutOffTailIfNeeded(newProps, false);
              else {
                if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                  for (current2 = workInProgress2.child; null !== current2; ) {
                    nextResource = findFirstSuspended(current2);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current2 = nextResource.updateQueue;
                      workInProgress2.updateQueue = current2;
                      scheduleRetryEffect(workInProgress2, current2);
                      workInProgress2.subtreeFlags = 0;
                      current2 = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                        workInProgress2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current2 = current2.sibling;
                  }
                null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current2 = findFirstSuspended(nextResource), null !== current2) {
                  if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
          case 24:
            return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(
          "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function unwindWork(current2, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 3:
            return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(
                  "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                );
              resetHydrationState();
            }
            current2 = workInProgress2.flags;
            return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current2 = workInProgress2.memoizedState;
            if (null !== current2 && null !== current2.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(
                  "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                );
              resetHydrationState();
            }
            current2 = workInProgress2.flags;
            return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor, workInProgress2), null;
          case 4:
            return popHostContainer(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type, workInProgress2), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 24:
            return popProvider(CacheContext, workInProgress2), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext, interruptedWork);
            popHostContainer(interruptedWork);
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer(interruptedWork);
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor, interruptedWork);
            break;
          case 10:
            popProvider(interruptedWork.type, interruptedWork);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext(interruptedWork);
            null !== current2 && pop(resumedCache, interruptedWork);
            break;
          case 24:
            popProvider(CacheContext, interruptedWork);
        }
      }
      function shouldProfile(current2) {
        return (current2.mode & ProfileMode) !== NoMode;
      }
      function commitHookLayoutEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
      }
      function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        ), recordEffectDuration()) : commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        );
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                finishedWork,
                callCreateInDEV,
                updateQueue
              ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                var hookName = void 0;
                hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                var addendum = void 0;
                addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                runWithFiberInDEV(
                  finishedWork,
                  function(n, a) {
                    console.error(
                      "%s must not return anything besides a function, which is used for clean-up.%s",
                      n,
                      a
                    );
                  },
                  hookName,
                  addendum
                );
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                  lastEffect,
                  callDestroyInDEV,
                  lastEffect,
                  nearestMountedAncestor,
                  destroy
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookPassiveMountEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
      }
      function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        ), recordEffectDuration()) : commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        );
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), instance.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            runWithFiberInDEV(
              finishedWork,
              commitCallbacks,
              updateQueue,
              instance
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
        return instance.getSnapshotBeforeUpdate(prevProps, prevState);
      }
      function commitClassSnapshot(finishedWork, current2) {
        var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
        current2 = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
          "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        ), current2.state !== finishedWork.memoizedState && console.error(
          "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        ));
        try {
          var resolvedPrevProps = resolveClassComponentProps(
            finishedWork.type,
            prevProps
          );
          var snapshot = runWithFiberInDEV(
            finishedWork,
            callGetSnapshotBeforeUpdates,
            current2,
            resolvedPrevProps,
            prevState
          );
          prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
          void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              getComponentNameFromFiber(finishedWork)
            );
          }));
          current2.__reactInternalSnapshotBeforeUpdate = snapshot;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current2.type,
          current2.memoizedProps
        );
        instance.state = current2.memoizedState;
        shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
          current2,
          callComponentWillUnmountInDEV,
          current2,
          nearestMountedAncestor,
          instance
        ), recordEffectDuration()) : runWithFiberInDEV(
          current2,
          callComponentWillUnmountInDEV,
          current2,
          nearestMountedAncestor,
          instance
        );
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (null !== ref) {
          switch (finishedWork.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = finishedWork.stateNode;
              break;
            case 30:
              instanceToUse = finishedWork.stateNode;
              break;
            default:
              instanceToUse = finishedWork.stateNode;
          }
          if ("function" === typeof ref)
            if (shouldProfile(finishedWork))
              try {
                startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
              } finally {
                recordEffectDuration();
              }
            else finishedWork.refCleanup = ref(instanceToUse);
          else
            "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
              "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
              getComponentNameFromFiber(finishedWork)
            ), ref.current = instanceToUse;
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          runWithFiberInDEV(current2, commitAttachRef, current2);
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref = current2.ref, refCleanup = current2.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              if (shouldProfile(current2))
                try {
                  startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                } finally {
                  recordEffectDuration(current2);
                }
              else runWithFiberInDEV(current2, refCleanup);
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            } finally {
              current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              if (shouldProfile(current2))
                try {
                  startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                } finally {
                  recordEffectDuration(current2);
                }
              else runWithFiberInDEV(current2, ref, null);
            } catch (error$7) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
            }
          else ref.current = null;
      }
      function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
        _finishedWork$memoize = _finishedWork$memoize.onRender;
        current2 = null === current2 ? "mount" : "update";
        currentUpdateIsNested && (current2 = "nested-update");
        "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
          id,
          current2,
          finishedWork.actualDuration,
          finishedWork.treeBaseDuration,
          finishedWork.actualStartTime,
          commitStartTime2
        );
        "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
      }
      function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
        var _finishedWork$memoize2 = finishedWork.memoizedProps;
        finishedWork = _finishedWork$memoize2.id;
        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
        current2 = null === current2 ? "mount" : "update";
        currentUpdateIsNested && (current2 = "nested-update");
        "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
          finishedWork,
          current2,
          passiveEffectDuration,
          commitStartTime2
        );
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          runWithFiberInDEV(
            finishedWork,
            commitMount,
            instance,
            type,
            props,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          runWithFiberInDEV(
            finishedWork,
            commitUpdate,
            finishedWork.stateNode,
            finishedWork.type,
            oldProps,
            newProps,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitPlacement(finishedWork) {
        for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
          if (isHostParent(parentFiber)) {
            hostParentFiber = parentFiber;
            break;
          }
          parentFiber = parentFiber.return;
        }
        if (null == hostParentFiber)
          throw Error(
            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
          );
        switch (hostParentFiber.tag) {
          case 27:
            hostParentFiber = hostParentFiber.stateNode;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(
              finishedWork,
              parentFiber,
              hostParentFiber
            );
            break;
          case 5:
            parentFiber = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
            hostParentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(
              finishedWork,
              hostParentFiber,
              parentFiber
            );
            break;
          case 3:
          case 4:
            hostParentFiber = hostParentFiber.stateNode.containerInfo;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              parentFiber,
              hostParentFiber
            );
            break;
          default:
            throw Error(
              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
            );
        }
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          runWithFiberInDEV(
            finishedWork,
            acquireSingletonInstance,
            finishedWork.type,
            props,
            singleton,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHydratingParent(current2, finishedWork) {
        return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
      }
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$2) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = {
          focusedElem: root2,
          selectionRange: JSCompiler_temp
        };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              root2 = firstChild = nextEffect;
              JSCompiler_temp = root2.alternate;
              anchorOffset = root2.flags;
              switch (root2.tag) {
                case 0:
                  if (0 !== (anchorOffset & 4) && (root2 = root2.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                      anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                  break;
                case 3:
                  if (0 !== (anchorOffset & 1024)) {
                    if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (anchorOffset & 1024))
                    throw Error(
                      "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                    );
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current2)
                finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                  finishedWork,
                  callComponentDidMountInDEV,
                  finishedWork,
                  finishedRoot
                ), recordEffectDuration()) : runWithFiberInDEV(
                  finishedWork,
                  callComponentDidMountInDEV,
                  finishedWork,
                  finishedRoot
                );
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current2.memoizedProps
                );
                current2 = current2.memoizedState;
                finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ));
                shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                  finishedWork,
                  callComponentDidUpdateInDEV,
                  finishedWork,
                  finishedRoot,
                  prevProps,
                  current2,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                ), recordEffectDuration()) : runWithFiberInDEV(
                  finishedWork,
                  callComponentDidUpdateInDEV,
                  finishedWork,
                  finishedRoot,
                  prevProps,
                  current2,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            current2 = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
              prevProps = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    prevProps = finishedWork.child.stateNode;
                    break;
                  case 1:
                    prevProps = finishedWork.child.stateNode;
                }
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitCallbacks,
                  flags,
                  prevProps
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            finishedRoot.effectDuration += popNestedEffectDurations(current2);
            break;
          case 27:
            null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (null === current2) {
              if (flags & 4) commitHostMount(finishedWork);
              else if (flags & 64) {
                finishedRoot = finishedWork.type;
                current2 = finishedWork.memoizedProps;
                prevProps = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedInstance,
                    prevProps,
                    finishedRoot,
                    current2,
                    finishedWork
                  );
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error
                  );
                }
              }
            }
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            if (flags & 4) {
              flags = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              finishedRoot = finishedWork.stateNode;
              finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfiler,
                  finishedWork,
                  current2,
                  commitStartTime,
                  finishedRoot.effectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, flags))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
          finishedWork.return.alternate,
          finishedWork.return
        ) || logComponentTrigger(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          "Mount"
        )));
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber._debugOwner = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(
            finishedRoot,
            nearestMountedAncestor,
            parent
          ), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
          }
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            runWithFiberInDEV(
              deletedFiber,
              releaseSingletonInstance,
              deletedFiber.stateNode
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  runWithFiberInDEV(
                    deletedFiber,
                    removeChildFromContainer,
                    hostParent,
                    deletedFiber.stateNode
                  );
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  runWithFiberInDEV(
                    deletedFiber,
                    removeChild,
                    hostParent,
                    deletedFiber.stateNode
                  );
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(
              Insertion,
              deletedFiber,
              nearestMountedAncestor
            );
            offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
              deletedFiber,
              nearestMountedAncestor,
              Layout
            );
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
        (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          deletedFiber,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitHydratedActivityInstance,
              finishedRoot
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            runWithFiberInDEV(
              finishedWork,
              commitHydratedSuspenseInstance,
              finishedRoot
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(
              "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
            );
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            if (isDevToolsPresent)
              if (null !== inProgressLanes && null !== inProgressRoot)
                restorePendingUpdaters(inProgressRoot, inProgressLanes);
              else
                throw Error(
                  "Expected finished root and lanes to be set. This is a bug in React."
                );
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent)
              throw Error(
                "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
              );
            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
            (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              deletedFiber,
              componentEffectStartTime,
              componentEffectEndTime,
              "Unmount"
            );
            popComponentEffectStart(prevEffectStart);
            root2 = deletedFiber;
            returnFiber = root2.alternate;
            null !== returnFiber && (returnFiber.return = null);
            root2.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(
              Insertion | HasEffect,
              finishedWork,
              finishedWork.return
            ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout | HasEffect
            ));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
              var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
              flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
            }
            break;
          case 26:
            existingHiddenCallbacks = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            if (flags & 4) {
              var currentResource = null !== current2 ? current2.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current2)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current2 = finishedWork.memoizedProps;
                      existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                      b: switch (flags) {
                        case "title":
                          currentResource = existingHiddenCallbacks.getElementsByTagName(
                            "title"
                          )[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                            currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                              currentResource,
                              existingHiddenCallbacks.querySelector(
                                "head > title"
                              )
                            );
                          setInitialProperties(currentResource, flags, current2);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            existingHiddenCallbacks
                          ).get(flags + (current2.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = existingHiddenCallbacks.createElement(flags);
                          setInitialProperties(currentResource, flags, current2);
                          existingHiddenCallbacks.head.appendChild(
                            currentResource
                          );
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            existingHiddenCallbacks
                          ).get(flags + (current2.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], checkAttributeStringCoercion(
                                current2.content,
                                "content"
                              ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = existingHiddenCallbacks.createElement(flags);
                          setInitialProperties(currentResource, flags, current2);
                          existingHiddenCallbacks.head.appendChild(
                            currentResource
                          );
                          break;
                        default:
                          throw Error(
                            'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                          );
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      existingHiddenCallbacks,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                  existingHiddenCallbacks,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  existingHiddenCallbacks,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current2.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            null !== current2 && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current2.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            if (finishedWork.flags & 32) {
              existingHiddenCallbacks = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  resetTextContent,
                  existingHiddenCallbacks
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              existingHiddenCallbacks,
              null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
            ));
            flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
              "Unexpected host component type. Expected a form. This is a bug in React."
            ));
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(
                  "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                );
              flags = finishedWork.memoizedProps;
              current2 = null !== current2 ? current2.memoizedProps : flags;
              existingHiddenCallbacks = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitTextUpdate,
                  existingHiddenCallbacks,
                  current2,
                  flags
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            existingHiddenCallbacks = pushNestedEffectDurations();
            tagCaches = null;
            currentResource = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = currentResource;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitHydratedContainer,
                  root2.containerInfo
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            root2.effectDuration += popNestedEffectDurations(
              existingHiddenCallbacks
            );
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            flags = pushNestedEffectDurations();
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            existingHiddenCallbacks = null !== finishedWork.memoizedState;
            var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime
            );
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = existingHiddenCallbacks ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )), current2 = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current2) {
                    wasHidden = current2 = root2;
                    try {
                      currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                        wasHidden,
                        hideInstance,
                        currentResource
                      ) : runWithFiberInDEV(
                        wasHidden,
                        unhideInstance,
                        wasHidden.stateNode,
                        wasHidden.memoizedProps
                      );
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current2) {
                    wasHidden = root2;
                    try {
                      maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                        wasHidden,
                        hideTextInstance,
                        maybeNodes
                      ) : runWithFiberInDEV(
                        wasHidden,
                        unhideTextInstance,
                        maybeNodes,
                        wasHidden.memoizedProps
                      );
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (18 === root2.tag) {
                  if (null === current2) {
                    wasHidden = root2;
                    try {
                      i = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                        wasHidden,
                        hideDehydratedBoundary,
                        i
                      ) : runWithFiberInDEV(
                        wasHidden,
                        unhideDehydratedBoundary,
                        wasHidden.stateNode
                      );
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork)
                    break a;
                  current2 === root2 && (current2 = null);
                  root2 = root2.return;
                }
                current2 === root2 && (current2 = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
          finishedWork.return.alternate,
          finishedWork.return
        ) || logComponentTrigger(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          "Mount"
        )));
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function disappearLayoutEffects(finishedWork) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            runWithFiberInDEV(
              finishedWork,
              releaseSingletonInstance,
              finishedWork.stateNode
            );
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
      }
      function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookLayoutEffects(finishedWork, Layout);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current2 = finishedWork.stateNode;
            "function" === typeof current2.componentDidMount && runWithFiberInDEV(
              finishedWork,
              callComponentDidMountInDEV,
              finishedWork,
              current2
            );
            current2 = finishedWork.updateQueue;
            if (null !== current2) {
              finishedRoot = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitHiddenCallbacks,
                  current2,
                  finishedRoot
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            if (includeWorkInProgressEffects && flags & 4) {
              flags = pushNestedEffectDurations();
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects = finishedWork.stateNode;
              includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfiler,
                  finishedWork,
                  current2,
                  commitStartTime,
                  includeWorkInProgressEffects.effectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          reappearLayoutEffects(
            finishedRoot,
            parentFiber.alternate,
            parentFiber,
            includeWorkInProgressEffects
          ), parentFiber = parentFiber.sibling;
      }
      function commitOffscreenPassiveMountEffects(current2, finishedWork) {
        var previousCache = null;
        null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
        current2 = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
        current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current2, finishedWork) {
        current2 = null;
        null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
        if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              inHydratedSubtree,
              committedLanes
            );
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
            break;
          case 1:
            (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              []
            ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              inHydratedSubtree,
              committedLanes
            ));
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            break;
          case 3:
            var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
            inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            inHydratedSubtree = wasInHydratedSubtree;
            flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
            finishedRoot.passiveEffectDuration += popNestedEffectDurations(
              prevProfilerEffectDuration
            );
            break;
          case 12:
            if (flags & 2048) {
              flags = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              finishedRoot = finishedWork.stateNode;
              finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfilerPostCommitImpl,
                  finishedWork,
                  finishedWork.alternate,
                  commitStartTime,
                  finishedRoot.passiveEffectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
            break;
          case 31:
            flags = inHydratedSubtree;
            prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
            wasInHydratedSubtree = finishedWork.memoizedState;
            null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              prevProfilerEffectDuration
            )) : inHydratedSubtree = true) : inHydratedSubtree = false;
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            inHydratedSubtree = flags;
            break;
          case 13:
            flags = inHydratedSubtree;
            prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
            wasInHydratedSubtree = finishedWork.memoizedState;
            null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              prevProfilerEffectDuration
            )) : inHydratedSubtree = true);
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            inHydratedSubtree = flags;
            break;
          case 23:
            break;
          case 22:
            wasInHydratedSubtree = finishedWork.stateNode;
            prevProfilerEffectDuration = finishedWork.alternate;
            null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
              endTime
            ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime
            )));
            flags & 2048 && commitOffscreenPassiveMountEffects(
              prevProfilerEffectDuration,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
        }
        if ((finishedWork.mode & ProfileMode) !== NoMode) {
          if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
            committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
              finishedWork,
              committedLanes,
              endTime,
              "Mount"
            );
          0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          ));
        }
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        alreadyWarnedForDeepEquality = prevDeepEquality;
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var nextSibling = parentFiber.sibling;
          reconnectPassiveEffects(
            finishedRoot,
            parentFiber,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            null !== nextSibling ? nextSibling.actualStartTime : endTime
          );
          parentFiber = nextSibling;
        }
      }
      function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
        includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
          finishedWork,
          finishedWork.actualStartTime,
          endTime,
          inHydratedSubtree,
          committedLanes
        );
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            );
            commitHookPassiveMountEffects(finishedWork, Passive);
            break;
          case 23:
            break;
          case 22:
            var _instance2 = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            );
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectErrors = prevEffectErrors;
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        alreadyWarnedForDeepEquality = prevDeepEquality;
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
        if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
          for (var child = parentFiber.child; null !== child; ) {
            parentFiber = child.sibling;
            var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
            (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
              child,
              child.actualStartTime,
              endTime,
              inHydratedSubtree,
              committedLanes
            );
            var flags = child.flags;
            switch (child.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  child,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  child,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  child,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
            }
            alreadyWarnedForDeepEquality = prevDeepEquality;
            child = parentFiber;
          }
      }
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              fiber.stateNode.containerInfo
            );
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
              (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                childToDelete,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive | HasEffect
            );
            break;
          case 3:
            var prevProfilerEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
            break;
          case 12:
            prevProfilerEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
            break;
          case 22:
            prevProfilerEffectDuration = finishedWork.stateNode;
            null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Disconnect"
            )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
              (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                childToDelete,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
      }
      function disconnectPassiveEffect(finishedWork) {
        var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive
            );
            recursivelyTraverseDisconnectPassiveEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        }
        (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (current2.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                current2,
                nearestMountedAncestor,
                Passive
              );
              break;
            case 23:
            case 22:
              null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
              break;
            case 24:
              releaseCache(current2.memoizedState.cache);
          }
          (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            current2,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
          current2 = fiber.child;
          if (null !== current2) current2.return = fiber, nextEffect = current2;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              current2 = nextEffect;
              prevEffectStart = current2.sibling;
              prevEffectDuration = current2.return;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== prevEffectStart) {
                prevEffectStart.return = prevEffectDuration;
                nextEffect = prevEffectStart;
                break a;
              }
              nextEffect = prevEffectDuration;
            }
        }
      }
      function onCommitRoot() {
        commitHooks.forEach(function(commitHook) {
          return commitHook();
        });
      }
      function isConcurrentActEnvironment() {
        var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
          "The current testing environment is not configured to support act(...)"
        );
        return isReactActEnvironmentGlobal;
      }
      function requestUpdateLane(fiber) {
        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        var transition = ReactSharedInternals.T;
        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
        if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if ((executionContext & RenderContext) !== NoContext && root2 === workInProgressRoot) {
          if (isRendering)
            switch (fiber.tag) {
              case 0:
              case 11:
              case 15:
                root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  fiber,
                  root2,
                  root2
                ));
                break;
              case 1:
                didWarnAboutUpdateInRender || (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ), didWarnAboutUpdateInRender = true);
            }
        } else
          isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root2, lanes, forceSync) {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
          var yieldedFiber = workInProgress, yieldEndTime = now$1();
          switch (yieldReason) {
            case SuspendedOnImmediate:
            case SuspendedOnData:
              var startTime = yieldStartTime;
              supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                console.timeStamp.bind(
                  console,
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                )
              ) : console.timeStamp(
                "Suspended",
                startTime,
                yieldEndTime,
                COMPONENTS_TRACK,
                void 0,
                "primary-light"
              ));
              break;
            case SuspendedOnAction:
              startTime = yieldStartTime;
              supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                console.timeStamp.bind(
                  console,
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                )
              ) : console.timeStamp(
                "Action",
                startTime,
                yieldEndTime,
                COMPONENTS_TRACK,
                void 0,
                "primary-light"
              ));
              break;
            default:
              supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                "Blocked",
                yieldStartTime,
                yieldEndTime,
                COMPONENTS_TRACK,
                void 0,
                5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
              ));
          }
        }
        startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes)) ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
        var renderWasConcurrent = forceSync;
        do {
          if (startTime === RootInProgress) {
            workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root2, lanes, 0, false);
            lanes = workInProgressSuspendedReason;
            yieldStartTime = now();
            yieldReason = lanes;
            break;
          } else {
            yieldedFiber = now$1();
            yieldEndTime = root2.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
              setCurrentTrackFromLanes(lanes);
              yieldEndTime = renderStartTime;
              startTime = yieldedFiber;
              !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                )
              ) : console.timeStamp(
                "Teared Render",
                yieldEndTime,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "error"
              ));
              finalizeRender(lanes, yieldedFiber);
              startTime = renderRootSync(root2, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (startTime === RootErrored) {
              renderWasConcurrent = lanes;
              if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                var errorRetryLanes = 0;
              else
                errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
              if (0 !== errorRetryLanes) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                lanes = errorRetryLanes;
                a: {
                  yieldedFiber = root2;
                  startTime = renderWasConcurrent;
                  renderWasConcurrent = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                  errorRetryLanes = renderRootSync(
                    yieldedFiber,
                    errorRetryLanes,
                    false
                  );
                  if (errorRetryLanes !== RootErrored) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                      workInProgressRootInterleavedUpdatedLanes |= startTime;
                      startTime = RootSuspendedWithDelay;
                      break a;
                    }
                    yieldedFiber = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = renderWasConcurrent;
                    null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      yieldedFiber
                    ));
                  }
                  startTime = errorRetryLanes;
                }
                renderWasConcurrent = false;
                if (startTime !== RootErrored) continue;
                else yieldedFiber = now$1();
              }
            }
            if (startTime === RootFatalErrored) {
              setCurrentTrackFromLanes(lanes);
              logErroredRenderPhase(
                renderStartTime,
                yieldedFiber,
                lanes,
                workInProgressUpdateTask
              );
              finalizeRender(lanes, yieldedFiber);
              prepareFreshStack(root2, 0);
              markRootSuspended(root2, lanes, 0, true);
              break;
            }
            a: {
              forceSync = root2;
              switch (startTime) {
                case RootInProgress:
                case RootFatalErrored:
                  throw Error("Root did not complete. This is a bug in React.");
                case RootSuspendedWithDelay:
                  if ((lanes & 4194048) !== lanes) break;
                case RootSuspendedAtTheShell:
                  setCurrentTrackFromLanes(lanes);
                  logSuspendedRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  yieldEndTime = lanes;
                  0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                  markRootSuspended(
                    forceSync,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case RootErrored:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case RootSuspended:
                case RootCompleted:
                  break;
                default:
                  throw Error("Unknown root exit status.");
              }
              if (null !== ReactSharedInternals.actQueue)
                commitRoot(
                  forceSync,
                  yieldEndTime,
                  lanes,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  startTime,
                  null,
                  null,
                  renderStartTime,
                  yieldedFiber
                );
              else {
                if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                  markRootSuspended(
                    forceSync,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  if (0 !== getNextLanes(forceSync, 0, true)) break a;
                  pendingEffectsLanes = lanes;
                  forceSync.timeoutHandle = scheduleTimeout(
                    commitRootWhenReady.bind(
                      null,
                      forceSync,
                      yieldEndTime,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      lanes,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes,
                      workInProgressRootDidSkipSuspendedSiblings,
                      startTime,
                      "Throttled",
                      renderStartTime,
                      yieldedFiber
                    ),
                    renderWasConcurrent
                  );
                  break a;
                }
                commitRootWhenReady(
                  forceSync,
                  yieldEndTime,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  startTime,
                  null,
                  renderStartTime,
                  yieldedFiber
                );
              }
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root2);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = noTimeout;
        var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
          if (suspendedState = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$1
          }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
            pendingEffectsLanes = lanes;
            root2.cancelPendingCommit = subtreeFlags(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedState,
                suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(
              root2,
              lanes,
              spawnedLane,
              !didSkipSuspendedSiblings
            );
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          suspendedState,
          suspendedCommitReason,
          completedRenderStartTime,
          completedRenderEndTime
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index;
          didAttemptEntireTree[index] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (workInProgressSuspendedReason === NotSuspended)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function finalizeRender(lanes, finalizationTime) {
        0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
        0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
        0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
        0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
      }
      function prepareFreshStack(root2, lanes) {
        supportsUserTiming && (console.timeStamp(
          "Blocking Track",
          3e-3,
          3e-3,
          "Blocking",
          LANES_TRACK_GROUP,
          "primary-light"
        ), console.timeStamp(
          "Transition Track",
          3e-3,
          3e-3,
          "Transition",
          LANES_TRACK_GROUP,
          "primary-light"
        ), console.timeStamp(
          "Suspense Track",
          3e-3,
          3e-3,
          "Suspense",
          LANES_TRACK_GROUP,
          "primary-light"
        ), console.timeStamp(
          "Idle Track",
          3e-3,
          3e-3,
          "Idle",
          LANES_TRACK_GROUP,
          "primary-light"
        ));
        var previousRenderStartTime = renderStartTime;
        renderStartTime = now();
        if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
          setCurrentTrackFromLanes(workInProgressRootRenderLanes);
          if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
            logSuspendedRenderPhase(
              previousRenderStartTime,
              renderStartTime,
              lanes,
              workInProgressUpdateTask
            );
          else {
            var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
            if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
              var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
              debugTask ? debugTask.run(
                console.timeStamp.bind(
                  console,
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                )
              ) : console.timeStamp(
                label,
                previousRenderStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              );
            }
          }
          finalizeRender(workInProgressRootRenderLanes, renderStartTime);
        }
        previousRenderStartTime = workInProgressUpdateTask;
        workInProgressUpdateTask = null;
        if (0 !== (lanes & 127)) {
          workInProgressUpdateTask = blockingUpdateTask;
          debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
          endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
          color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
          0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
            blockingSuspendedTime,
            color,
            lanes,
            previousRenderStartTime
          )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
          previousRenderStartTime = debugTask;
          var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
          debugTask = renderStartTime;
          endTime = blockingUpdateTask;
          color = blockingUpdateMethodName;
          label = blockingUpdateComponentName;
          if (supportsUserTiming) {
            currentTrack = "Blocking";
            0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
            0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
            if (null !== eventType && previousRenderStartTime > eventTime) {
              var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
              endTime ? endTime.run(
                console.timeStamp.bind(
                  console,
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                )
              ) : console.timeStamp(
                eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                eventTime,
                previousRenderStartTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color$jscomp$0
              );
            }
            debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
              start: previousRenderStartTime,
              end: debugTask,
              detail: {
                devtools: {
                  properties: isPingedUpdate,
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  color: eventTime
                }
              }
            }, endTime ? endTime.run(
              performance.measure.bind(
                performance,
                isSpawnedUpdate,
                previousRenderStartTime
              )
            ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
          }
          blockingUpdateTime = -1.1;
          blockingUpdateType = 0;
          blockingUpdateComponentName = blockingUpdateMethodName = null;
          blockingSuspendedTime = -1.1;
          blockingEventRepeatTime = blockingEventTime;
          blockingEventTime = -1.1;
          blockingClampTime = now();
        }
        0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
          transitionSuspendedTime,
          color,
          lanes,
          workInProgressUpdateTask
        )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
          console.timeStamp.bind(
            console,
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )
        ) : console.timeStamp(
          eventType ? "Consecutive" : "Event: " + eventTime,
          isPingedUpdate,
          debugTask,
          currentTrack,
          LANES_TRACK_GROUP,
          color$jscomp$0
        )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
          console.timeStamp.bind(
            console,
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )
        ) : console.timeStamp(
          "Action",
          debugTask,
          previousRenderStartTime,
          currentTrack,
          LANES_TRACK_GROUP,
          "primary-dark"
        )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
          start: previousRenderStartTime,
          end: color,
          detail: {
            devtools: {
              properties: isPingedUpdate,
              track: currentTrack,
              trackGroup: LANES_TRACK_GROUP,
              color: "primary-light"
            }
          }
        }, endTime ? endTime.run(
          performance.measure.bind(
            performance,
            debugTask,
            previousRenderStartTime
          )
        ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
        0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
        0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
        previousRenderStartTime = root2.timeoutHandle;
        previousRenderStartTime !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
        previousRenderStartTime = root2.cancelPendingCommit;
        null !== previousRenderStartTime && (root2.cancelPendingCommit = null, previousRenderStartTime());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = previousRenderStartTime = createWorkInProgress(
          root2.current,
          null
        );
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = NotSuspended;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        endTime = root2.entangledLanes;
        if (0 !== endTime)
          for (root2 = root2.entanglements, endTime &= lanes; 0 < endTime; )
            debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root2[debugTask], endTime &= ~color;
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        root2 = getCurrentTime();
        1e3 < root2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root2);
        ReactStrictModeWarnings.discardPendingWarnings();
        return previousRenderStartTime;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        ReactSharedInternals.getCurrentStack = null;
        isRendering = false;
        current = null;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
        workInProgressThrownValue = thrownValue;
        var erroredWork = workInProgress;
        null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function markRenderDerivedCause(fiber) {
        null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = RootSuspendedWithDelay;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root2.memoizedUpdaters;
            0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
            movePendingFibersToMemoized(root2, lanes);
          }
          workInProgressTransitions = null;
          prepareFreshStack(root2, lanes);
        }
        lanes = false;
        memoizedUpdaters = workInProgressRootExitStatus;
        a: do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$8) {
            handleThrow(root2, thrownValue$8);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        resetContextDependencies();
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return memoizedUpdaters;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root2.memoizedUpdaters;
            0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
            movePendingFibersToMemoized(root2, lanes);
          }
          workInProgressTransitions = null;
          workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
          prepareFreshStack(root2, lanes);
        } else
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
            root2,
            lanes
          );
        a: do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
              b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                case SuspendedOnError:
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root2,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnError
                  );
                  break;
                case SuspendedOnData:
                case SuspendedOnAction:
                  if (isThenableResolved(memoizedUpdaters)) {
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                    ensureRootIsScheduled(root2);
                  };
                  memoizedUpdaters.then(lanes, lanes);
                  break a;
                case SuspendedOnImmediate:
                  workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                  break a;
                case SuspendedOnInstance:
                  workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                  break a;
                case SuspendedAndReadyToContinue:
                  isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                    root2,
                    lanes,
                    memoizedUpdaters,
                    SuspendedAndReadyToContinue
                  ));
                  break;
                case SuspendedOnInstanceAndReadyToContinue:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                        workInProgressSuspendedReason = NotSuspended;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                      break;
                    default:
                      console.error(
                        "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                      );
                  }
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root2,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnInstanceAndReadyToContinue
                  );
                  break;
                case SuspendedOnDeprecatedThrowPromise:
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root2,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnDeprecatedThrowPromise
                  );
                  break;
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = RootSuspendedAtTheShell;
                  break a;
                default:
                  throw Error(
                    "Unexpected SuspendedReason. This is a bug in React."
                  );
              }
            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$9) {
            handleThrow(root2, thrownValue$9);
          }
        while (1);
        resetContextDependencies();
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return RootInProgress;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
          unitOfWork,
          beginWork,
          current2,
          unitOfWork,
          entangledRenderLanes
        ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
          unitOfWork,
          beginWork,
          current2,
          unitOfWork,
          entangledRenderLanes
        );
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replayBeginWork(unitOfWork) {
        var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
        isProfilingMode && startProfilerTimer(unitOfWork);
        switch (unitOfWork.tag) {
          case 15:
          case 0:
            current2 = replayFunctionComponent(
              current2,
              unitOfWork,
              unitOfWork.pendingProps,
              unitOfWork.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            current2 = replayFunctionComponent(
              current2,
              unitOfWork,
              unitOfWork.pendingProps,
              unitOfWork.type.render,
              unitOfWork.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(unitOfWork);
          default:
            unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
        }
        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
        return current2;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        resetContextDependencies();
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          var current2 = completedWork.alternate;
          unitOfWork = completedWork.return;
          startProfilerTimer(completedWork);
          current2 = runWithFiberInDEV(
            completedWork,
            completeWork,
            current2,
            completedWork,
            entangledRenderLanes
          );
          (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
          if (null !== current2) {
            workInProgress = current2;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
            next = unitOfWork.actualDuration;
            for (var child = unitOfWork.child; null !== child; )
              next += child.actualDuration, child = child.sibling;
            unitOfWork.actualDuration = next;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = RootSuspendedAtTheShell;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
        ReactStrictModeWarnings.flushLegacyContextWarning();
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        setCurrentTrackFromLanes(lanes);
        exitStatus === RootErrored ? logErroredRenderPhase(
          completedRenderStartTime,
          completedRenderEndTime,
          lanes,
          workInProgressUpdateTask
        ) : null !== recoverableErrors ? logRecoveredRenderPhase(
          completedRenderStartTime,
          completedRenderEndTime,
          lanes,
          recoverableErrors,
          null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
          workInProgressUpdateTask
        ) : logRenderPhase(
          completedRenderStartTime,
          completedRenderEndTime,
          lanes,
          workInProgressUpdateTask
        );
        if (null !== finishedWork) {
          0 === lanes && console.error(
            "finishedLanes should not be empty during a commit. This is a bug in React."
          );
          if (finishedWork === root2.current)
            throw Error(
              "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
            );
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          pendingEffectsRenderEndTime = completedRenderEndTime;
          pendingSuspendedCommitReason = suspendedCommitReason;
          pendingDelayedCommitReason = IMMEDIATE_COMMIT;
          pendingSuspendedViewTransitionReason = null;
          0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            schedulerEvent = window.event;
            pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
            flushPassiveEffects();
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          commitErrors = null;
          commitStartTime = now();
          null !== suspendedCommitReason && logSuspendedCommitPhase(
            completedRenderEndTime,
            commitStartTime,
            suspendedCommitReason,
            workInProgressUpdateTask
          );
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = DiscreteEventPriority;
            spawnedLane = executionContext;
            executionContext |= CommitContext;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = PENDING_MUTATION_PHASE;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = DiscreteEventPriority;
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            try {
              inProgressLanes = lanes;
              inProgressRoot = root2;
              resetComponentEffectTimers();
              commitMutationEffectsOnFiber(finishedWork, root2);
              inProgressRoot = inProgressLanes = null;
              lanes = selectionInformation;
              var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                        priorSelectionRange.start,
                        length
                      ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = PENDING_LAYOUT_PHASE;
        }
      }
      function flushLayoutEffects() {
        if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
          if (null !== suspendedViewTransitionReason) {
            commitStartTime = now();
            var startTime = commitEndTime, endTime = commitStartTime;
            !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
              console.timeStamp.bind(
                console,
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              )
            ) : console.timeStamp(
              suspendedViewTransitionReason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            ));
          }
          suspendedViewTransitionReason = pendingEffectsRoot;
          startTime = pendingFinishedWork;
          endTime = pendingEffectsLanes;
          var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
          if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var _previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = DiscreteEventPriority;
            var _prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            try {
              inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                suspendedViewTransitionReason,
                startTime.alternate,
                startTime
              ), inProgressRoot = inProgressLanes = null;
            } finally {
              executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          suspendedViewTransitionReason = pendingEffectsRenderEndTime;
          startTime = pendingSuspendedCommitReason;
          commitEndTime = now();
          suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
          startTime = commitEndTime;
          endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
          rootHasLayoutEffect = workInProgressUpdateTask;
          null !== commitErrors ? logCommitErrored(
            suspendedViewTransitionReason,
            startTime,
            commitErrors,
            false,
            rootHasLayoutEffect
          ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
            console.timeStamp.bind(
              console,
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            )
          ) : console.timeStamp(
            endTime ? "Commit Interrupted View Transition" : "Commit",
            suspendedViewTransitionReason,
            startTime,
            currentTrack,
            LANES_TRACK_GROUP,
            endTime ? "error" : "secondary-dark"
          ));
          pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
        }
      }
      function flushSpawnedWork() {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
            var startViewTransitionStartTime = commitEndTime;
            commitEndTime = now();
            var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
              console.timeStamp.bind(
                console,
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? "error" : "secondary-light"
              )
            ) : console.timeStamp(
              abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
              startViewTransitionStartTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              abortedViewTransition ? " error" : "secondary-light"
            ));
            pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
          }
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          requestPaint();
          startViewTransitionStartTime = pendingEffectsRoot;
          var finishedWork = pendingFinishedWork;
          endTime = pendingEffectsLanes;
          abortedViewTransition = pendingRecoverableErrors;
          var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
          rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
            startViewTransitionStartTime,
            startViewTransitionStartTime.pendingLanes
          ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
          var remainingLanes = startViewTransitionStartTime.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
          remainingLanes = lanesToEventPriority(endTime);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              var didError = 128 === (finishedWork.current.flags & 128);
              switch (remainingLanes) {
                case DiscreteEventPriority:
                  var schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority$1;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority$1;
              }
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                schedulerPriority,
                didError
              );
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
          onCommitRoot();
          if (null !== abortedViewTransition) {
            didError = ReactSharedInternals.T;
            schedulerPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = DiscreteEventPriority;
            ReactSharedInternals.T = null;
            try {
              var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
              for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                runWithFiberInDEV(
                  recoverableError.source,
                  onRecoverableError,
                  recoverableError.value,
                  errorInfo
                );
              }
            } finally {
              ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(startViewTransitionStartTime);
          remainingLanes = startViewTransitionStartTime.pendingLanes;
          0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
          rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function makeErrorInfo(componentStack) {
        componentStack = { componentStack };
        Object.defineProperty(componentStack, "digest", {
          get: function() {
            console.error(
              'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
            );
          }
        });
        return componentStack;
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
        renderPriority = ReactSharedInternals.T;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = priority;
          ReactSharedInternals.T = null;
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          priority = pendingEffectsRoot;
          var lanes = pendingEffectsLanes;
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Cannot flush passive effects while already rendering.");
          setCurrentTrackFromLanes(lanes);
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
          var passiveEffectStartTime = 0;
          commitErrors = null;
          passiveEffectStartTime = now$1();
          if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
            logAnimatingPhase(
              commitEndTime,
              passiveEffectStartTime,
              animatingTask
            );
          else {
            var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
            !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
              console.timeStamp.bind(
                console,
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              )
            ) : console.timeStamp(
              delayedUntilPaint ? "Waiting for Paint" : "Waiting",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            ));
          }
          startTime = executionContext;
          executionContext |= CommitContext;
          var finishedWork = priority.current;
          resetComponentEffectTimers();
          commitPassiveUnmountOnFiber(finishedWork);
          var finishedWork$jscomp$0 = priority.current;
          finishedWork = pendingEffectsRenderEndTime;
          resetComponentEffectTimers();
          commitPassiveMountOnFiber(
            priority,
            finishedWork$jscomp$0,
            lanes,
            transitions,
            finishedWork
          );
          commitDoubleInvokeEffectsInDEV(priority);
          executionContext = startTime;
          var passiveEffectsEndTime = now$1();
          finishedWork$jscomp$0 = passiveEffectStartTime;
          finishedWork = workInProgressUpdateTask;
          null !== commitErrors ? logCommitErrored(
            finishedWork$jscomp$0,
            passiveEffectsEndTime,
            commitErrors,
            true,
            finishedWork
          ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
            console.timeStamp.bind(
              console,
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Remaining Effects",
            finishedWork$jscomp$0,
            passiveEffectsEndTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
          finalizeRender(lanes, passiveEffectsEndTime);
          flushSyncWorkAcrossRoots_impl(0, false);
          didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
          didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, priority);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var stateNode = priority.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        recordEffectError(sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        isRunningInsertionEffect = false;
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else {
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              return;
            }
            if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                recordEffectError(sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                return;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
          console.error(
            "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
            error
          );
        }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
        );
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(
              "Pinged unknown suspense boundary type. This is probably a bug in React."
            );
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
        if (0 !== (parentFiber.subtreeFlags & 67117056))
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
            isStrictModeFiber = isInStrictMode || isStrictModeFiber;
            22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
              fiber,
              doubleInvokeEffectsOnFiber,
              root2,
              fiber
            ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
              root2,
              fiber,
              isStrictModeFiber
            ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
              fiber,
              doubleInvokeEffectsOnFiber,
              root2,
              fiber
            ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
              fiber,
              recursivelyTraverseAndDoubleInvokeEffectsInDEV,
              root2,
              fiber,
              isStrictModeFiber
            ));
            parentFiber = parentFiber.sibling;
          }
      }
      function doubleInvokeEffectsOnFiber(root2, fiber) {
        setIsStrictModeForDevtools(true);
        try {
          disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      function commitDoubleInvokeEffectsInDEV(root2) {
        var doubleInvokeEffects = true;
        root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
        recursivelyTraverseAndDoubleInvokeEffectsInDEV(
          root2,
          root2.current,
          doubleInvokeEffects
        );
      }
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        if ((executionContext & RenderContext) === NoContext) {
          var tag = fiber.tag;
          if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
            tag = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (null !== didWarnStateUpdateForNotYetMountedComponent) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
              didWarnStateUpdateForNotYetMountedComponent.add(tag);
            } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
            runWithFiberInDEV(fiber, function() {
              console.error(
                "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
              );
            });
          }
        }
      }
      function restorePendingUpdaters(root2, lanes) {
        isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
          addFiberToLanesMap(root2, schedulingFiber, lanes);
        });
      }
      function scheduleCallback$1(priorityLevel, callback) {
        var actQueue = ReactSharedInternals.actQueue;
        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
          console.error(
            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
            getComponentNameFromFiber(fiber)
          );
        });
      }
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root2 = firstScheduledRoot; null !== root2; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root2.pendingLanes;
                  if (0 === pendingLanes) var nextLanes = 0;
                  else {
                    var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                    nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                  }
                  0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                } else
                  nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                    root2,
                    root2 === workInProgressRoot ? nextLanes : 0,
                    null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                  ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
              root2 = root2.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        schedulerEvent = window.event;
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
            cancelCallback(pingedLanes);
          else return currentTime;
          switch (lanesToEventPriority(suspendedLanes)) {
            case DiscreteEventPriority:
            case ContinuousEventPriority:
              suspendedLanes = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              suspendedLanes = NormalPriority$1;
              break;
            case IdleEventPriority:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && cancelCallback(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        nestedUpdateScheduled = currentUpdateIsNested = false;
        schedulerEvent = window.event;
        if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
        if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(
          root2,
          workInProgressRootRenderLanes$jscomp$0,
          didTimeout
        );
        scheduleTaskForRootDuringMicrotask(root2, now$1());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        currentUpdateIsNested = nestedUpdateScheduled;
        nestedUpdateScheduled = false;
        performWorkOnRoot(root2, lanes, true);
      }
      function cancelCallback(callbackNode) {
        callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
      }
      function scheduleImmediateRootScheduleTask() {
        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
          processRootScheduleInMicrotask();
          return null;
        });
        scheduleMicrotask(function() {
          (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
          return null;
        if ("function" === typeof actionProp) return actionProp;
        checkAttributeStringCoercion(actionProp, "action");
        return sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      };
                      Object.freeze(pendingState);
                      startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                      nativeEventTarget,
                      submitter
                    ) : new FormData(nativeEventTarget), pendingState = {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    }, Object.freeze(pendingState), startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      function executeDispatch(event, listener, currentTarget) {
        event.currentTarget = currentTarget;
        try {
          listener(event);
        } catch (error) {
          reportGlobalError(error);
        }
        event.currentTarget = null;
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i];
          a: {
            var previousInstance = void 0, event = _dispatchQueue$i.event;
            _dispatchQueue$i = _dispatchQueue$i.listeners;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                null !== instance ? runWithFiberInDEV(
                  instance,
                  executeDispatch,
                  event,
                  _dispatchListeners$i,
                  currentTarget
                ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                null !== instance ? runWithFiberInDEV(
                  instance,
                  executeDispatch,
                  event,
                  _dispatchListeners$i,
                  currentTarget
                ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        nonDelegatedEvents.has(domEventName) || console.error(
          'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
          domEventName
        );
        var listenerSet = targetElement[internalEventHandlersKey];
        void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
          'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
          domEventName
        );
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case DiscreteEventPriority:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(
          domEventName,
          eventSystemFlags,
          false
        );
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container2 = targetInst$jscomp$0.stateNode.containerInfo;
              if (container2 === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container2; ) {
                nodeTag = getClosestInstanceFromNode(container2);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container2 = container2.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance2 = instance;
                lastHostComponent = _instance2.stateNode;
                _instance2 = _instance2.tag;
                5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                  createDispatchListener(
                    instance,
                    _instance2,
                    lastHostComponent
                  )
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: reactName,
                listeners: inCapturePhase
              }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance2 = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance2,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance2 = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                  accumulateTargetOnly = _instance2;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance = reactEventType;
                      lastHostComponent = 0;
                      for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                        lastHostComponent++;
                      _instance2 = 0;
                      for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                        _instance2++;
                      for (; 0 < lastHostComponent - _instance2; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance2 - lastHostComponent; )
                        instance = inCapturePhase(instance), _instance2--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance = inCapturePhase(instance);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(
                  dispatchQueue,
                  nativeEvent,
                  nativeEventTarget
                );
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(
                  dispatchQueue,
                  nativeEvent,
                  nativeEventTarget
                );
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
              targetInst,
              eventType
            ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: eventType,
              listeners: handleEventFunc
            }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(
                targetInst,
                "onBeforeInput"
              ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance3 = targetFiber, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
            createDispatchListener(targetFiber, _instance3, stateNode)
          ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
            createDispatchListener(targetFiber, _instance3, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
          _instance4 = _instance4.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      function validatePropertiesInDevelopment(type, props) {
        validateProperties$2(type, props);
        "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type
        ));
        var eventRegistry = {
          registrationNameDependencies,
          possibleRegistrationNames
        };
        isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
        props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
      }
      function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
        serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
      }
      function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
        attributeNames.forEach(function(attributeName) {
          serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
        });
      }
      function warnForInvalidEventListener(registrationName, listener) {
        false === listener ? console.error(
          "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
          registrationName,
          registrationName,
          registrationName
        ) : console.error(
          "Expected `%s` listener to be a function, instead got a value of `%s` type.",
          registrationName,
          typeof listener
        );
      }
      function normalizeHTML(parent, html) {
        parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
          parent.namespaceURI,
          parent.tagName
        ) : parent.ownerDocument.createElement(parent.tagName);
        parent.innerHTML = html;
        return parent.innerHTML;
      }
      function normalizeMarkupForTextOrAttribute(markup) {
        willCoercionThrow(markup) && (console.error(
          "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
          typeName(markup)
        ), testStringCoercion(markup));
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            if ("string" === typeof value)
              validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
            else if ("number" === typeof value || "bigint" === typeof value)
              validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              "src" === key ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                key,
                key
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                key,
                key
              );
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            checkAttributeStringCoercion(value, key);
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            null != value && ("form" === tag ? "formAction" === key ? console.error(
              "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
            ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
              "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
            )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
              "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
            ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
              "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
            ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
              'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
            )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
              "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
            )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
              "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
            ))) : (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            )) : (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            )) : "action" === key ? console.error(
              "You can only pass the action prop to <form>."
            ) : console.error(
              "You can only pass the formAction prop to <input> or <button>."
            ));
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(
                domElement,
                tag,
                "encType",
                props.encType,
                props,
                null
              ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                domElement,
                tag,
                "target",
                props.target,
                props,
                null
              )));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            checkAttributeStringCoercion(value, key);
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
            break;
          case "onScrollEnd":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              key = value.__html;
              if (null != key) {
                if (null != props.children)
                  throw Error(
                    "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                  );
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            checkAttributeStringCoercion(value, key);
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              key
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              xlinkNamespace,
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              xmlNamespace,
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              xmlNamespace,
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              xmlNamespace,
              "xml:space",
              value
            );
            break;
          case "is":
            null != prevValue && console.error(
              'Cannot update the "is" prop after it has been initialized.'
            );
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          case "popoverTarget":
            didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
              "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
              value
            ));
          default:
            !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              key = value.__html;
              if (null != key) {
                if (null != props.children)
                  throw Error(
                    "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                  );
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
            break;
          case "onScrollEnd":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
            break;
          case "onClick":
            null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (registrationNameDependencies.hasOwnProperty(key))
              null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
            else
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        validatePropertiesInDevelopment(tag, props);
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            checkControlledValueProps("input", props);
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var _propValue = props[hasSrc];
                if (null != _propValue)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = _propValue;
                      break;
                    case "type":
                      propValue = _propValue;
                      break;
                    case "checked":
                      checked = _propValue;
                      break;
                    case "defaultChecked":
                      defaultChecked = _propValue;
                      break;
                    case "value":
                      propKey = _propValue;
                      break;
                    case "defaultValue":
                      defaultValue = _propValue;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propValue)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, _propValue, props, null);
                  }
              }
            validateInputProps(domElement, props);
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            checkControlledValueProps("select", props);
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(
                      domElement,
                      tag,
                      hasSrcSet,
                      defaultValue,
                      props,
                      null
                    );
                }
            validateSelectProps(domElement, props);
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            checkControlledValueProps("textarea", props);
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue)
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propValue,
                      defaultValue,
                      props,
                      null
                    );
                }
            validateTextareaProps(domElement, props);
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            validateOptionProps(domElement, props);
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (_propValue in props)
                props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  _propValue,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        validatePropertiesInDevelopment(tag, nextProps);
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(
                      domElement,
                      tag,
                      propKey,
                      null,
                      nextProps,
                      lastProp
                    );
                }
            }
            for (var _propKey8 in nextProps) {
              var propKey = nextProps[_propKey8];
              lastProp = lastProps[_propKey8];
              if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                switch (_propKey8) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      _propKey8,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
            nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
            tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
              "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ), didWarnUncontrolledToControlled = true);
            !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
              "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ), didWarnControlledToUncontrolled = true);
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = _propKey8 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    _propKey8 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            nextProps = defaultValue;
            tag = value;
            lastProps = propKey;
            null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
            return;
          case "textarea":
            propKey = _propKey8 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    _propKey8 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name)
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, _propKey8, propKey);
            return;
          case "option":
            for (var _propKey13 in lastProps)
              if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                switch (_propKey13) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      _propKey13,
                      null,
                      nextProps,
                      _propKey8
                    );
                }
            for (lastDefaultValue in nextProps)
              if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      _propKey8,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var _propKey15 in lastProps)
              _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                domElement,
                tag,
                _propKey15,
                null,
                nextProps,
                _propKey8
              );
            for (checked in nextProps)
              if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != _propKey8)
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      _propKey8,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var _propKey17 in lastProps)
                _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                  domElement,
                  tag,
                  _propKey17,
                  void 0,
                  nextProps,
                  _propKey8
                );
              for (defaultChecked in nextProps)
                _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  _propKey8,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var _propKey19 in lastProps)
          _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
        for (lastProp in nextProps)
          _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
      }
      function getPropNameFromAttributeName(attrName) {
        switch (attrName) {
          case "class":
            return "className";
          case "for":
            return "htmlFor";
          default:
            return attrName;
        }
      }
      function getStylesObjectFromElement(domElement) {
        var serverValueInObjectForm = {};
        domElement = domElement.style;
        for (var i = 0; i < domElement.length; i++) {
          var styleName = domElement[i];
          serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
        }
        return serverValueInObjectForm;
      }
      function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
        if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
          console.error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        else {
          var clientValue;
          var delimiter = clientValue = "", styleName;
          for (styleName in value$jscomp$0)
            if (value$jscomp$0.hasOwnProperty(styleName)) {
              var value = value$jscomp$0[styleName];
              null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
            }
          clientValue = clientValue || null;
          value$jscomp$0 = domElement.getAttribute("style");
          value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
        }
      }
      function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement)
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              return;
          }
        else if (null != value)
          switch (typeof value) {
            case "function":
            case "symbol":
            case "boolean":
              break;
            default:
              if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                return;
          }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
      }
      function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
          }
          if (!value) return;
        } else
          switch (typeof value) {
            case "function":
            case "symbol":
              break;
            default:
              if (value) return;
          }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
      }
      function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement)
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              return;
          }
        else if (null != value)
          switch (typeof value) {
            case "function":
            case "symbol":
              break;
            default:
              if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                return;
          }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
      }
      function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement)
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              return;
            default:
              if (isNaN(value)) return;
          }
        else if (null != value)
          switch (typeof value) {
            case "function":
            case "symbol":
            case "boolean":
              break;
            default:
              if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                return;
          }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
      }
      function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
        extraAttributes.delete(attributeName);
        domElement = domElement.getAttribute(attributeName);
        if (null === domElement)
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              return;
          }
        else if (null != value)
          switch (typeof value) {
            case "function":
            case "symbol":
            case "boolean":
              break;
            default:
              if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                return;
          }
        warnForPropDifference(propKey, domElement, value, serverDifferences);
      }
      function diffHydratedProperties(domElement, tag, props, hostContext) {
        for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
          switch (attributes[i].name.toLowerCase()) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              extraAttributes.add(attributes[i].name);
          }
        if (isCustomElement(tag))
          for (var propKey in props) {
            if (props.hasOwnProperty(propKey)) {
              var value = props[propKey];
              if (null != value) {
                if (registrationNameDependencies.hasOwnProperty(propKey))
                  "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                else if (true !== props.suppressHydrationWarning)
                  switch (propKey) {
                    case "children":
                      "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        value,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      value = value ? value.__html : void 0;
                      null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      ));
                      continue;
                    case "style":
                      extraAttributes.delete(propKey);
                      diffHydratedStyles(domElement, value, serverDifferences);
                      continue;
                    case "offsetParent":
                    case "offsetTop":
                    case "offsetLeft":
                    case "offsetWidth":
                    case "offsetHeight":
                    case "isContentEditable":
                    case "outerText":
                    case "outerHTML":
                      extraAttributes.delete(propKey.toLowerCase());
                      console.error(
                        "Assignment to read-only property will result in a no-op: `%s`",
                        propKey
                      );
                      continue;
                    case "className":
                      extraAttributes.delete("class");
                      attributes = getValueForAttributeOnCustomComponent(
                        domElement,
                        "class",
                        value
                      );
                      warnForPropDifference(
                        "className",
                        attributes,
                        value,
                        serverDifferences
                      );
                      continue;
                    default:
                      hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                        domElement,
                        propKey,
                        value
                      ), warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      );
                  }
              }
            }
          }
        else
          for (value in props)
            if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
              if (registrationNameDependencies.hasOwnProperty(value))
                "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
              else if (true !== props.suppressHydrationWarning)
                switch (value) {
                  case "children":
                    "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                      "children",
                      domElement.textContent,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "value":
                  case "checked":
                  case "selected":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    propKey = propKey ? propKey.__html : void 0;
                    null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                    continue;
                  case "className":
                    hydrateAttribute(
                      domElement,
                      value,
                      "class",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "tabIndex":
                    hydrateAttribute(
                      domElement,
                      value,
                      "tabindex",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "style":
                    extraAttributes.delete(value);
                    diffHydratedStyles(domElement, propKey, serverDifferences);
                    continue;
                  case "multiple":
                    extraAttributes.delete(value);
                    warnForPropDifference(
                      value,
                      domElement.multiple,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  case "muted":
                    extraAttributes.delete(value);
                    warnForPropDifference(
                      value,
                      domElement.muted,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  case "autoFocus":
                    extraAttributes.delete("autofocus");
                    warnForPropDifference(
                      value,
                      domElement.autofocus,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  case "data":
                    if ("object" !== tag) {
                      extraAttributes.delete(value);
                      attributes = domElement.getAttribute("data");
                      warnForPropDifference(
                        value,
                        attributes,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    }
                  case "src":
                  case "href":
                    if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                      "src" === value ? console.error(
                        'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                        value,
                        value
                      ) : console.error(
                        'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                        value,
                        value
                      );
                      continue;
                    }
                    hydrateSanitizedAttribute(
                      domElement,
                      value,
                      value,
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "action":
                  case "formAction":
                    attributes = domElement.getAttribute(value);
                    if ("function" === typeof propKey) {
                      extraAttributes.delete(value.toLowerCase());
                      "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                      continue;
                    } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                      extraAttributes.delete(value.toLowerCase());
                      warnForPropDifference(
                        value,
                        "function",
                        propKey,
                        serverDifferences
                      );
                      continue;
                    }
                    hydrateSanitizedAttribute(
                      domElement,
                      value,
                      value.toLowerCase(),
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkHref":
                    hydrateSanitizedAttribute(
                      domElement,
                      value,
                      "xlink:href",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "contentEditable":
                    hydrateBooleanishAttribute(
                      domElement,
                      value,
                      "contenteditable",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "spellCheck":
                    hydrateBooleanishAttribute(
                      domElement,
                      value,
                      "spellcheck",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "draggable":
                  case "autoReverse":
                  case "externalResourcesRequired":
                  case "focusable":
                  case "preserveAlpha":
                    hydrateBooleanishAttribute(
                      domElement,
                      value,
                      value,
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                    hydrateBooleanAttribute(
                      domElement,
                      value,
                      value.toLowerCase(),
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "capture":
                  case "download":
                    a: {
                      i = domElement;
                      var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                      extraAttributes.delete(attributeName);
                      i = i.getAttribute(attributeName);
                      if (null === i)
                        switch (typeof propKey) {
                          case "undefined":
                          case "function":
                          case "symbol":
                            break a;
                          default:
                            if (false === propKey) break a;
                        }
                      else if (null != propKey)
                        switch (typeof propKey) {
                          case "function":
                          case "symbol":
                            break;
                          case "boolean":
                            if (true === propKey && "" === i) break a;
                            break;
                          default:
                            if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                              break a;
                        }
                      warnForPropDifference(
                        attributes,
                        i,
                        propKey,
                        serverDifferences$jscomp$0
                      );
                    }
                    continue;
                  case "cols":
                  case "rows":
                  case "size":
                  case "span":
                    a: {
                      i = domElement;
                      attributeName = attributes = value;
                      serverDifferences$jscomp$0 = serverDifferences;
                      extraAttributes.delete(attributeName);
                      i = i.getAttribute(attributeName);
                      if (null === i)
                        switch (typeof propKey) {
                          case "undefined":
                          case "function":
                          case "symbol":
                          case "boolean":
                            break a;
                          default:
                            if (isNaN(propKey) || 1 > propKey) break a;
                        }
                      else if (null != propKey)
                        switch (typeof propKey) {
                          case "function":
                          case "symbol":
                          case "boolean":
                            break;
                          default:
                            if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                              break a;
                        }
                      warnForPropDifference(
                        attributes,
                        i,
                        propKey,
                        serverDifferences$jscomp$0
                      );
                    }
                    continue;
                  case "rowSpan":
                    hydrateNumericAttribute(
                      domElement,
                      value,
                      "rowspan",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "start":
                    hydrateNumericAttribute(
                      domElement,
                      value,
                      value,
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xHeight":
                    hydrateAttribute(
                      domElement,
                      value,
                      "x-height",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkActuate":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:actuate",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkArcrole":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:arcrole",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkRole":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:role",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkShow":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:show",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkTitle":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:title",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xlinkType":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xlink:type",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xmlBase":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xml:base",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xmlLang":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xml:lang",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "xmlSpace":
                    hydrateAttribute(
                      domElement,
                      value,
                      "xml:space",
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  case "inert":
                    "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                      "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                      value
                    ));
                    hydrateBooleanAttribute(
                      domElement,
                      value,
                      value,
                      propKey,
                      extraAttributes,
                      serverDifferences
                    );
                    continue;
                  default:
                    if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                      i = getAttributeAlias(value);
                      attributes = false;
                      hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                        attributeName
                      ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                      a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                        if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                          attributeName = attributeName.getAttribute(
                            serverDifferences$jscomp$0
                          ), checkAttributeStringCoercion(
                            i,
                            serverDifferences$jscomp$0
                          ), i = attributeName === "" + i ? i : attributeName;
                        else {
                          switch (typeof i) {
                            case "function":
                            case "symbol":
                              break a;
                            case "boolean":
                              if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                break a;
                          }
                          i = void 0 === i ? void 0 : null;
                        }
                      else i = void 0;
                      attributes || warnForPropDifference(
                        value,
                        i,
                        propKey,
                        serverDifferences
                      );
                    }
                }
            }
        0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
        return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
      }
      function propNamesListJoin(list, combinator) {
        switch (list.length) {
          case 0:
            return "";
          case 1:
            return list[0];
          case 2:
            return list[0] + " " + combinator + " " + list[1];
          default:
            return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
        }
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
            var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i += 1; i < resourceEntries.length; i++) {
                var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration) break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count) break;
            }
          }
          if (0 < count) return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case SVG_NAMESPACE:
            return HostContextNamespaceSvg;
          case MATH_NAMESPACE:
            return HostContextNamespaceMath;
          default:
            return HostContextNamespaceNone;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (parentNamespace === HostContextNamespaceNone)
          switch (type) {
            case "svg":
              return HostContextNamespaceSvg;
            case "math":
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      function resolveEventType() {
        var event = window.event;
        return event && event !== schedulerEvent ? event.type : null;
      }
      function resolveEventTimeStamp() {
        var event = window.event;
        return event && event !== schedulerEvent ? event.timeStamp : -1.1;
      }
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function commitMount(domElement, type, newProps) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            newProps.autoFocus && domElement.focus();
            break;
          case "img":
            newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
        }
      }
      function commitHydratedInstance() {
      }
      function commitUpdate(domElement, type, oldProps, newProps) {
        updateProperties(domElement, type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function warnForReactChildrenConflict(container2) {
        if (!container2.__reactWarnedAboutChildrenConflict) {
          var props = container2[internalPropsKey] || null;
          if (null !== props) {
            var fiber = getInstanceFromNode(container2);
            null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container2.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
              console.error(
                'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
              );
            })) : null != props.dangerouslySetInnerHTML && (container2.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
              console.error(
                'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
              );
            })));
          }
        }
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container2, child) {
        (9 === container2.nodeType ? container2.body : "HTML" === container2.nodeName ? container2.ownerDocument.body : container2).removeChild(child);
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
              depth++;
            else if (node === PREAMBLE_CONTRIBUTION_HTML)
              releaseSingletonInstance(
                parentInstance.ownerDocument.documentElement
              );
            else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, node === SUSPENSE_END_DATA)
              if (0 === suspenseInstance) break;
              else suspenseInstance--;
            else
              node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function hideDehydratedBoundary(suspenseInstance) {
        hideOrUnhideDehydratedBoundary(suspenseInstance, true);
      }
      function hideInstance(instance) {
        instance = instance.style;
        "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideDehydratedBoundary(dehydratedInstance) {
        hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
      }
      function unhideInstance(instance, props) {
        props = props[STYLE];
        props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
        instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
      }
      function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
      }
      function clearContainerSparingly(container2) {
        var nextNode = container2.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container2.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              checkAttributeStringCoercion(anyProps.name, "name");
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
        for (; 8 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
      }
      function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if (instance.data === SUSPENSE_QUEUED_START_DATA)
          instance._reactRetry = callback;
        else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
              break;
            if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
              return null;
          }
        }
        return node;
      }
      function describeHydratableInstanceForDevWarnings(instance) {
        if (1 === instance.nodeType) {
          for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
          }
          return { type: JSCompiler_temp_const, props: serverDifferences };
        }
        return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
      }
      function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
        return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
      }
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
              if (0 === depth) return targetInstance;
              depth--;
            } else
              data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container2) {
        retryIfBlockedOn(container2);
      }
      function commitHydratedActivityInstance(activityInstance) {
        retryIfBlockedOn(activityInstance);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
        validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type)
              throw Error(
                "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
              );
            return type;
          case "head":
            type = props.head;
            if (!type)
              throw Error(
                "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
              );
            return type;
          case "body":
            type = props.body;
            if (!type)
              throw Error(
                "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
              );
            return type;
          default:
            throw Error(
              "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
            );
        }
      }
      function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
        if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
          var tagName = instance.tagName.toLowerCase();
          console.error(
            "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
            tagName,
            tagName,
            tagName
          );
        }
        switch (type) {
          case "html":
          case "head":
          case "body":
            break;
          default:
            console.error(
              "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
            );
        }
        for (tagName = instance.attributes; tagName.length; )
          instance.removeAttributeNode(tagName[0]);
        setInitialProperties(instance, type, props);
        instance[internalInstanceKey] = internalInstanceHandle;
        instance[internalPropsKey] = props;
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      function getHoistableRoot(container2) {
        return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
      }
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
        if (!resourceRoot)
          throw Error(
            '"resourceRoot" was expected to exist. This is a bug in React.'
          );
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
              if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: NotLoaded, preload: null }
              }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                var preloadProps = {
                  rel: "preload",
                  as: "style",
                  href: pendingProps.href,
                  crossOrigin: pendingProps.crossOrigin,
                  integrity: pendingProps.integrity,
                  media: pendingProps.media,
                  hrefLang: pendingProps.hrefLang,
                  referrerPolicy: pendingProps.referrerPolicy
                };
                preloadPropsMap.set(type, preloadProps);
                _styles || preloadStylesheet(
                  resourceRoot,
                  type,
                  preloadProps,
                  _resource.state
                );
              }
              if (currentProps && null === currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return _resource;
            }
            if (currentProps && null !== currentResource)
              throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
              );
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(
              'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
            );
        }
      }
      function describeLinkForResourceErrorDEV(props) {
        var describedProps = 0, description = "<link";
        "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
        "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
        "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
        Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
        return description + " />";
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector(
          'link[rel="preload"][as="style"][' + key + "]"
        ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= Loaded;
        }), key.addEventListener("error", function() {
          return state.loading |= Errored;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var _instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (_instance)
                return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(_instance);
              var linkInstance = _instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(_instance, "link", instance);
              resource.state.loading |= Inserted;
              insertStylesheet(_instance, props.precedence, hoistableRoot);
              return resource.instance = _instance;
            case "script":
              _instance = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(_instance)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(_instance))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(
                'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
              );
          }
        else
          "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
        if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
          return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
            "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
            type,
            type
          ), false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
              outsideHostContainerContext && console.error(
                'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
              );
              break;
            }
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
              if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                type = props.href;
                var onError = props.onError, disabled = props.disabled;
                hostContext = [];
                props.onLoad && hostContext.push("`onLoad`");
                onError && hostContext.push("`onError`");
                null != disabled && hostContext.push("`disabled`");
                onError = propNamesListJoin(hostContext, "and");
                onError += 1 === hostContext.length ? " prop" : " props";
                disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                hostContext.length && console.error(
                  'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                  type,
                  disabled,
                  onError
                );
              }
              outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
              ) : (props.onError || props.onLoad) && console.error(
                "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
              ));
              break;
            }
            switch (props.rel) {
              case "stylesheet":
                return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                  'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                ), "string" === typeof type && null == props;
              default:
                return true;
            }
          case "script":
            type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
            if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
              outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
              ) : console.error(
                "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
              ) : console.error(
                'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
              ));
              break;
            }
            return true;
          case "noscript":
          case "template":
            outsideHostContainerContext && console.error(
              "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
              type
            );
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= Inserted;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets)
            insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & Inserted)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(LAST_PRECEDENCE);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(LAST_PRECEDENCE, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(LAST_PRECEDENCE, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= Inserted;
        }
      }
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = noTimeout;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
        this.passiveEffectDuration = this.effectDuration = -0;
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        containerInfo = this.pendingUpdatersLaneMap = [];
        for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
        this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = ConcurrentMode;
        true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
        tag |= ProfileMode;
        isStrictMode = createFiber(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        retainCache(tag);
        containerInfo.pooledCache = tag;
        retainCache(tag);
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback) {
        if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
          try {
            injectedHook.onScheduleFiberRoot(rendererID, container2, element);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
          }
        parentComponent = getContextForSubtree(parentComponent);
        null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
          getComponentNameFromFiber(current) || "Unknown"
        ));
        container2 = createUpdate(lane);
        container2.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && ("function" !== typeof callback && console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          callback
        ), container2.callback = callback);
        element = enqueueUpdate(rootFiber, container2, lane);
        null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane(fiber);
          lane = getBumpedLaneForHydrationByLane(lane);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return DiscreteEventPriority;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return ContinuousEventPriority;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return DiscreteEventPriority;
              case UserBlockingPriority:
                return ContinuousEventPriority;
              case NormalPriority$1:
              case LowPriority:
                return DefaultEventPriority;
              case IdlePriority:
                return IdleEventPriority;
              default:
                return DefaultEventPriority;
            }
          default:
            return DefaultEventPriority;
        }
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            ), event = nativeEventClone;
            null !== currentReplayingEvent && console.error(
              "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
            );
            currentReplayingEvent = event;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            null === currentReplayingEvent && console.error(
              "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
            );
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              }, Object.freeze(form), startHostTransition(
                formInst,
                form,
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve) {
                return pendingResolve = resolve;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener(
              "navigatesuccess",
              handleNavigateComplete
            );
            navigation.removeEventListener(
              "navigateerror",
              handleNavigateComplete
            );
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function warnIfReactDOMContainerInDEV(container2) {
        container2[internalContainerInstanceKey] && (container2._reactRootContainer ? console.error(
          "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
        ) : console.error(
          "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
        ));
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var Scheduler = require_scheduler(), React3 = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), valueStack = [];
      var fiberStack = [];
      var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
      var didWarnValueDefaultValue = false;
      var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
        " "
      ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
        " "
      ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null,
        implicitRootScope: false
      }, didWarn = {}, shorthandToLonghand = {
        animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
          " "
        ),
        background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
          " "
        ),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
          " "
        ),
        borderBlockEnd: [
          "borderBlockEndColor",
          "borderBlockEndStyle",
          "borderBlockEndWidth"
        ],
        borderBlockStart: [
          "borderBlockStartColor",
          "borderBlockStartStyle",
          "borderBlockStartWidth"
        ],
        borderBottom: [
          "borderBottomColor",
          "borderBottomStyle",
          "borderBottomWidth"
        ],
        borderColor: [
          "borderBottomColor",
          "borderLeftColor",
          "borderRightColor",
          "borderTopColor"
        ],
        borderImage: [
          "borderImageOutset",
          "borderImageRepeat",
          "borderImageSlice",
          "borderImageSource",
          "borderImageWidth"
        ],
        borderInlineEnd: [
          "borderInlineEndColor",
          "borderInlineEndStyle",
          "borderInlineEndWidth"
        ],
        borderInlineStart: [
          "borderInlineStartColor",
          "borderInlineStartStyle",
          "borderInlineStartWidth"
        ],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: [
          "borderBottomLeftRadius",
          "borderBottomRightRadius",
          "borderTopLeftRadius",
          "borderTopRightRadius"
        ],
        borderRight: [
          "borderRightColor",
          "borderRightStyle",
          "borderRightWidth"
        ],
        borderStyle: [
          "borderBottomStyle",
          "borderLeftStyle",
          "borderRightStyle",
          "borderTopStyle"
        ],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: [
          "borderBottomWidth",
          "borderLeftWidth",
          "borderRightWidth",
          "borderTopWidth"
        ],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
          " "
        ),
        fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
          " "
        ),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
          " "
        ),
        gridArea: [
          "gridColumnEnd",
          "gridColumnStart",
          "gridRowEnd",
          "gridRowStart"
        ],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: [
          "gridTemplateAreas",
          "gridTemplateColumns",
          "gridTemplateRows"
        ],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
          " "
        ),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: [
          "textDecorationColor",
          "textDecorationLine",
          "textDecorationStyle"
        ],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: [
          "transitionDelay",
          "transitionDuration",
          "transitionProperty",
          "transitionTimingFunction"
        ],
        wordWrap: ["overflowWrap"]
      }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0,
        "aria-braillelabel": 0,
        "aria-brailleroledescription": 0,
        "aria-colindextext": 0,
        "aria-rowindextext": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
      if (canUseDOM2)
        try {
          var options$jscomp$0 = {};
          Object.defineProperty(options$jscomp$0, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options$jscomp$0, options$jscomp$0);
          window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var root = null, startText = null, fallbackText = null, EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
        CompositionEventInterface
      ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      }, KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window, documentMode = null;
      canUseDOM2 && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
      canUseDOM2 && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
      var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style = {};
      canUseDOM2 && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      var lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date;
        getCurrentTime = function() {
          return localDate.now();
        };
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
        color: "primary",
        properties: null,
        tooltipText: "",
        track: COMPONENTS_TRACK
      }, reusableComponentOptions = {
        start: -0,
        end: -0,
        detail: { devtools: reusableComponentDevToolDetails }
      }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
      var hasBadMapPolyfill = false;
      try {
        var nonExtensibleObject = Object.preventExtensions({});
        /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
        /* @__PURE__ */ new Set([nonExtensibleObject]);
      } catch (e$3) {
        hasBadMapPolyfill = true;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), valueCursor = createCursor(null);
      var rendererCursorDEV = createCursor(null);
      var rendererSigil = {};
      var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
        return null;
      }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        globalMostRecentTransitionTime = now$1();
        if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
          if (0 > transitionStartTime && 0 > transitionUpdateTime) {
            transitionStartTime = now();
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = newEventTime;
            transitionEventType = newEventType;
          }
          entangleAsyncAction(transition, returnValue);
        }
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null), ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function() {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function() {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
      };
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
          componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillMountWarnings = []);
        var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
          UNSAFE_componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillMountWarnings = []);
        var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
          componentWillReceivePropsUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillReceivePropsWarnings = []);
        var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
          function(fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }
        ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
        var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
          componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillUpdateWarnings = []);
        var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
        if (0 < UNSAFE_componentWillMountUniqueNames.size) {
          var sortedNames = setToSortedString(
            UNSAFE_componentWillMountUniqueNames
          );
          console.error(
            "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
            sortedNames
          );
        }
        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
          UNSAFE_componentWillReceivePropsUniqueNames
        ), console.error(
          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
          UNSAFE_componentWillUpdateUniqueNames
        ), console.error(
          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
          componentWillReceivePropsUniqueNames
        ), console.warn(
          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      };
      var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = null;
        for (var node = fiber; null !== node; )
          node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
        null === strictRoot ? console.error(
          "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
        ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
      };
      ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray) {
          if (0 !== fiberArray.length) {
            var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            runWithFiberInDEV(firstFiber, function() {
              console.error(
                "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                sortedNames
              );
            });
          }
        });
      };
      ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = /* @__PURE__ */ new Map();
      };
      var callComponent = {
        react_stack_bottom_frame: function(Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = true;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
        react_stack_bottom_frame: function(instance) {
          var wasRendering = isRendering;
          isRendering = true;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
        react_stack_bottom_frame: function(finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
        callComponentDidMount
      ), callComponentDidUpdate = {
        react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
        callComponentDidUpdate
      ), callComponentDidCatch = {
        react_stack_bottom_frame: function(instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
        callComponentDidCatch
      ), callComponentWillUnmount = {
        react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
      }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
        callComponentWillUnmount
      ), callCreate = {
        react_stack_bottom_frame: function(effect) {
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return effect.destroy = create;
        }
      }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
        react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
      }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
        react_stack_bottom_frame: function(lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), SuspenseyCommitException = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), SuspenseActionException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
      ), noopSuspenseyCommitThenable = {
        then: function() {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
      var didWarnAboutGenerators = didWarnAboutMaps = false;
      var ownerHasKeyUseWarning = {};
      var ownerHasFunctionTypeWarning = {};
      var ownerHasSymbolTypeWarning = {};
      warnForMissingKey = function(returnFiber, workInProgress2, child) {
        if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
          if ("object" !== typeof child._store)
            throw Error(
              "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
            );
          child._store.validated = 1;
          var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
          if (!ownerHasKeyUseWarning[componentKey]) {
            ownerHasKeyUseWarning[componentKey] = true;
            child = child._owner;
            returnFiber = returnFiber._debugOwner;
            var currentComponentErrorInfo = "";
            returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
            currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
            var childOwnerAppendix = "";
            null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
            runWithFiberInDEV(workInProgress2, function() {
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                currentComponentErrorInfo,
                childOwnerAppendix
              );
            });
          }
        }
      };
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = false;
      var currentlyProcessingQueue = null;
      var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
      var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
      var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      HooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          mountHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          mountHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          mountHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          mountHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          mountHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          mountHookTypesDev();
          return mountId();
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          mountHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState);
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          mountHookTypesDev();
          return mountRefresh();
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          mountHookTypesDev();
          return mountEvent(callback);
        }
      };
      HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return mountId();
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return mountActionState(action, initialState);
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return mountRefresh();
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          updateHookTypesDev();
          return mountEvent(callback);
        }
      };
      HooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return updateActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return updateActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          updateHookTypesDev();
          return updateEvent(callback);
        }
      };
      HooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return rerenderActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          updateHookTypesDev();
          return updateEvent(callback);
        }
      };
      InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountId();
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          mountHookTypesDev();
          return mountRefresh();
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountEvent(callback);
        }
      };
      InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEvent(callback);
        }
      };
      InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, deps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useEffectEvent: function(callback) {
          currentHookNameInDev = "useEffectEvent";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEvent(callback);
        }
      };
      var fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      Object.freeze(fakeInternalInstance);
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ), didReceiveUpdate = false;
      var didWarnAboutBadClass = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutContextTypes = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutRevealOrder = {};
      var didWarnAboutTailOptions = {};
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        },
        getOwner: function() {
          return current;
        }
      };
      if ("function" === typeof Symbol && Symbol.for) {
        var symbolFor = Symbol.for;
        symbolFor("selector.component");
        symbolFor("selector.has_pseudo_class");
        symbolFor("selector.role");
        symbolFor("selector.test_id");
        symbolFor("selector.text");
      }
      var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
      (function() {
        for (var i = 0; i < simpleEventPluginEvents.length; i++) {
          var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
          eventName = eventName[0].toUpperCase() + eventName.slice(1);
          registerSimpleEvent(domEventName, "on" + eventName);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
        registerSimpleEvent(TRANSITION_START, "onTransitionStart");
        registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      })();
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ), nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: function() {
          var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
          return previousWasRendering || wasRendering;
        },
        r: function(form) {
          var formInst = getInstanceFromNode(form);
          null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
        },
        D: function(href) {
          previousDispatcher.D(href);
          preconnectAs("dns-prefetch", href, null);
        },
        C: function(href, crossOrigin) {
          previousDispatcher.C(href, crossOrigin);
          preconnectAs("preconnect", href, crossOrigin);
        },
        L: function(href, as, options) {
          previousDispatcher.L(href, as, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href && as) {
            var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
            "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSizes
            ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
            var key = preloadSelector;
            switch (as) {
              case "style":
                key = getStyleKey(href);
                break;
              case "script":
                key = getScriptKey(href);
            }
            preloadPropsMap.has(key) || (href = assign(
              {
                rel: "preload",
                href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                as
              },
              options
            ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
          }
        },
        m: function(href, options) {
          previousDispatcher.m(href, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href) {
            var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                key = getScriptKey(href);
            }
            if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                    return;
              }
              as = ownerDocument.createElement("link");
              setInitialProperties(as, "link", href);
              markNodeAsHoistable(as);
              ownerDocument.head.appendChild(as);
            }
          }
        },
        X: function(src, options) {
          previousDispatcher.X(src, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && src) {
            var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
            resource || (resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }, scripts.set(key, resource));
          }
        },
        S: function(href, precedence, options) {
          previousDispatcher.S(href, precedence, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href) {
            var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
            precedence = precedence || "default";
            var resource = styles.get(key);
            if (!resource) {
              var state = { loading: NotLoaded, preload: null };
              if (resource = ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ))
                state.loading = Loaded | Inserted;
              else {
                href = assign(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options
                );
                (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                var link = resource = ownerDocument.createElement("link");
                markNodeAsHoistable(link);
                setInitialProperties(link, "link", href);
                link._p = new Promise(function(resolve, reject) {
                  link.onload = resolve;
                  link.onerror = reject;
                });
                link.addEventListener("load", function() {
                  state.loading |= Loaded;
                });
                link.addEventListener("error", function() {
                  state.loading |= Errored;
                });
                state.loading |= Inserted;
                insertStylesheet(resource, precedence, ownerDocument);
              }
              resource = {
                type: "stylesheet",
                instance: resource,
                count: 1,
                state
              };
              styles.set(key, resource);
            }
          }
        },
        M: function(src, options) {
          previousDispatcher.M(src, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && src) {
            var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
            resource || (resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }, scripts.set(key, resource));
          }
        }
      };
      var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
      var didWarnAboutNestedUpdates = false;
      var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
      overrideHookState = function(fiber, id, path, value) {
        id = findHook(fiber, id);
        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
      };
      overrideHookStateDeletePath = function(fiber, id, path) {
        id = findHook(fiber, id);
        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
      };
      overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
        id = findHook(fiber, id);
        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
      };
      overrideProps = function(fiber, path, value) {
        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path && scheduleUpdateOnFiber(path, fiber, 2);
      };
      overridePropsDeletePath = function(fiber, path) {
        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path && scheduleUpdateOnFiber(path, fiber, 2);
      };
      overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(
          fiber.memoizedProps,
          oldPath,
          newPath
        );
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        oldPath = enqueueConcurrentRenderForLane(fiber, 2);
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
      };
      scheduleUpdate = function(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      };
      scheduleRetry = function(fiber) {
        var lane = claimNextRetryLane(), root2 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
      };
      setErrorHandler = function(newShouldErrorImpl) {
        shouldErrorImpl = newShouldErrorImpl;
      };
      setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
      };
      var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      ), lastScheduledReplayQueue = null;
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error("Cannot update an unmounted root.");
        var args = arguments;
        "function" === typeof args[1] ? console.error(
          "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
        ) : isValidContainer(args[1]) ? console.error(
          "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
        ) : "undefined" !== typeof args[1] && console.error(
          "You passed a second argument to root.render(...) but it only accepts one argument."
        );
        args = children;
        var current2 = root2.current, lane = requestUpdateLane(current2);
        updateContainerImpl(current2, lane, args, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var args = arguments;
        "function" === typeof args[0] && console.error(
          "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
        );
        args = this._internalRoot;
        if (null !== args) {
          this._internalRoot = null;
          var container2 = args.containerInfo;
          (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
            "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
          );
          updateContainerImpl(args.current, 2, null, args, null, null);
          flushSyncWork$1();
          container2[internalContainerInstanceKey] = null;
        }
      };
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      (function() {
        var isomorphicReactPackageVersion = React3.version;
        if ("19.2.0" !== isomorphicReactPackageVersion)
          throw Error(
            'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
          );
      })();
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
      );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error("Unable to find node on an unmounted component.");
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(
            "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
          );
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      if (!function() {
        var internals = {
          bundleType: 1,
          version: "19.2.0",
          rendererPackageName: "react-dom",
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: "19.2.0"
        };
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.scheduleRetry = scheduleRetry;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        return injectInternals(internals);
      }() && canUseDOM2 && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
        var protocol = window.location.protocol;
        /^(https?|file):$/.test(protocol) && console.info(
          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
          "font-weight:bold"
        );
      }
      exports.createRoot = function(container2, options) {
        if (!isValidContainer(container2))
          throw Error("Target container is not a DOM element.");
        warnIfReactDOMContainerInDEV(container2);
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options && void 0 !== options && (options.hydrate ? console.warn(
          "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
        ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
          "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
        ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
        options = createFiberRoot(
          container2,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container2[internalContainerInstanceKey] = options.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMRoot(options);
      };
      exports.hydrateRoot = function(container2, initialChildren, options) {
        if (!isValidContainer(container2))
          throw Error("Target container is not a DOM element.");
        warnIfReactDOMContainerInDEV(container2);
        void 0 === initialChildren && console.error(
          "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
        );
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
        initialChildren = createFiberRoot(
          container2,
          1,
          true,
          initialChildren,
          null != options ? options : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options = initialChildren.current;
        isStrictMode = requestUpdateLane(options);
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options, identifierPrefix, isStrictMode);
        startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
        options = isStrictMode;
        initialChildren.current.lanes = options;
        markRootUpdated$1(initialChildren, options);
        ensureRootIsScheduled(initialChildren);
        container2[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.2.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_client_development();
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys2 = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys2.length ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys2 = 0 < keys2.length ? "{" + keys2.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys2,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          maybeKey,
          getOwner(),
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var React3 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React3 = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React3.react_stack_bottom_frame.bind(
        React3,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type, config, maybeKey) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          false,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type, config, maybeKey) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          true,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory2());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl2;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl2 = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        var e = "undefined" != typeof self ? self : {}, r2 = "2.14.1";
        let n;
        const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (null == n) {
            const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              n = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t2;
            } catch (e2) {
              n = t2;
            }
          }
          return n;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!i.API_URL) return null;
          try {
            const t2 = new URL(i.API_URL);
            return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t2) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, s = { supported: false, testSupport: function(t2) {
          !l && o && (u ? c(t2) : a = t2);
        } };
        let a, o, l = false, u = false;
        function c(t2) {
          const e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, o), t2.isContextLost()) return;
            s.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), l = true;
        }
        e.document && (o = e.document.createElement("img"), o.onload = function() {
          a && c(a), a = null, u = true;
        }, o.onerror = function() {
          l = true, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h = "01";
        var p = f;
        function f(t2, e2, r3, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r3 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r3, this.p2y = n2;
        }
        f.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0) return 0;
          if (t2 > 1) return 1;
          for (var r3 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r3) - t2;
            if (Math.abs(i2) < e2) return r3;
            var s2 = this.sampleCurveDerivativeX(r3);
            if (Math.abs(s2) < 1e-6) break;
            r3 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r3 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r3), !(Math.abs(i2 - t2) < e2)); n2++) t2 > i2 ? a2 = r3 : o2 = r3, r3 = 0.5 * (o2 - a2) + a2;
          return r3;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var d = y;
        function y(t2, e2) {
          this.x = t2, this.y = e2;
        }
        y.prototype = { clone: function() {
          return new y(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r3 = t2.y - this.y;
          return e2 * e2 + r3 * r3;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r3 = Math.sin(t2), n2 = r3 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r3 * this.y, this.y = n2, this;
        }, _rotateAround: function(t2, e2) {
          var r3 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r3 * (this.y - e2.y);
          return this.x = e2.x + r3 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, y.convert = function(t2) {
          return t2 instanceof y ? t2 : Array.isArray(t2) ? new y(t2[0], t2[1]) : t2;
        };
        const m = Math.PI / 180, g = 180 / Math.PI;
        function x(t2) {
          return t2 * m;
        }
        function v(t2) {
          return t2 * g;
        }
        const b = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function w(t2) {
          if (t2 <= 0) return 0;
          if (t2 >= 1) return 1;
          const e2 = t2 * t2, r3 = e2 * t2;
          return 4 * (t2 < 0.5 ? r3 : 3 * (t2 - e2) + r3 - 0.75);
        }
        function _(t2, e2, r3, n2) {
          const i2 = new p(t2, e2, r3, n2);
          return function(t3) {
            return i2.solve(t3);
          };
        }
        const A = _(0.25, 0.1, 0.25, 1);
        function S(t2, e2, r3) {
          return Math.min(r3, Math.max(e2, t2));
        }
        function k(t2, e2, r3) {
          return (r3 = S((r3 - t2) / (e2 - t2), 0, 1)) * r3 * (3 - 2 * r3);
        }
        function I(t2, e2, r3) {
          const n2 = r3 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r3 : i2;
        }
        function M(t2, e2, r3) {
          if (!t2.length) return r3(null, []);
          let n2 = t2.length;
          const i2 = new Array(t2.length);
          let s2 = null;
          t2.forEach((t3, a2) => {
            e2(t3, (t4, e3) => {
              t4 && (s2 = t4), i2[a2] = e3, 0 == --n2 && r3(s2, i2);
            });
          });
        }
        function T(t2) {
          const e2 = [];
          for (const r3 in t2) e2.push(t2[r3]);
          return e2;
        }
        function z(t2, ...e2) {
          for (const r3 of e2) for (const e3 in r3) t2[e3] = r3[e3];
          return t2;
        }
        let B = 1;
        function E() {
          return B++;
        }
        function C() {
          return function t2(e2) {
            return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
          }();
        }
        function P(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }
        function D(t2) {
          return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
        }
        function V(t2, e2) {
          t2.forEach((t3) => {
            e2[t3] && (e2[t3] = e2[t3].bind(e2));
          });
        }
        function L(t2, e2) {
          return -1 !== t2.indexOf(e2, t2.length - e2.length);
        }
        function F(t2, e2, r3) {
          const n2 = {};
          for (const i2 in t2) n2[i2] = e2.call(r3 || this, t2[i2], i2, t2);
          return n2;
        }
        function R(t2, e2, r3) {
          const n2 = {};
          for (const i2 in t2) e2.call(r3 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
          return n2;
        }
        function j(t2) {
          return Array.isArray(t2) ? t2.map(j) : "object" == typeof t2 && t2 ? F(t2, j) : t2;
        }
        const $ = {};
        function U(t2) {
          $[t2] || ("undefined" != typeof console && console.warn(t2), $[t2] = true);
        }
        function O(t2, e2, r3) {
          return (r3.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r3.x - t2.x);
        }
        function q(t2) {
          let e2 = 0;
          for (let r3, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r3 = t2[i2], n2 = t2[a2], e2 += (n2.x - r3.x) * (r3.y + n2.y);
          return e2;
        }
        function N() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function G(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r3, n2, i2) => {
            const s2 = n2 || i2;
            return e2[r3] = !s2 || s2.toLowerCase(), "";
          }), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }
        let Z = null;
        function X(t2) {
          if (null == Z) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            Z = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return Z;
        }
        function K(t2) {
          try {
            const r3 = e[t2];
            return r3.setItem("_mapbox_test_", 1), r3.removeItem("_mapbox_test_"), true;
          } catch (t3) {
            return false;
          }
        }
        function Y(t2, e2) {
          return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
        }
        const H = "mapbox-tiles";
        let W, J, Q = 500, tt = 50;
        function et() {
          try {
            return e.caches;
          } catch (t2) {
          }
        }
        function rt() {
          et() && !W && (W = e.caches.open(H));
        }
        function nt(t2) {
          const e2 = t2.indexOf("?");
          if (e2 < 0) return t2;
          const r3 = function(t3) {
            const e3 = t3.indexOf("?");
            return e3 > 0 ? t3.slice(e3 + 1).split("&") : [];
          }(t2), n2 = r3.filter((t3) => {
            const e3 = t3.split("=");
            return "language" === e3[0] || "worldview" === e3[0];
          });
          return n2.length ? `${t2.slice(0, e2)}?${n2.join("&")}` : t2.slice(0, e2);
        }
        let it = 1 / 0;
        const st = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(st);
        class at extends Error {
          constructor(t2, e2, r3) {
            401 === e2 && gt(r3) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r3;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const ot = N() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;
        const lt = function(t2, r3) {
          if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ot()) && !/^\w+:/.test(n2))) {
            if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal")) return function(t3, r4) {
              const n3 = new e.AbortController(), i2 = new e.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ot(), referrerPolicy: t3.referrerPolicy, signal: n3.signal });
              let s2 = false, a2 = false;
              const o2 = (l2 = i2.url).indexOf("sku=") > 0 && gt(l2);
              var l2;
              "json" === t3.type && i2.headers.set("Accept", "application/json");
              const u2 = (n4, s3, l3) => {
                if (a2) return;
                if (n4 && "SecurityError" !== n4.message && U(n4), s3 && l3) return c2(s3);
                const u3 = Date.now();
                e.fetch(i2).then((e2) => {
                  if (e2.ok) {
                    const t4 = o2 ? e2.clone() : null;
                    return c2(e2, t4, u3);
                  }
                  return r4(new at(e2.statusText, e2.status, t3.url));
                }).catch((e2) => {
                  "AbortError" !== e2.name && r4(new Error(`${e2.message} ${t3.url}`));
                });
              }, c2 = (n4, o3, l3) => {
                ("arrayBuffer" === t3.type ? n4.arrayBuffer() : "json" === t3.type ? n4.json() : n4.text()).then((t4) => {
                  a2 || (o3 && l3 && function(t5, r5, n5) {
                    if (rt(), !W) return;
                    const i3 = { status: r5.status, statusText: r5.statusText, headers: new e.Headers() };
                    r5.headers.forEach((t6, e2) => i3.headers.set(e2, t6));
                    const s3 = G(r5.headers.get("Cache-Control") || "");
                    if (s3["no-store"]) return;
                    s3["max-age"] && i3.headers.set("Expires", new Date(n5 + 1e3 * s3["max-age"]).toUTCString());
                    const a3 = i3.headers.get("Expires");
                    a3 && (new Date(a3).getTime() - n5 < 42e4 || function(t6, e2) {
                      if (void 0 === J) try {
                        new Response(new ReadableStream()), J = true;
                      } catch (t7) {
                        J = false;
                      }
                      J ? e2(t6.body) : t6.blob().then(e2);
                    }(r5, (r6) => {
                      const n6 = new e.Response(r6, i3);
                      rt(), W && W.then((e2) => e2.put(nt(t5.url), n6)).catch((t6) => U(t6.message));
                    }));
                  }(i2, o3, l3), s2 = true, r4(null, t4, n4.headers.get("Cache-Control"), n4.headers.get("Expires")));
                }).catch((t4) => {
                  a2 || r4(new Error(t4.message));
                });
              };
              return o2 ? function(t4, e2) {
                if (rt(), !W) return e2(null);
                const r5 = nt(t4.url);
                W.then((t5) => {
                  t5.match(r5).then((n4) => {
                    const i3 = function(t6) {
                      if (!t6) return false;
                      const e3 = new Date(t6.headers.get("Expires") || 0), r6 = G(t6.headers.get("Cache-Control") || "");
                      return e3 > Date.now() && !r6["no-cache"];
                    }(n4);
                    t5.delete(r5), i3 && t5.put(r5, n4.clone()), e2(null, n4, i3);
                  }).catch(e2);
                }).catch(e2);
              }(i2, u2) : u2(null, null), { cancel: () => {
                a2 = true, s2 || n3.abort();
              } };
            }(t2, r3);
            if (N() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t2, r3, void 0, true);
          }
          var n2;
          return function(t3, r4) {
            const n3 = new e.XMLHttpRequest();
            n3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (n3.responseType = "arraybuffer");
            for (const e2 in t3.headers) n3.setRequestHeader(e2, t3.headers[e2]);
            return "json" === t3.type && (n3.responseType = "text", n3.setRequestHeader("Accept", "application/json")), n3.withCredentials = "include" === t3.credentials, n3.onerror = () => {
              r4(new Error(n3.statusText));
            }, n3.onload = () => {
              if ((n3.status >= 200 && n3.status < 300 || 0 === n3.status) && null !== n3.response) {
                let e2 = n3.response;
                if ("json" === t3.type) try {
                  e2 = JSON.parse(n3.response);
                } catch (t4) {
                  return r4(t4);
                }
                r4(null, e2, n3.getResponseHeader("Cache-Control"), n3.getResponseHeader("Expires"));
              } else r4(new at(n3.statusText, n3.status, t3.url));
            }, n3.send(t3.body), { cancel: () => n3.abort() };
          }(t2, r3);
        }, ut = function(t2, e2) {
          return lt(z(t2, { type: "arrayBuffer" }), e2);
        };
        function ct(t2) {
          const r3 = e.document.createElement("a");
          return r3.href = t2, r3.protocol === e.document.location.protocol && r3.host === e.document.location.host;
        }
        const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let pt, ft;
        pt = [], ft = 0;
        const dt = function(t2, r3) {
          if (s.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
            const e2 = { requestParameters: t2, callback: r3, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return pt.push(e2), e2;
          }
          ft++;
          let n2 = false;
          const a2 = () => {
            if (!n2) for (n2 = true, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = pt.shift(), { requestParameters: e2, callback: r4, cancelled: n3 } = t3;
              n3 || (t3.cancel = dt(e2, r4).cancel);
            }
          }, o2 = ut(t2, (t3, n3, i2, s2) => {
            a2(), t3 ? r3(t3) : n3 && (e.createImageBitmap ? function(t4, r4) {
              const n4 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
              e.createImageBitmap(n4).then((t5) => {
                r4(null, t5);
              }).catch((t5) => {
                r4(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(n3, (t4, e2) => r3(t4, e2, i2, s2)) : function(t4, r4) {
              const n4 = new e.Image(), i3 = e.URL;
              n4.onload = () => {
                r4(null, n4), i3.revokeObjectURL(n4.src), n4.onload = null, e.requestAnimationFrame(() => {
                  n4.src = ht;
                });
              }, n4.onerror = () => r4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const s3 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
              n4.src = t4.byteLength ? i3.createObjectURL(s3) : ht;
            }(n3, (t4, e2) => r3(t4, e2, i2, s2)));
          });
          return { cancel: () => {
            o2.cancel(), a2();
          } };
        }, yt = "NO_ACCESS_TOKEN";
        function mt(t2) {
          return 0 === t2.indexOf("mapbox:");
        }
        function gt(t2) {
          return i.API_URL_REGEX.test(t2);
        }
        function xt(t2) {
          return i.API_CDN_URL_REGEX.test(t2);
        }
        function vt(t2) {
          return i.API_STYLE_REGEX.test(t2) && !bt(t2);
        }
        function bt(t2) {
          return i.API_SPRITE_REGEX.test(t2);
        }
        const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function _t(t2) {
          const e2 = t2.match(wt);
          if (!e2) throw new Error("Unable to parse URL object");
          return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
        }
        function At(t2) {
          const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
          return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
        }
        function St(t2) {
          if (!t2) return null;
          const r3 = t2.split(".");
          if (!r3 || 3 !== r3.length) return null;
          try {
            return JSON.parse(decodeURIComponent(e.atob(r3[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t3) {
            return null;
          }
        }
        class kt {
          constructor(t2) {
            this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t2) {
            const r3 = St(i.ACCESS_TOKEN);
            let n2 = "";
            return n2 = r3 && r3.u ? e.btoa(encodeURIComponent(r3.u).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2)))) : i.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${n2}` : `mapbox.eventData:${n2}`;
          }
          fetchEventData() {
            const t2 = K("localStorage"), r3 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
            if (t2) try {
              const t3 = e.localStorage.getItem(r3);
              t3 && (this.eventData = JSON.parse(t3));
              const i2 = e.localStorage.getItem(n2);
              i2 && (this.anonId = i2);
            } catch (t3) {
              U("Unable to read from LocalStorage");
            }
          }
          saveEventData() {
            const t2 = K("localStorage"), r3 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
            if (t2) try {
              e.localStorage.setItem(n2, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r3, JSON.stringify(this.eventData));
            } catch (t3) {
              U("Unable to write to LocalStorage");
            }
          }
          processRequests(t2) {
          }
          postEvent(t2, e2, r3, n2) {
            if (!i.EVENTS_URL) return;
            const s2 = _t(i.EVENTS_URL);
            s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
            const a2 = { event: this.type, created: new Date(t2).toISOString() }, o2 = e2 ? z(a2, e2) : a2, l2 = { url: At(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
            this.pendingRequest = function(t3, e3) {
              return lt(z(t3, { method: "POST" }), e3);
            }(l2, (t3) => {
              this.pendingRequest = null, r3(t3), this.saveEventData(), this.processRequests(n2);
            });
          }
          queueRequest(t2, e2) {
            this.queue.push(t2), this.processRequests(e2);
          }
        }
        const It = new class extends kt {
          constructor(t2) {
            super("appUserTurnstile"), this._customAccessToken = t2;
          }
          postTurnstileEvent(t2, e2) {
            i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => mt(t3) || gt(t3)) && this.queueRequest(Date.now(), e2);
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const e2 = St(i.ACCESS_TOKEN), n2 = e2 ? e2.u : i.ACCESS_TOKEN;
            let s2 = n2 !== this.eventData.tokenU;
            D(this.anonId) || (this.anonId = C(), s2 = true);
            const a2 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(a2), r3 = (a2 - this.eventData.lastSuccess) / 864e5;
              s2 = s2 || r3 >= 1 || r3 < -1 || t3.getDate() !== e3.getDate();
            } else s2 = true;
            s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r2, skuId: h, "enabled.telemetry": false, userId: this.anonId }, (t3) => {
              t3 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = n2);
            }, t2) : this.processRequests();
          }
        }(), Mt = It.postTurnstileEvent.bind(It), Tt = new class extends kt {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t2, e2, r3, n2) {
            this.skuToken = e2, this.errorCb = n2, i.EVENTS_URL && (r3 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r3) : this.errorCb(new Error(yt)));
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: e2, timestamp: n2 } = this.queue.shift();
            e2 && this.success[e2] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r2, skuId: h, skuToken: this.skuToken, userId: this.anonId }, (t3) => {
              t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
            }, t2));
          }
        }(), zt = Tt.postMapLoadEvent.bind(Tt), Bt = new class extends kt {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t2, e2) {
            i.EVENTS_URL && (t2 || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e2 }, t2);
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: n2, performanceData: i2 } = this.queue.shift(), s2 = function(t3) {
              const n3 = e.performance.getEntriesByType("resource"), i3 = e.performance.getEntriesByType("mark"), s3 = function(t4) {
                const e2 = {};
                if (t4) {
                  for (const r3 in t4) if ("other" !== r3) for (const n4 of t4[r3]) {
                    const t5 = `${r3}ResolveRangeMin`, i4 = `${r3}ResolveRangeMax`, s4 = `${r3}RequestCount`, a3 = `${r3}RequestCachedCount`;
                    e2[t5] = Math.min(e2[t5] || 1 / 0, n4.startTime), e2[i4] = Math.max(e2[i4] || -1 / 0, n4.responseEnd);
                    const o3 = (t6) => {
                      void 0 === e2[t6] && (e2[t6] = 0), ++e2[t6];
                    };
                    void 0 !== n4.transferSize && 0 === n4.transferSize && o3(a3), o3(s4);
                  }
                }
                return e2;
              }(function(t4, e2) {
                const r3 = {};
                if (t4) for (const n4 of t4) {
                  const t5 = e2(n4);
                  void 0 === r3[t5] && (r3[t5] = []), r3[t5].push(n4);
                }
                return r3;
              }(n3, Ft)), a2 = e.devicePixelRatio, o2 = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection, l2 = { counters: [], metadata: [], attributes: [] }, u2 = (t4, e2, r3) => {
                null != r3 && t4.push({ name: e2, value: r3.toString() });
              };
              for (const t4 in s3) u2(l2.counters, t4, s3[t4]);
              if (t3.interactionRange[0] !== 1 / 0 && t3.interactionRange[1] !== -1 / 0 && (u2(l2.counters, "interactionRangeMin", t3.interactionRange[0]), u2(l2.counters, "interactionRangeMax", t3.interactionRange[1])), i3) for (const t4 of Object.keys(Vt)) {
                const e2 = Vt[t4], r3 = i3.find((t5) => t5.name === e2);
                r3 && u2(l2.counters, e2, r3.startTime);
              }
              return u2(l2.counters, "visibilityHidden", t3.visibilityHidden), u2(l2.attributes, "style", function(t4) {
                if (t4) for (const e2 of t4) {
                  const t5 = e2.name.split("?")[0];
                  if (vt(t5)) {
                    const e3 = t5.split("/").slice(-2);
                    if (2 === e3.length) return `mapbox://styles/${e3[0]}/${e3[1]}`;
                  }
                }
              }(n3)), u2(l2.attributes, "terrainEnabled", t3.terrainEnabled ? "true" : "false"), u2(l2.attributes, "fogEnabled", t3.fogEnabled ? "true" : "false"), u2(l2.attributes, "projection", t3.projection), u2(l2.attributes, "zoom", t3.zoom), u2(l2.metadata, "devicePixelRatio", a2), u2(l2.metadata, "connectionEffectiveType", o2 ? o2.effectiveType : void 0), u2(l2.metadata, "navigatorUserAgent", e.navigator.userAgent), u2(l2.metadata, "screenWidth", e.screen.width), u2(l2.metadata, "screenHeight", e.screen.height), u2(l2.metadata, "windowWidth", e.innerWidth), u2(l2.metadata, "windowHeight", e.innerHeight), u2(l2.metadata, "mapWidth", t3.width / a2), u2(l2.metadata, "mapHeight", t3.height / a2), u2(l2.metadata, "webglRenderer", t3.renderer), u2(l2.metadata, "webglVendor", t3.vendor), u2(l2.metadata, "sdkVersion", r2), u2(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
            }(i2);
            for (const t3 of s2.metadata) ;
            for (const t3 of s2.counters) ;
            for (const t3 of s2.attributes) ;
            this.postEvent(n2, s2, () => {
            }, t2);
          }
        }(), Et = Bt.postPerformanceEvent.bind(Bt), Ct = new class extends kt {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t2, e2, r3, n2) {
            if (!i.API_URL || !i.SESSION_PATH) return;
            const s2 = _t(i.API_URL + i.SESSION_PATH);
            s2.params.push(`sku=${e2 || ""}`), s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
            const a2 = { url: At(s2), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = function(t3, e3) {
              return lt(z(t3, { method: "GET" }), e3);
            }(a2, (t3) => {
              this.pendingRequest = null, r3(t3), this.saveEventData(), this.processRequests(n2);
            });
          }
          getSessionAPI(t2, e2, r3, n2) {
            this.skuToken = e2, this.errorCb = n2, i.SESSION_PATH && i.API_URL && (r3 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r3) : this.errorCb(new Error(yt)));
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: e2, timestamp: r3 } = this.queue.shift();
            e2 && this.success[e2] || this.getSession(r3, this.skuToken, (t3) => {
              t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
            }, t2);
          }
        }(), Pt = Ct.getSessionAPI.bind(Ct), Dt = /* @__PURE__ */ new Set(), Vt = { create: "create", load: "load", fullLoad: "fullLoad" }, Lt = { mark(t2) {
          e.performance.mark(t2);
        }, measure(t2, r3, n2) {
          e.performance.measure(t2, r3, n2);
        } };
        function Ft(t2) {
          const e2 = t2.name.split("?")[0];
          return xt(e2) && e2.includes("mapbox-gl.js") ? "javascript" : xt(e2) && e2.includes("mapbox-gl.css") ? "css" : function(t3) {
            return i.API_FONTS_REGEX.test(t3);
          }(e2) ? "fontRange" : bt(e2) ? "sprite" : vt(e2) ? "style" : function(t3) {
            return i.API_TILEJSON_REGEX.test(t3);
          }(e2) ? "tilejson" : "other";
        }
        const Rt = e.performance;
        function jt(t2) {
          const e2 = t2 ? t2.url.toString() : void 0;
          return Rt.getEntriesByName(e2);
        }
        let $t, Ut, Ot, qt;
        const Nt = { now: () => void 0 !== Ot ? Ot : e.performance.now(), setNow(t2) {
          Ot = t2;
        }, restoreNow() {
          Ot = void 0;
        }, frame(t2) {
          const r3 = e.requestAnimationFrame(t2);
          return { cancel: () => e.cancelAnimationFrame(r3) };
        }, getImageData(t2, r3 = 0) {
          const { width: n2, height: i2 } = t2;
          qt || (qt = e.document.createElement("canvas"));
          const s2 = qt.getContext("2d", { willReadFrequently: true });
          if (!s2) throw new Error("failed to create canvas 2d context");
          return (n2 > qt.width || i2 > qt.height) && (qt.width = n2, qt.height = i2), s2.clearRect(-r3, -r3, n2 + 2 * r3, i2 + 2 * r3), s2.drawImage(t2, 0, 0, n2, i2), s2.getImageData(-r3, -r3, n2 + 2 * r3, i2 + 2 * r3);
        }, resolveURL: (t2) => ($t || ($t = e.document.createElement("a")), $t.href = t2, $t.href), get devicePixelRatio() {
          return e.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!e.matchMedia && (null == Ut && (Ut = e.matchMedia("(prefers-reduced-motion: reduce)")), Ut.matches);
        } };
        function Gt(t2, e2, r3) {
          r3[t2] && -1 !== r3[t2].indexOf(e2) || (r3[t2] = r3[t2] || [], r3[t2].push(e2));
        }
        function Zt(t2, e2, r3) {
          if (r3 && r3[t2]) {
            const n2 = r3[t2].indexOf(e2);
            -1 !== n2 && r3[t2].splice(n2, 1);
          }
        }
        class Xt {
          constructor(t2, e2 = {}) {
            z(this, e2), this.type = t2;
          }
        }
        class Kt extends Xt {
          constructor(t2, e2 = {}) {
            super("error", z({ error: t2 }, e2));
          }
        }
        class Yt {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, Gt(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return Zt(t2, e2, this._listeners), Zt(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
          }
          fire(t2, e2) {
            "string" == typeof t2 && (t2 = new Xt(t2, e2 || {}));
            const r3 = t2.type;
            if (this.listens(r3)) {
              t2.target = this;
              const e3 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
              for (const r4 of e3) r4.call(this, t2);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
              for (const e4 of n2) Zt(r3, e4, this._oneTimeListeners), e4.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (z(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else t2 instanceof Kt && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Wt(t2, ...e2) {
          for (const r3 of e2) for (const e3 in r3) t2[e3] = r3[e3];
          return t2;
        }
        function Jt(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function Qt(t2) {
          if (Array.isArray(t2)) return t2.map(Qt);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r3 in t2) e2[r3] = Qt(t2[r3]);
            return e2;
          }
          return Jt(t2);
        }
        class te extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        var ee = te;
        class re {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r3] of e2) this.bindings[t3] = r3;
          }
          concat(t2) {
            return new re(this, t2);
          }
          get(t2) {
            if (this.bindings[t2]) return this.bindings[t2];
            if (this.parent) return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        var ne = re;
        const ie = { kind: "null" }, se = { kind: "number" }, ae = { kind: "string" }, oe = { kind: "boolean" }, le = { kind: "color" }, ue = { kind: "object" }, ce = { kind: "value" }, he = { kind: "collator" }, pe = { kind: "formatted" }, fe = { kind: "resolvedImage" };
        function de(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function ye(t2) {
          if ("array" === t2.kind) {
            const e2 = ye(t2.itemType);
            return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        const me = [ie, se, ae, oe, le, pe, ue, de(ce), fe];
        function ge(t2, e2) {
          if ("error" === e2.kind) return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !ge(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
          } else {
            if (t2.kind === e2.kind) return null;
            if ("value" === t2.kind) {
              for (const t3 of me) if (!ge(t3, e2)) return null;
            }
          }
          return `Expected ${ye(t2)} but found ${ye(e2)} instead.`;
        }
        function xe(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function ve(t2, e2) {
          return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
        }
        var be, we = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function _e(t2) {
          return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
        }
        function Ae(t2) {
          return _e("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
        }
        function Se(t2) {
          return (e2 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
          var e2;
        }
        function ke(t2, e2, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t2 + (e2 - t2) * r3 * 6 : 2 * r3 < 1 ? e2 : 3 * r3 < 2 ? t2 + (e2 - t2) * (2 / 3 - r3) * 6 : t2;
        }
        try {
          be = {}.parseCSSColor = function(t2) {
            var e2, r3 = t2.replace(/ /g, "").toLowerCase();
            if (r3 in we) return we[r3].slice();
            if ("#" === r3[0]) return 4 === r3.length ? (e2 = parseInt(r3.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : 7 === r3.length && (e2 = parseInt(r3.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
            var n2 = r3.indexOf("("), i2 = r3.indexOf(")");
            if (-1 !== n2 && i2 + 1 === r3.length) {
              var s2 = r3.substr(0, n2), a2 = r3.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
              switch (s2) {
                case "rgba":
                  if (4 !== a2.length) return null;
                  o2 = Se(a2.pop());
                case "rgb":
                  return 3 !== a2.length ? null : [Ae(a2[0]), Ae(a2[1]), Ae(a2[2]), o2];
                case "hsla":
                  if (4 !== a2.length) return null;
                  o2 = Se(a2.pop());
                case "hsl":
                  if (3 !== a2.length) return null;
                  var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Se(a2[1]), c2 = Se(a2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                  return [_e(255 * ke(p2, h2, l2 + 1 / 3)), _e(255 * ke(p2, h2, l2)), _e(255 * ke(p2, h2, l2 - 1 / 3)), o2];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t2) {
        }
        class Ie {
          constructor(t2, e2, r3, n2 = 1) {
            this.r = t2, this.g = e2, this.b = r3, this.a = n2;
          }
          static parse(t2) {
            if (!t2) return;
            if (t2 instanceof Ie) return t2;
            if ("string" != typeof t2) return;
            const e2 = be(t2);
            return e2 ? new Ie(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
          }
          toString() {
            const [t2, e2, r3, n2] = this.toArray();
            return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r3)},${n2})`;
          }
          toArray() {
            const { r: t2, g: e2, b: r3, a: n2 } = this;
            return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r3 / n2, n2];
          }
          toArray01() {
            const { r: t2, g: e2, b: r3, a: n2 } = this;
            return 0 === n2 ? [0, 0, 0, 0] : [t2 / n2, e2 / n2, r3 / n2, n2];
          }
          toArray01PremultipliedAlpha() {
            const { r: t2, g: e2, b: r3, a: n2 } = this;
            return [t2, e2, r3, n2];
          }
        }
        Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
        var Me = Ie;
        class Te {
          constructor(t2, e2, r3) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class ze {
          constructor(t2, e2, r3, n2, i2) {
            this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r3, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Be {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Be([new ze(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
          }
          static factory(t2) {
            return t2 instanceof Be ? t2 : Be.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              if (e2.image) {
                t2.push(["image", e2.image.name]);
                continue;
              }
              t2.push(e2.text);
              const r3 = {};
              e2.fontStack && (r3["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r3["font-scale"] = e2.scale), e2.textColor && (r3["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r3);
            }
            return t2;
          }
        }
        class Ee {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new Ee({ name: t2, available: false }) : null;
          }
          serialize() {
            return ["image", this.name];
          }
        }
        function Ce(t2, e2, r3, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r3 && r3 >= 0 && r3 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r3, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r3, n2] : [t2, e2, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Pe(t2) {
          if (null === t2) return true;
          if ("string" == typeof t2) return true;
          if ("boolean" == typeof t2) return true;
          if ("number" == typeof t2) return true;
          if (t2 instanceof Me) return true;
          if (t2 instanceof Te) return true;
          if (t2 instanceof Be) return true;
          if (t2 instanceof Ee) return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2) if (!Pe(e2)) return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2) if (!Pe(t2[e2])) return false;
            return true;
          }
          return false;
        }
        function De(t2) {
          if (null === t2) return ie;
          if ("string" == typeof t2) return ae;
          if ("boolean" == typeof t2) return oe;
          if ("number" == typeof t2) return se;
          if (t2 instanceof Me) return le;
          if (t2 instanceof Te) return he;
          if (t2 instanceof Be) return pe;
          if (t2 instanceof Ee) return fe;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r3;
            for (const e3 of t2) {
              const t3 = De(e3);
              if (r3) {
                if (r3 === t3) continue;
                r3 = ce;
                break;
              }
              r3 = t3;
            }
            return de(r3 || ce, e2);
          }
          return ue;
        }
        function Ve(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Me || t2 instanceof Be || t2 instanceof Ee ? t2.toString() : JSON.stringify(t2);
        }
        class Le {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!Pe(t2[1])) return e2.error("invalid value");
            const r3 = t2[1];
            let n2 = De(r3);
            const i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new Le(n2, r3);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
          }
        }
        var Fe = Le, Re = class {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        };
        const je = { string: ae, number: se, boolean: oe, object: ue };
        class $e {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            let r3, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r4 = t2[1];
                if ("string" != typeof r4 || !(r4 in je) || "object" === r4) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = je[r4], n2++;
              } else i3 = ce;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r3 = de(i3, s3);
            } else r3 = je[i2];
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r4 = e2.parse(t2[n2], n2, ce);
              if (!r4) return null;
              s2.push(r4);
            }
            return new $e(r3, s2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r3 = this.args[e2].evaluate(t2);
              if (!ge(this.type, De(r3))) return r3;
              if (e2 === this.args.length - 1) throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r3))} instead.`);
            }
            return null;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = this.type, e2 = [t2.kind];
            if ("array" === t2.kind) {
              const r3 = t2.itemType;
              if ("string" === r3.kind || "number" === r3.kind || "boolean" === r3.kind) {
                e2.push(r3.kind);
                const n2 = t2.N;
                ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
              }
            }
            return e2.concat(this.args.map((t3) => t3.serialize()));
          }
        }
        var Ue = $e;
        class Oe {
          constructor(t2) {
            this.type = pe, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r3 = t2[1];
            if (!Array.isArray(r3) && "object" == typeof r3) return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r4 = 1; r4 <= t2.length - 1; ++r4) {
              const s2 = t2[r4];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, se), !t3)) return null;
                let r5 = null;
                if (s2["text-font"] && (r5 = e2.parse(s2["text-font"], 1, de(ae)), !r5)) return null;
                let a2 = null;
                if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, le), !a2)) return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t3, o2.font = r5, o2.textColor = a2;
              } else {
                const s3 = e2.parse(t2[r4], 1, ce);
                if (!s3) return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
              }
            }
            return new Oe(n2);
          }
          evaluate(t2) {
            return new Be(this.sections.map((e2) => {
              const r3 = e2.content.evaluate(t2);
              return De(r3) === fe ? new ze("", r3, null, null, null) : new ze(Ve(r3), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              t2.push(e2.content.serialize());
              const r3 = {};
              e2.scale && (r3["font-scale"] = e2.scale.serialize()), e2.font && (r3["text-font"] = e2.font.serialize()), e2.textColor && (r3["text-color"] = e2.textColor.serialize()), t2.push(r3);
            }
            return t2;
          }
        }
        class qe {
          constructor(t2) {
            this.type = fe, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected two arguments.");
            const r3 = e2.parse(t2[1], 1, ae);
            return r3 ? new qe(r3) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r3 = Ee.fromString(e2);
            return r3 && t2.availableImages && (r3.available = t2.availableImages.indexOf(e2) > -1), r3;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["image", this.input.serialize()];
          }
        }
        const Ne = { "to-boolean": oe, "to-color": le, "to-number": se, "to-string": ae };
        class Ge {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r3 = t2[0];
            if (("to-boolean" === r3 || "to-string" === r3) && 2 !== t2.length) return e2.error("Expected one argument.");
            const n2 = Ne[r3], i2 = [];
            for (let r4 = 1; r4 < t2.length; r4++) {
              const n3 = e2.parse(t2[r4], r4, ce);
              if (!n3) return null;
              i2.push(n3);
            }
            return new Ge(n2, i2);
          }
          evaluate(t2) {
            if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t2));
            if ("color" === this.type.kind) {
              let e2, r3;
              for (const n2 of this.args) {
                if (e2 = n2.evaluate(t2), r3 = null, e2 instanceof Me) return e2;
                if ("string" == typeof e2) {
                  const r4 = t2.parseColor(e2);
                  if (r4) return r4;
                } else if (Array.isArray(e2) && (r3 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ce(e2[0], e2[1], e2[2], e2[3]), !r3)) return new Me(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new Re(r3 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
            }
            if ("number" === this.type.kind) {
              let e2 = null;
              for (const r3 of this.args) {
                if (e2 = r3.evaluate(t2), null === e2) return 0;
                const n2 = Number(e2);
                if (!isNaN(n2)) return n2;
              }
              throw new Re(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t2))) : Ve(this.args[0].evaluate(t2));
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind) return new Oe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind) return new qe(this.args[0]).serialize();
            const t2 = [`to-${this.type.kind}`];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var Ze = Ge;
        const Xe = ["Unknown", "Point", "LineString", "Polygon"];
        var Ke = class {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Xe[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r3, y: n2 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r3 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
            }
            return 0;
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = Me.parse(t2)), e2;
          }
        };
        class Ye {
          constructor(t2, e2, r3, n2) {
            this.name = t2, this.type = e2, this._evaluate = r3, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t2) => t2.serialize()));
          }
          static parse(t2, e2) {
            const r3 = t2[0], n2 = Ye.definitions[r3];
            if (!n2) return e2.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
            let o2 = null;
            for (const [n3, s3] of a2) {
              o2 = new _r(e2.registry, e2.path, null, e2.scope);
              const a3 = [];
              let l2 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r4 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r4, 1 + a3.length, i3);
                if (!s4) {
                  l2 = true;
                  break;
                }
                a3.push(s4);
              }
              if (!l2) if (Array.isArray(n3) && n3.length !== a3.length) o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0; t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r4 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r4.type);
                }
                if (0 === o2.errors.length) return new Ye(r3, i2, s3, a3);
              }
            }
            if (1 === a2.length) e2.errors.push(...o2.errors);
            else {
              const r4 = (a2.length ? a2 : s2).map(([t3]) => {
                return e3 = t3, Array.isArray(e3) ? `(${e3.map(ye).join(", ")})` : `(${ye(e3.type)}...)`;
                var e3;
              }).join(" | "), n3 = [];
              for (let r5 = 1; r5 < t2.length; r5++) {
                const i3 = e2.parse(t2[r5], 1 + n3.length);
                if (!i3) return null;
                n3.push(ye(i3.type));
              }
              e2.error(`Expected arguments of type ${r4}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            Ye.definitions = e2;
            for (const r3 in e2) t2[r3] = Ye;
          }
        }
        var He = Ye;
        class We {
          constructor(t2, e2, r3) {
            this.type = he, this.locale = r3, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected one argument.");
            const r3 = t2[1];
            if ("object" != typeof r3 || Array.isArray(r3)) return e2.error("Collator options argument must be an object.");
            const n2 = e2.parse(void 0 !== r3["case-sensitive"] && r3["case-sensitive"], 1, oe);
            if (!n2) return null;
            const i2 = e2.parse(void 0 !== r3["diacritic-sensitive"] && r3["diacritic-sensitive"], 1, oe);
            if (!i2) return null;
            let s2 = null;
            return r3.locale && (s2 = e2.parse(r3.locale, 1, ae), !s2) ? null : new We(n2, i2, s2);
          }
          evaluate(t2) {
            return new Te(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
          }
        }
        const Je = 8192;
        function Qe(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function tr(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function er(t2, e2) {
          const r3 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r3 * i2 * Je), Math.round(n2 * i2 * Je)];
        }
        function rr(t2, e2, r3) {
          const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r3[0], a2 = t2[1] - r3[1];
          return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function nr(t2, e2) {
          let r3 = false;
          for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
            const o3 = e2[a2];
            for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
              if (rr(t2, o3[e3], o3[e3 + 1])) return false;
              (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r3 = !r3);
            }
          }
          var n2, i2, s2;
          return r3;
        }
        function ir(t2, e2) {
          for (let r3 = 0; r3 < e2.length; r3++) if (nr(t2, e2[r3])) return true;
          return false;
        }
        function sr(t2, e2, r3, n2) {
          const i2 = n2[0] - r3[0], s2 = n2[1] - r3[1], a2 = (t2[0] - r3[0]) * s2 - i2 * (t2[1] - r3[1]), o2 = (e2[0] - r3[0]) * s2 - i2 * (e2[1] - r3[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function ar(t2, e2, r3) {
          for (const u2 of r3) for (let r4 = 0; r4 < u2.length - 1; ++r4) if (0 != (o2 = [(a2 = u2[r4 + 1])[0] - (s2 = u2[r4])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && sr(n2, i2, s2, a2) && sr(s2, a2, n2, i2)) return true;
          var n2, i2, s2, a2, o2, l2;
          return false;
        }
        function or(t2, e2) {
          for (let r3 = 0; r3 < t2.length; ++r3) if (!nr(t2[r3], e2)) return false;
          for (let r3 = 0; r3 < t2.length - 1; ++r3) if (ar(t2[r3], t2[r3 + 1], e2)) return false;
          return true;
        }
        function lr(t2, e2) {
          for (let r3 = 0; r3 < e2.length; r3++) if (or(t2, e2[r3])) return true;
          return false;
        }
        function ur(t2, e2, r3) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = er(t2[i2][n3], r3);
              Qe(e2, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function cr(t2, e2, r3) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = ur(t2[i2], e2, r3);
            n2.push(s2);
          }
          return n2;
        }
        function hr(t2, e2, r3, n2) {
          if (t2[0] < r3[0] || t2[0] > r3[2]) {
            const e3 = 0.5 * n2;
            let i2 = t2[0] - r3[0] > e3 ? -n2 : r3[0] - t2[0] > e3 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r3[2] > e3 ? -n2 : r3[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          Qe(e2, t2);
        }
        function pr(t2, e2, r3, n2) {
          const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
          if (!t2) return a2;
          for (const n3 of t2) for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            hr(n4, e2, r3, i2), a2.push(n4);
          }
          return a2;
        }
        function fr(t2, e2, r3, n2) {
          const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
          if (!t2) return a2;
          for (const r4 of t2) {
            const t3 = [];
            for (const n3 of r4) {
              const r5 = [n3.x + s2[0], n3.y + s2[1]];
              Qe(e2, r5), t3.push(r5);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2) for (const n3 of t3) hr(n3, e2, r3, i2);
          }
          var o2;
          return a2;
        }
        class dr {
          constructor(t2, e2) {
            this.type = oe, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (Pe(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r3 = e3.features[t3].geometry.type;
                if ("Polygon" === r3 || "MultiPolygon" === r3) return new dr(e3, e3.features[t3].geometry);
              }
              else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3) return new dr(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new dr(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return function(t3, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2) return false;
                if ("Polygon" === e2.type) {
                  const s2 = ur(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r3, n2, i2);
                  if (!tr(r3, n2)) return false;
                  for (const t4 of a2) if (!nr(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = cr(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r3, n2, i2);
                  if (!tr(r3, n2)) return false;
                  for (const t4 of a2) if (!ir(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return function(t3, e2) {
                const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2) return false;
                if ("Polygon" === e2.type) {
                  const s2 = ur(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r3, n2, i2);
                  if (!tr(r3, n2)) return false;
                  for (const t4 of a2) if (!or(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = cr(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r3, n2, i2);
                  if (!tr(r3, n2)) return false;
                  for (const t4 of a2) if (!lr(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        var yr = dr;
        function mr(t2) {
          if (t2 instanceof He) {
            if ("get" === t2.name && 1 === t2.args.length) return false;
            if ("feature-state" === t2.name) return false;
            if ("has" === t2.name && 1 === t2.args.length) return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
            if (/^filter-/.test(t2.name)) return false;
          }
          if (t2 instanceof yr) return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !mr(t3) && (e2 = false);
          }), e2;
        }
        function gr(t2) {
          if (t2 instanceof He && "feature-state" === t2.name) return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !gr(t3) && (e2 = false);
          }), e2;
        }
        function xr(t2, e2) {
          if (t2 instanceof He && e2.indexOf(t2.name) >= 0) return false;
          let r3 = true;
          return t2.eachChild((t3) => {
            r3 && !xr(t3, e2) && (r3 = false);
          }), r3;
        }
        class vr {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
            const r3 = t2[1];
            return e2.scope.has(r3) ? new vr(r3, e2.scope.get(r3)) : e2.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        var br = vr;
        class wr {
          constructor(t2, e2 = [], r3, n2 = new ne(), i2 = []) {
            this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r3;
          }
          parse(t2, e2, r3, n2, i2 = {}) {
            return e2 ? this.concat(e2, r3, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r3(t3, e3, r4) {
              return "assert" === r4 ? new Ue(e3, [t3]) : "coerce" === r4 ? new Ze(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t2[0];
              if ("string" != typeof n2) return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3) return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n3.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind) if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) {
                    if (this.checkSubtype(t3, i3)) return null;
                  } else n3 = r3(n3, t3, e2.typeAnnotation || "coerce");
                  else n3 = r3(n3, t3, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof Fe) && "resolvedImage" !== n3.type.kind && Ar(n3)) {
                  const t3 = new Ke();
                  try {
                    n3 = new Fe(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r3) {
            const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r3 ? this.scope.concat(r3) : this.scope;
            return new wr(this.registry, n2, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            const r3 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new ee(r3, t2));
          }
          checkSubtype(t2, e2) {
            const r3 = ge(t2, e2);
            return r3 && this.error(r3), r3;
          }
        }
        var _r = wr;
        function Ar(t2) {
          if (t2 instanceof br) return Ar(t2.boundExpression);
          if (t2 instanceof He && "error" === t2.name) return false;
          if (t2 instanceof We) return false;
          if (t2 instanceof yr) return false;
          const e2 = t2 instanceof Ze || t2 instanceof Ue;
          let r3 = true;
          return t2.eachChild((t3) => {
            r3 = e2 ? r3 && Ar(t3) : r3 && t3 instanceof Fe;
          }), !!r3 && mr(t2) && xr(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
        }
        function Sr(t2, e2) {
          const r3 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r3, o2 = 0;
          for (; s2 <= a2; ) if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r3 || e2 < i2) return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2)) throw new Re("Input is not a number.");
            a2 = o2 - 1;
          }
          return 0;
        }
        class kr {
          constructor(t2, e2, r3) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r3) this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            const r3 = e2.parse(t2[1], 1, se);
            if (!r3) return null;
            const n2 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r4 = 1; r4 < t2.length; r4 += 2) {
              const s2 = 1 === r4 ? -1 / 0 : t2[r4], a2 = t2[r4 + 1], o2 = r4, l2 = r4 + 1;
              if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(a2, l2, i2);
              if (!u2) return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new kr(i2, r3, n2);
          }
          evaluate(t2) {
            const e2 = this.labels, r3 = this.outputs;
            if (1 === e2.length) return r3[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r3[0].evaluate(t2);
            const i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r3[i2 - 1].evaluate(t2) : r3[Sr(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["step", this.input.serialize()];
            for (let e2 = 0; e2 < this.labels.length; e2++) e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
            return t2;
          }
        }
        var Ir = kr;
        function Mr(t2, e2, r3) {
          return t2 * (1 - r3) + e2 * r3;
        }
        var Tr = Object.freeze({ __proto__: null, number: Mr, color: function(t2, e2, r3) {
          return new Me(Mr(t2.r, e2.r, r3), Mr(t2.g, e2.g, r3), Mr(t2.b, e2.b, r3), Mr(t2.a, e2.a, r3));
        }, array: function(t2, e2, r3) {
          return t2.map((t3, n2) => Mr(t3, e2[n2], r3));
        } });
        const zr = 0.95047, Br = 1.08883, Er = 4 / 29, Cr = 6 / 29, Pr = 3 * Cr * Cr, Dr = Math.PI / 180, Vr = 180 / Math.PI;
        function Lr(t2) {
          return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pr + Er;
        }
        function Fr(t2) {
          return t2 > Cr ? t2 * t2 * t2 : Pr * (t2 - Er);
        }
        function Rr(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function jr(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function $r(t2) {
          const e2 = jr(t2.r), r3 = jr(t2.g), n2 = jr(t2.b), i2 = Lr((0.4124564 * e2 + 0.3575761 * r3 + 0.1804375 * n2) / zr), s2 = Lr((0.2126729 * e2 + 0.7151522 * r3 + 0.072175 * n2) / 1);
          return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Lr((0.0193339 * e2 + 0.119192 * r3 + 0.9503041 * n2) / Br)), alpha: t2.a };
        }
        function Ur(t2) {
          let e2 = (t2.l + 16) / 116, r3 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
          return e2 = 1 * Fr(e2), r3 = zr * Fr(r3), n2 = Br * Fr(n2), new Me(Rr(3.2404542 * r3 - 1.5371385 * e2 - 0.4985314 * n2), Rr(-0.969266 * r3 + 1.8760108 * e2 + 0.041556 * n2), Rr(0.0556434 * r3 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
        }
        function Or(t2, e2, r3) {
          const n2 = e2 - t2;
          return t2 + r3 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        const qr = { forward: $r, reverse: Ur, interpolate: function(t2, e2, r3) {
          return { l: Mr(t2.l, e2.l, r3), a: Mr(t2.a, e2.a, r3), b: Mr(t2.b, e2.b, r3), alpha: Mr(t2.alpha, e2.alpha, r3) };
        } }, Nr = { forward: function(t2) {
          const { l: e2, a: r3, b: n2 } = $r(t2), i2 = Math.atan2(n2, r3) * Vr;
          return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r3 * r3 + n2 * n2), l: e2, alpha: t2.a };
        }, reverse: function(t2) {
          const e2 = t2.h * Dr, r3 = t2.c;
          return Ur({ l: t2.l, a: Math.cos(e2) * r3, b: Math.sin(e2) * r3, alpha: t2.alpha });
        }, interpolate: function(t2, e2, r3) {
          return { h: Or(t2.h, e2.h, r3), c: Mr(t2.c, e2.c, r3), l: Mr(t2.l, e2.l, r3), alpha: Mr(t2.alpha, e2.alpha, r3) };
        } };
        var Gr = Object.freeze({ __proto__: null, lab: qr, hcl: Nr });
        class Zr {
          constructor(t2, e2, r3, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r3, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r3, n2) {
            let i2 = 0;
            if ("exponential" === t2.name) i2 = Xr(e2, t2.base, r3, n2);
            else if ("linear" === t2.name) i2 = Xr(e2, 1, r3, n2);
            else if ("cubic-bezier" === t2.name) {
              const s2 = t2.controlPoints;
              i2 = new p(s2[0], s2[1], s2[2], s2[3]).solve(Xr(e2, 1, r3, n2));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r3, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0]) n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0]) return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, se), !i2) return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r3 || "interpolate-lab" === r3 ? o2 = le : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r4 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if ("number" != typeof r4) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r4) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e2.parse(n3, l2, o2);
              if (!u2) return null;
              o2 = o2 || u2.type, a2.push([r4, u2]);
            }
            return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Zr(o2, r3, n2, i2, a2) : e2.error(`Type ${ye(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e2 = this.labels, r3 = this.outputs;
            if (1 === e2.length) return r3[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r3[0].evaluate(t2);
            const i2 = e2.length;
            if (n2 >= e2[i2 - 1]) return r3[i2 - 1].evaluate(t2);
            const s2 = Sr(e2, n2), a2 = Zr.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r3[s2].evaluate(t2), l2 = r3[s2 + 1].evaluate(t2);
            return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o2), Nr.forward(l2), a2)) : qr.reverse(qr.interpolate(qr.forward(o2), qr.forward(l2), a2));
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            let t2;
            t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e2 = [this.operator, t2, this.input.serialize()];
            for (let t3 = 0; t3 < this.labels.length; t3++) e2.push(this.labels[t3], this.outputs[t3].serialize());
            return e2;
          }
        }
        function Xr(t2, e2, r3, n2) {
          const i2 = n2 - r3, s2 = t2 - r3;
          return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
        }
        var Kr = Zr;
        class Yr {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expectected at least one argument.");
            let r3 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r3 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e2.parse(n3, 1 + i2.length, r3, void 0, { typeAnnotation: "omit" });
              if (!t3) return null;
              r3 = r3 || t3.type, i2.push(t3);
            }
            const s2 = n2 && i2.some((t3) => ge(n2, t3.type));
            return new Yr(s2 ? ce : r3, i2);
          }
          evaluate(t2) {
            let e2, r3 = null, n2 = 0;
            for (const i2 of this.args) {
              if (n2++, r3 = i2.evaluate(t2), r3 && r3 instanceof Ee && !r3.available && (e2 || (e2 = r3), r3 = null, n2 === this.args.length)) return e2;
              if (null !== r3) break;
            }
            return r3;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["coalesce"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var Hr = Yr;
        class Wr {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings) t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r3 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2) return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!s2) return null;
              r3.push([i2, s2]);
            }
            const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r3);
            return n2 ? new Wr(r3, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t2 = ["let"];
            for (const [e2, r3] of this.bindings) t2.push(e2, r3.serialize());
            return t2.push(this.result.serialize()), t2;
          }
        }
        var Jr = Wr;
        class Qr {
          constructor(t2, e2, r3) {
            this.type = t2, this.index = e2, this.input = r3;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r3 = e2.parse(t2[1], 1, se), n2 = e2.parse(t2[2], 2, de(e2.expectedType || ce));
            return r3 && n2 ? new Qr(n2.type.itemType, r3, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r3 = this.input.evaluate(t2);
            if (e2 < 0) throw new Re(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r3.length) throw new Re(`Array index out of bounds: ${e2} > ${r3.length - 1}.`);
            if (e2 !== Math.floor(e2)) throw new Re(`Array index must be an integer, but found ${e2} instead.`);
            return r3[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        var tn = Qr;
        class en {
          constructor(t2, e2) {
            this.type = oe, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r3 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
            return r3 && n2 ? xe(r3.type, [oe, ae, se, ie, ce]) ? new en(r3, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r3.type)} instead`) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r3 = this.haystack.evaluate(t2);
            if (null == r3) return false;
            if (!ve(e2, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
            if (!ve(r3, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r3))} instead.`);
            return r3.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var rn = en;
        class nn {
          constructor(t2, e2, r3) {
            this.type = se, this.needle = t2, this.haystack = e2, this.fromIndex = r3;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r3 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
            if (!r3 || !n2) return null;
            if (!xe(r3.type, [oe, ae, se, ie, ce])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r3.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, se);
              return i2 ? new nn(r3, n2, i2) : null;
            }
            return new nn(r3, n2);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r3 = this.haystack.evaluate(t2);
            if (!ve(e2, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
            if (!ve(r3, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r3))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t2);
              return r3.indexOf(e2, n2);
            }
            return r3.indexOf(e2);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t2 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var sn = nn;
        class an {
          constructor(t2, e2, r3, n2, i2, s2) {
            this.inputType = t2, this.type = e2, this.input = r3, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e2) {
            if (t2.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
            let r3, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l2 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(a3);
              if (0 === o3.length) return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3) return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3) return u2.error("Numeric branch labels must be integer values.");
                if (r3) {
                  if (u2.checkSubtype(r3, De(t3))) return null;
                } else r3 = De(t3);
                if (void 0 !== i2[String(t3)]) return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e2.parse(l2, a3, n2);
              if (!c2) return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e2.parse(t2[1], 1, ce);
            if (!a2) return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r3, a2.type) ? null : new an(r3, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (De(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r3 = [], n2 = {};
            for (const t3 of e2) {
              const e3 = n2[this.cases[t3]];
              void 0 === e3 ? (n2[this.cases[t3]] = r3.length, r3.push([this.cases[t3], [t3]])) : r3[e3][1].push(t3);
            }
            const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
            for (const [e3, n3] of r3) t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
            return t2.push(this.otherwise.serialize()), t2;
          }
        }
        var on = an;
        class ln {
          constructor(t2, e2, r3) {
            this.type = t2, this.branches = e2, this.otherwise = r3;
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
            let r3;
            e2.expectedType && "value" !== e2.expectedType.kind && (r3 = e2.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e2.parse(t2[i3], i3, oe);
              if (!s2) return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r3);
              if (!a2) return null;
              n2.push([s2, a2]), r3 = r3 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r3);
            return i2 ? new ln(r3, n2, i2) : null;
          }
          evaluate(t2) {
            for (const [e2, r3] of this.branches) if (e2.evaluate(t2)) return r3.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r3] of this.branches) t2(e2), t2(r3);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["case"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var un = ln;
        class cn {
          constructor(t2, e2, r3, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r3, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r3 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, se);
            if (!r3 || !n2) return null;
            if (!xe(r3.type, [de(ce), ae, ce])) return e2.error(`Expected first argument to be of type array or string, but found ${ye(r3.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, se);
              return i2 ? new cn(r3.type, r3, n2, i2) : null;
            }
            return new cn(r3.type, r3, n2);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r3 = this.beginIndex.evaluate(t2);
            if (!ve(e2, ["string", "array"])) throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e2))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t2);
              return e2.slice(r3, n2);
            }
            return e2.slice(r3);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t2 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        var hn = cn;
        function pn(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function fn(t2, e2, r3, n2) {
          return 0 === n2.compare(e2, r3);
        }
        function dn(t2, e2, r3) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r4) {
              this.type = oe, this.lhs = t3, this.rhs = e3, this.collator = r4, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
              const r4 = t3[0];
              let s2 = e3.parse(t3[1], 1, ce);
              if (!s2) return null;
              if (!pn(r4, s2.type)) return e3.concat(1).error(`"${r4}" comparisons are not supported for type '${ye(s2.type)}'.`);
              let a2 = e3.parse(t3[2], 2, ce);
              if (!a2) return null;
              if (!pn(r4, a2.type)) return e3.concat(2).error(`"${r4}" comparisons are not supported for type '${ye(a2.type)}'.`);
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error(`Cannot compare types '${ye(s2.type)}' and '${ye(a2.type)}'.`);
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Ue(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Ue(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, he), !o2) return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e3 = De(s2), r4 = De(a2);
                if (e3.kind !== r4.kind || "string" !== e3.kind && "number" !== e3.kind) throw new Re(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r4.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = De(s2), r4 = De(a2);
                if ("string" !== t3.kind || "string" !== r4.kind) return e2(i3, s2, a2);
              }
              return this.collator ? r3(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e3 = [t2];
              return this.eachChild((t3) => {
                e3.push(t3.serialize());
              }), e3;
            }
          };
        }
        const yn = dn("==", function(t2, e2, r3) {
          return e2 === r3;
        }, fn), mn = dn("!=", function(t2, e2, r3) {
          return e2 !== r3;
        }, function(t2, e2, r3, n2) {
          return !fn(0, e2, r3, n2);
        }), gn = dn("<", function(t2, e2, r3) {
          return e2 < r3;
        }, function(t2, e2, r3, n2) {
          return n2.compare(e2, r3) < 0;
        }), xn = dn(">", function(t2, e2, r3) {
          return e2 > r3;
        }, function(t2, e2, r3, n2) {
          return n2.compare(e2, r3) > 0;
        }), vn = dn("<=", function(t2, e2, r3) {
          return e2 <= r3;
        }, function(t2, e2, r3, n2) {
          return n2.compare(e2, r3) <= 0;
        }), bn = dn(">=", function(t2, e2, r3) {
          return e2 >= r3;
        }, function(t2, e2, r3, n2) {
          return n2.compare(e2, r3) >= 0;
        });
        class wn {
          constructor(t2, e2, r3, n2, i2, s2) {
            this.type = ae, this.number = t2, this.locale = e2, this.currency = r3, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected two arguments.");
            const r3 = e2.parse(t2[1], 1, se);
            if (!r3) return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parse(n2.locale, 1, ae), !i2)) return null;
            let s2 = null;
            if (n2.currency && (s2 = e2.parse(n2.currency, 1, ae), !s2)) return null;
            let a2 = null;
            if (n2.unit && (a2 = e2.parse(n2.unit, 1, ae), !a2)) return null;
            let o2 = null;
            if (n2["min-fraction-digits"] && (o2 = e2.parse(n2["min-fraction-digits"], 1, se), !o2)) return null;
            let l2 = null;
            return n2["max-fraction-digits"] && (l2 = e2.parse(n2["max-fraction-digits"], 1, se), !l2) ? null : new wn(r3, i2, s2, a2, o2, l2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
          }
        }
        class _n {
          constructor(t2) {
            this.type = se, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r3 = e2.parse(t2[1], 1);
            return r3 ? "array" !== r3.type.kind && "string" !== r3.type.kind && "value" !== r3.type.kind ? e2.error(`Expected argument of type string or array, but found ${ye(r3.type)} instead.`) : new _n(r3) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2) return e2.length;
            if (Array.isArray(e2)) return e2.length;
            throw new Re(`Expected value to be of type string or array, but found ${ye(De(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["length"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        const An = { "==": yn, "!=": mn, ">": xn, "<": gn, ">=": bn, "<=": vn, array: Ue, at: tn, boolean: Ue, case: un, coalesce: Hr, collator: We, format: Oe, image: qe, in: rn, "index-of": sn, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: _n, let: Jr, literal: Fe, match: on, number: Ue, "number-format": wn, object: Ue, slice: hn, step: Ir, string: Ue, "to-boolean": Ze, "to-color": Ze, "to-number": Ze, "to-string": Ze, var: br, within: yr };
        function Sn(t2, [e2, r3, n2, i2]) {
          e2 = e2.evaluate(t2), r3 = r3.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Ce(e2, r3, n2, s2);
          if (a2) throw new Re(a2);
          return new Me(e2 / 255 * s2, r3 / 255 * s2, n2 / 255 * s2, s2);
        }
        function kn(t2, e2) {
          return t2 in e2;
        }
        function In(t2, e2) {
          const r3 = e2[t2];
          return void 0 === r3 ? null : r3;
        }
        function Mn(t2) {
          return { type: t2 };
        }
        He.register(An, { error: [{ kind: "error" }, [ae], (t2, [e2]) => {
          throw new Re(e2.evaluate(t2));
        }], typeof: [ae, [ce], (t2, [e2]) => ye(De(e2.evaluate(t2)))], "to-rgba": [de(se, 4), [le], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [le, [se, se, se], Sn], rgba: [le, [se, se, se, se], Sn], has: { type: oe, overloads: [[[ae], (t2, [e2]) => kn(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r3]) => kn(e2.evaluate(t2), r3.evaluate(t2))]] }, get: { type: ce, overloads: [[[ae], (t2, [e2]) => In(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r3]) => In(e2.evaluate(t2), r3.evaluate(t2))]] }, "feature-state": [ce, [ae], (t2, [e2]) => In(e2.evaluate(t2), t2.featureState || {})], properties: [ue, [], (t2) => t2.properties()], "geometry-type": [ae, [], (t2) => t2.geometryType()], id: [ce, [], (t2) => t2.id()], zoom: [se, [], (t2) => t2.globals.zoom], pitch: [se, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [se, [], (t2) => t2.distanceFromCenter()], "heatmap-density": [se, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [se, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [se, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [ce, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [se, Mn(se), (t2, e2) => {
          let r3 = 0;
          for (const n2 of e2) r3 += n2.evaluate(t2);
          return r3;
        }], "*": [se, Mn(se), (t2, e2) => {
          let r3 = 1;
          for (const n2 of e2) r3 *= n2.evaluate(t2);
          return r3;
        }], "-": { type: se, overloads: [[[se, se], (t2, [e2, r3]) => e2.evaluate(t2) - r3.evaluate(t2)], [[se], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [se, [se, se], (t2, [e2, r3]) => e2.evaluate(t2) / r3.evaluate(t2)], "%": [se, [se, se], (t2, [e2, r3]) => e2.evaluate(t2) % r3.evaluate(t2)], ln2: [se, [], () => Math.LN2], pi: [se, [], () => Math.PI], e: [se, [], () => Math.E], "^": [se, [se, se], (t2, [e2, r3]) => Math.pow(e2.evaluate(t2), r3.evaluate(t2))], sqrt: [se, [se], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [se, [se], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [se, [se], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [se, [se], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [se, [se], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [se, [se], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [se, [se], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [se, Mn(se), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [se, Mn(se), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [se, [se], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [se, [se], (t2, [e2]) => {
          const r3 = e2.evaluate(t2);
          return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
        }], floor: [se, [se], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [se, [se], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [oe, [ae, ce], (t2, [e2, r3]) => t2.properties()[e2.value] === r3.value], "filter-id-==": [oe, [ce], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [oe, [ae], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [oe, [ae, ce], (t2, [e2, r3]) => {
          const n2 = t2.properties()[e2.value], i2 = r3.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [oe, [ce], (t2, [e2]) => {
          const r3 = t2.id(), n2 = e2.value;
          return typeof r3 == typeof n2 && r3 < n2;
        }], "filter->": [oe, [ae, ce], (t2, [e2, r3]) => {
          const n2 = t2.properties()[e2.value], i2 = r3.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [oe, [ce], (t2, [e2]) => {
          const r3 = t2.id(), n2 = e2.value;
          return typeof r3 == typeof n2 && r3 > n2;
        }], "filter-<=": [oe, [ae, ce], (t2, [e2, r3]) => {
          const n2 = t2.properties()[e2.value], i2 = r3.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [oe, [ce], (t2, [e2]) => {
          const r3 = t2.id(), n2 = e2.value;
          return typeof r3 == typeof n2 && r3 <= n2;
        }], "filter->=": [oe, [ae, ce], (t2, [e2, r3]) => {
          const n2 = t2.properties()[e2.value], i2 = r3.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [oe, [ce], (t2, [e2]) => {
          const r3 = t2.id(), n2 = e2.value;
          return typeof r3 == typeof n2 && r3 >= n2;
        }], "filter-has": [oe, [ce], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [oe, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [oe, [de(ae)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [oe, [de(ce)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [oe, [ae, de(ce)], (t2, [e2, r3]) => r3.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [oe, [ae, de(ce)], (t2, [e2, r3]) => function(t3, e3, r4, n2) {
          for (; r4 <= n2; ) {
            const i2 = r4 + n2 >> 1;
            if (e3[i2] === t3) return true;
            e3[i2] > t3 ? n2 = i2 - 1 : r4 = i2 + 1;
          }
          return false;
        }(t2.properties()[e2.value], r3.value, 0, r3.value.length - 1)], all: { type: oe, overloads: [[[oe, oe], (t2, [e2, r3]) => e2.evaluate(t2) && r3.evaluate(t2)], [Mn(oe), (t2, e2) => {
          for (const r3 of e2) if (!r3.evaluate(t2)) return false;
          return true;
        }]] }, any: { type: oe, overloads: [[[oe, oe], (t2, [e2, r3]) => e2.evaluate(t2) || r3.evaluate(t2)], [Mn(oe), (t2, e2) => {
          for (const r3 of e2) if (r3.evaluate(t2)) return true;
          return false;
        }]] }, "!": [oe, [oe], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [oe, [ae], (t2, [e2]) => {
          const r3 = t2.globals && t2.globals.isSupportedScript;
          return !r3 || r3(e2.evaluate(t2));
        }], upcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ae, Mn(ce), (t2, e2) => e2.map((e3) => Ve(e3.evaluate(t2))).join("")], "resolved-locale": [ae, [he], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        var Tn = An;
        function zn(t2) {
          return { result: "success", value: t2 };
        }
        function Bn(t2) {
          return { result: "error", value: t2 };
        }
        function En(t2) {
          return "data-driven" === t2["property-type"];
        }
        function Cn(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function Pn(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function Dn(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function Vn(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function Ln(t2) {
          return t2;
        }
        function Fn(t2, e2) {
          const r3 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Pn(e2) ? "exponential" : "interval");
          if (r3 && ((t2 = Wt({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Me.parse(t3[1])])), t2.default = Me.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !Gr[t2.colorSpace]) throw new Error(`Unknown color space: ${t2.colorSpace}`);
          let a2, o2, l2;
          if ("exponential" === s2) a2 = Un;
          else if ("interval" === s2) a2 = $n;
          else if ("categorical" === s2) {
            a2 = jn, o2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops) o2[e3[0]] = e3[1];
            l2 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s2) throw new Error(`Unknown function type "${s2}"`);
            a2 = On;
          }
          if (n2) {
            const r4 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s4 = i4[0].zoom;
              void 0 === r4[s4] && (r4[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r4[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3) i3.push([r4[t3].zoom, Fn(r4[t3], e2)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: Kr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r5 }, n4) => Un({ stops: i3, base: t2.base }, e2, r5).evaluate(r5, n4) };
          }
          if (i2) {
            const r4 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r4, interpolationFactor: Kr.interpolationFactor.bind(void 0, r4), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r5 }) => a2(t2, e2, r5, o2, l2) };
          }
          return { kind: "source", evaluate(r4, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? Rn(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
          } };
        }
        function Rn(t2, e2, r3) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r3 ? r3 : void 0;
        }
        function jn(t2, e2, r3, n2, i2) {
          return Rn(typeof r3 === i2 ? n2[r3] : void 0, t2.default, e2.default);
        }
        function $n(t2, e2, r3) {
          if ("number" !== Dn(r3)) return Rn(t2.default, e2.default);
          const n2 = t2.stops.length;
          if (1 === n2) return t2.stops[0][1];
          if (r3 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r3 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
          const i2 = Sr(t2.stops.map((t3) => t3[0]), r3);
          return t2.stops[i2][1];
        }
        function Un(t2, e2, r3) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== Dn(r3)) return Rn(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2) return t2.stops[0][1];
          if (r3 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r3 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
          const s2 = Sr(t2.stops.map((t3) => t3[0]), r3), a2 = function(t3, e3, r4, n3) {
            const i3 = n3 - r4, s3 = t3 - r4;
            return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
          }(r3, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
          let u2 = Tr[e2.type] || Ln;
          if (t2.colorSpace && "rgb" !== t2.colorSpace) {
            const e3 = Gr[t2.colorSpace];
            u2 = (t3, r4) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r4), a2));
          }
          return "function" == typeof o2.evaluate ? { evaluate(...t3) {
            const e3 = o2.evaluate.apply(void 0, t3), r4 = l2.evaluate.apply(void 0, t3);
            if (void 0 !== e3 && void 0 !== r4) return u2(e3, r4, a2);
          } } : u2(o2, l2, a2);
        }
        function On(t2, e2, r3) {
          return "color" === e2.type ? r3 = Me.parse(r3) : "formatted" === e2.type ? r3 = Be.fromString(r3.toString()) : "resolvedImage" === e2.type ? r3 = Ee.fromString(r3.toString()) : Dn(r3) === e2.type || "enum" === e2.type && e2.values[r3] || (r3 = void 0), Rn(r3, t2.default, e2.default);
        }
        class qn {
          constructor(t2, e2) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e2 ? function(t3) {
              return "color" === t3.type && (Vn(t3.default) || Array.isArray(t3.default)) ? new Me(0, 0, 0, 0) : "color" === t3.type ? Me.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
            }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2, a2, o2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r3, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r3, n2, i2, s2, a2, o2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues)) throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function Nn(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Tn;
        }
        function Gn(t2, e2) {
          const r3 = new _r(Tn, [], e2 ? function(t3) {
            const e3 = { color: le, string: ae, number: se, enum: ae, boolean: oe, formatted: pe, resolvedImage: fe };
            return "array" === t3.type ? de(e3[t3.value] || ce, t3.length) : e3[t3.type];
          }(e2) : void 0), n2 = r3.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? zn(new qn(n2, e2)) : Bn(r3.errors);
        }
        class Zn {
          constructor(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !gr(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2);
          }
          evaluate(t2, e2, r3, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r3, n2, i2, s2);
          }
        }
        class Xn {
          constructor(t2, e2, r3, n2) {
            this.kind = t2, this.zoomStops = r3, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !gr(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r3, n2, i2, s2);
          }
          evaluate(t2, e2, r3, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r3, n2, i2, s2);
          }
          interpolationFactor(t2, e2, r3) {
            return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t2, e2, r3) : 0;
          }
        }
        function Kn(t2, e2) {
          if ("error" === (t2 = Gn(t2, e2)).result) return t2;
          const r3 = t2.value.expression, n2 = mr(r3);
          if (!n2 && !En(e2)) return Bn([new ee("", "data expressions not supported")]);
          const i2 = xr(r3, ["zoom", "pitch", "distance-from-center"]);
          if (!i2 && !Cn(e2)) return Bn([new ee("", "zoom expressions not supported")]);
          const s2 = Hn(r3);
          return s2 || i2 ? s2 instanceof ee ? Bn([s2]) : s2 instanceof Kr && !Pn(e2) ? Bn([new ee("", '"interpolate" expressions cannot be used with this property')]) : zn(s2 ? new Xn(n2 ? "camera" : "composite", t2.value, s2.labels, s2 instanceof Kr ? s2.interpolation : void 0) : new Zn(n2 ? "constant" : "source", t2.value)) : Bn([new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Yn {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, Wt(this, Fn(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new Yn(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function Hn(t2) {
          let e2 = null;
          if (t2 instanceof Jr) e2 = Hn(t2.result);
          else if (t2 instanceof Hr) {
            for (const r3 of t2.args) if (e2 = Hn(r3), e2) break;
          } else (t2 instanceof Ir || t2 instanceof Kr) && t2.input instanceof He && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof ee || t2.eachChild((t3) => {
            const r3 = Hn(t3);
            r3 instanceof ee ? e2 = r3 : !e2 && r3 ? e2 = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r3 && e2 !== r3 && (e2 = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        class Wn {
          constructor(t2, e2, r3, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r3, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function Jn(t2) {
          const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
          let o2 = [];
          const l2 = Dn(r3);
          if ("object" !== l2) return [new Wn(e2, r3, `object expected, ${l2} found`)];
          for (const t3 in r3) {
            const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
            let c2;
            i2[l3] ? c2 = i2[l3] : n2[l3] ? c2 = Ci : i2["*"] ? c2 = i2["*"] : n2["*"] && (c2 = Ci), c2 ? o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r3[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r3, objectKey: t3 }, r3)) : o2.push(new Wn(e2, r3[t3], `unknown property "${t3}"`));
          }
          for (const t3 in n2) i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r3[t3] && o2.push(new Wn(e2, r3, `missing required property "${t3}"`));
          return o2;
        }
        function Qn(t2) {
          const e2 = t2.value, r3 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Ci;
          if ("array" !== Dn(e2)) return [new Wn(s2, e2, `array expected, ${Dn(e2)} found`)];
          if (r3.length && e2.length !== r3.length) return [new Wn(s2, e2, `array length ${r3.length} expected, length ${e2.length} found`)];
          if (r3["min-length"] && e2.length < r3["min-length"]) return [new Wn(s2, e2, `array length at least ${r3["min-length"]} expected, length ${e2.length} found`)];
          let o2 = { type: r3.value, values: r3.values, minimum: r3.minimum, maximum: r3.maximum, function: void 0 };
          i2.$version < 7 && (o2.function = r3.function), "object" === Dn(r3.value) && (o2 = r3.value);
          let l2 = [];
          for (let t3 = 0; t3 < e2.length; t3++) l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
          return l2;
        }
        function ti(t2) {
          const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec;
          let i2 = Dn(r3);
          if ("number" === i2 && r3 != r3 && (i2 = "NaN"), "number" !== i2) return [new Wn(e2, r3, `number expected, ${i2} found`)];
          if ("minimum" in n2) {
            let i3 = n2.minimum;
            if ("array" === Dn(n2.minimum) && (i3 = n2.minimum[t2.arrayIndex]), r3 < i3) return [new Wn(e2, r3, `${r3} is less than the minimum value ${i3}`)];
          }
          if ("maximum" in n2) {
            let i3 = n2.maximum;
            if ("array" === Dn(n2.maximum) && (i3 = n2.maximum[t2.arrayIndex]), r3 > i3) return [new Wn(e2, r3, `${r3} is greater than the maximum value ${i3}`)];
          }
          return [];
        }
        function ei(t2) {
          const e2 = t2.valueSpec, r3 = Jt(t2.value.type);
          let n2, i2, s2, a2 = {};
          const o2 = "categorical" !== r3 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Dn(t2.value.stops) && "array" === Dn(t2.value.stops[0]) && "object" === Dn(t2.value.stops[0][0]), c2 = Jn({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r3) return [new Wn(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n3 = t3.value;
            return e3 = e3.concat(Qn({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === Dn(n3) && 0 === n3.length && e3.push(new Wn(t3.key, n3, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return Ci({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r3 && o2 && c2.push(new Wn(t2.key, t2.value, 'missing required property "property"')), "identity" === r3 || t2.value.stops || c2.push(new Wn(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r3 && t2.valueSpec.expression && !Pn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !En(t2.valueSpec) ? c2.push(new Wn(t2.key, t2.value, "property functions not supported")) : o2 && !Cn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r3 && !u2 || void 0 !== t2.value.property || c2.push(new Wn(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r4 = [];
            const n3 = t3.value, o3 = t3.key;
            if ("array" !== Dn(n3)) return [new Wn(o3, n3, `array expected, ${Dn(n3)} found`)];
            if (2 !== n3.length) return [new Wn(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if ("object" !== Dn(n3[0])) return [new Wn(o3, n3, `object expected, ${Dn(n3[0])} found`)];
              if (void 0 === n3[0].zoom) return [new Wn(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value) return [new Wn(o3, n3, "object stop key must have value")];
              const e3 = Jt(n3[0].zoom);
              if ("number" != typeof e3) return [new Wn(o3, n3[0].zoom, "stop zoom values must be numbers")];
              if (s2 && s2 > e3) return [new Wn(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              e3 !== s2 && (s2 = e3, i2 = void 0, a2 = {}), r4 = r4.concat(Jn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: ti, value: p2 } }));
            } else r4 = r4.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return Nn(Qt(n3[1])) ? r4.concat([new Wn(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r4.concat(Ci({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, s3) {
            const o3 = Dn(t3.value), l3 = Jt(t3.value), u3 = null !== t3.value ? t3.value : s3;
            if (n2) {
              if (o3 !== n2) return [new Wn(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3) return [new Wn(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r3) {
              let n3 = `number expected, ${o3} found`;
              return En(e2) && void 0 === r3 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Wn(t3.key, u3, n3)];
            }
            return "categorical" !== r3 || "number" !== o3 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r3 && "number" === o3 && "number" == typeof l3 && "number" == typeof i2 && void 0 !== i2 && l3 < i2 ? [new Wn(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r3 && l3 in a2 ? [new Wn(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Wn(t3.key, u3, `integer expected, found ${String(l3)}`)];
          }
        }
        function ri(t2) {
          const e2 = ("property" === t2.expressionContext ? Kn : Gn)(Qt(t2.value), t2.valueSpec);
          if ("error" === e2.result) return e2.value.map((e3) => new Wn(`${t2.key}${e3.key}`, t2.value, e3.message));
          const r3 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r3.outputDefined()) return [new Wn(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !gr(r3)) return [new Wn(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext) return ni(r3, t2);
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!xr(r3, ["zoom", "feature-state"])) return [new Wn(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !mr(r3)) return [new Wn(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ni(t2, e2) {
          const r3 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (e2.valueSpec && e2.valueSpec.expression) for (const t3 of e2.valueSpec.expression.parameters) r3.delete(t3);
          if (0 === r3.size) return [];
          const n2 = [];
          return t2 instanceof He && r3.has(t2.name) ? [new Wn(e2.key, e2.value, `["${t2.name}"] expression is not supported in a filter for a ${e2.object.type} layer with id: ${e2.object.id}`)] : (t2.eachChild((t3) => {
            n2.push(...ni(t3, e2));
          }), n2);
        }
        function ii(t2) {
          const e2 = t2.key, r3 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Jt(r3)) && i2.push(new Wn(e2, r3, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r3)} found`)) : -1 === Object.keys(n2.values).indexOf(Jt(r3)) && i2.push(new Wn(e2, r3, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r3)} found`)), i2;
        }
        function si(t2) {
          if (true === t2 || false === t2) return true;
          if (!Array.isArray(t2) || 0 === t2.length) return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1)) if (!si(e2) && "boolean" != typeof e2) return false;
              return true;
            default:
              return true;
          }
        }
        function ai(t2, e2 = "fill") {
          if (null == t2) return { filter: () => true, needGeometry: false, needFeature: false };
          si(t2) || (t2 = fi(t2));
          const r3 = t2;
          let n2 = true;
          try {
            n2 = function(t3) {
              if (!ui(t3)) return t3;
              let e3 = Qt(t3);
              return li(e3), e3 = oi(e3), e3;
            }(r3);
          } catch (t3) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r3, null, 2)}
        `);
          }
          const i2 = Ht[`filter_${e2}`], s2 = Gn(n2, i2);
          let a2 = null;
          if ("error" === s2.result) throw new Error(s2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
          a2 = (t3, e3, r4) => s2.value.evaluate(t3, e3, {}, r4);
          let o2 = null, l2 = null;
          if (n2 !== r3) {
            const t3 = Gn(r3, i2);
            if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
            o2 = (e3, r4, n3, i3, s3) => t3.value.evaluate(e3, r4, {}, n3, void 0, void 0, i3, s3), l2 = !mr(t3.value.expression);
          }
          return { filter: a2, dynamicFilter: o2 || void 0, needGeometry: pi(n2), needFeature: !!l2 };
        }
        function oi(t2) {
          if (!Array.isArray(t2)) return t2;
          const e2 = function(t3) {
            if (ci.has(t3[0])) {
              for (let e3 = 1; e3 < t3.length; e3++) if (ui(t3[e3])) return true;
            }
            return t3;
          }(t2);
          return true === e2 ? e2 : e2.map((t3) => oi(t3));
        }
        function li(t2) {
          let e2 = false;
          const r3 = [];
          if ("case" === t2[0]) {
            for (let n2 = 1; n2 < t2.length - 1; n2 += 2) e2 = e2 || ui(t2[n2]), r3.push(t2[n2 + 1]);
            r3.push(t2[t2.length - 1]);
          } else if ("match" === t2[0]) {
            e2 = e2 || ui(t2[1]);
            for (let e3 = 2; e3 < t2.length - 1; e3 += 2) r3.push(t2[e3 + 1]);
            r3.push(t2[t2.length - 1]);
          } else if ("step" === t2[0]) {
            e2 = e2 || ui(t2[1]);
            for (let e3 = 1; e3 < t2.length - 1; e3 += 2) r3.push(t2[e3 + 1]);
          }
          e2 && (t2.length = 0, t2.push("any", ...r3));
          for (let e3 = 1; e3 < t2.length; e3++) li(t2[e3]);
        }
        function ui(t2) {
          if (!Array.isArray(t2)) return false;
          if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2) return true;
          var e2;
          for (let e3 = 1; e3 < t2.length; e3++) if (ui(t2[e3])) return true;
          return false;
        }
        const ci = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function hi(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function pi(t2) {
          if (!Array.isArray(t2)) return false;
          if ("within" === t2[0]) return true;
          for (let e2 = 1; e2 < t2.length; e2++) if (pi(t2[e2])) return true;
          return false;
        }
        function fi(t2) {
          if (!t2) return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? di(t2[1], t2[2], "==") : "!=" === e2 ? gi(di(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? di(t2[1], t2[2], e2) : "any" === e2 ? (r3 = t2.slice(1), ["any"].concat(r3.map(fi))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(fi)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(fi).map(gi)) : "in" === e2 ? yi(t2[1], t2.slice(2)) : "!in" === e2 ? gi(yi(t2[1], t2.slice(2))) : "has" === e2 ? mi(t2[1]) : "!has" === e2 ? gi(mi(t2[1])) : "within" !== e2 || t2;
          var r3;
        }
        function di(t2, e2, r3) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r3}`, e2];
            case "$id":
              return [`filter-id-${r3}`, e2];
            default:
              return [`filter-${r3}`, t2, e2];
          }
        }
        function yi(t2, e2) {
          if (0 === e2.length) return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(hi)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function mi(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function gi(t2) {
          return ["!", t2];
        }
        function xi(t2) {
          return si(Qt(t2.value)) ? ri(Wt({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : vi(t2);
        }
        function vi(t2) {
          const e2 = t2.value, r3 = t2.key;
          if ("array" !== Dn(e2)) return [new Wn(r3, e2, `array expected, ${Dn(e2)} found`)];
          const n2 = t2.styleSpec;
          let i2, s2 = [];
          if (e2.length < 1) return [new Wn(r3, e2, "filter array must have at least 1 element")];
          switch (s2 = s2.concat(ii({ key: `${r3}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), Jt(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === Jt(e2[1]) && s2.push(new Wn(r3, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && s2.push(new Wn(r3, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = Dn(e2[1]), "string" !== i2 && s2.push(new Wn(`${r3}[1]`, e2[1], `string expected, ${i2} found`)));
              for (let a2 = 2; a2 < e2.length; a2++) i2 = Dn(e2[a2]), "$type" === Jt(e2[1]) ? s2 = s2.concat(ii({ key: `${r3}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new Wn(`${r3}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++) s2 = s2.concat(vi({ key: `${r3}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = Dn(e2[1]), 2 !== e2.length ? s2.push(new Wn(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new Wn(`${r3}[1]`, e2[1], `string expected, ${i2} found`));
              break;
            case "within":
              i2 = Dn(e2[1]), 2 !== e2.length ? s2.push(new Wn(r3, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i2 && s2.push(new Wn(`${r3}[1]`, e2[1], `object expected, ${i2} found`));
          }
          return s2;
        }
        function bi(t2, e2) {
          const r3 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
          if (!o2) return [];
          const l2 = a2.match(/^(.*)-transition$/);
          if ("paint" === e2 && l2 && o2[l2[1]] && o2[l2[1]].transition) return Ci({ key: r3, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
          const u2 = t2.valueSpec || o2[a2];
          if (!u2) return [new Wn(r3, s2, `unknown property "${a2}"`)];
          let c2;
          if ("string" === Dn(s2) && En(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2))) {
            const t3 = `\`{ "type": "identity", "property": ${c2 ? JSON.stringify(c2[1]) : '"_"'} }\``;
            return [new Wn(r3, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
          }
          const h2 = [];
          return "symbol" === t2.layerType && ("text-field" === a2 && n2 && !n2.glyphs && h2.push(new Wn(r3, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a2 && Vn(Qt(s2)) && "identity" === Jt(s2.type) && h2.push(new Wn(r3, s2, '"text-font" does not support identity functions'))), h2.concat(Ci({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
        }
        function wi(t2) {
          return bi(t2, "paint");
        }
        function _i(t2) {
          return bi(t2, "layout");
        }
        function Ai(t2) {
          let e2 = [];
          const r3 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
          r3.type || r3.ref || e2.push(new Wn(n2, r3, 'either "type" or "ref" is required'));
          let a2 = Jt(r3.type);
          const o2 = Jt(r3.ref);
          if (r3.id) {
            const s3 = Jt(r3.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              Jt(t3.id) === s3 && e2.push(new Wn(n2, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r3) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r3 && e2.push(new Wn(n2, r3[t4], `"${t4}" is prohibited for ref layers`));
            }), i2.layers.forEach((e3) => {
              Jt(e3.id) === o2 && (t3 = e3);
            }), t3 ? t3.ref ? e2.push(new Wn(n2, r3.ref, "ref cannot reference another ref layer")) : a2 = Jt(t3.type) : "string" == typeof o2 && e2.push(new Wn(n2, r3.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== a2 && "sky" !== a2) if (r3.source) {
            const t3 = i2.sources && i2.sources[r3.source], s3 = t3 && Jt(t3.type);
            t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new Wn(n2, r3.source, `layer "${r3.id}" requires a raster source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new Wn(n2, r3.source, `layer "${r3.id}" requires a vector source`)) : "vector" !== s3 || r3["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new Wn(n2, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r3.paint || !r3.paint["line-gradient"] && !r3.paint["line-trim-offset"] || "geojson" === s3 && t3.lineMetrics || e2.push(new Wn(n2, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Wn(n2, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e2.push(new Wn(n2, r3.source, `source "${r3.source}" not found`));
          } else e2.push(new Wn(n2, r3, 'missing required property "source"'));
          return e2 = e2.concat(Jn({ key: n2, value: r3, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Ci({ key: `${n2}.type`, value: r3.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r3, objectKey: "type" }), filter: (t3) => xi(Wt({ layerType: a2 }, t3)), layout: (t3) => Jn({ layer: r3, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => _i(Wt({ layerType: a2 }, t4)) } }), paint: (t3) => Jn({ layer: r3, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => wi(Wt({ layerType: a2 }, t4)) } }) } })), e2;
        }
        function Si(t2) {
          const e2 = t2.value, r3 = t2.key, n2 = Dn(e2);
          return "string" !== n2 ? [new Wn(r3, e2, `string expected, ${n2} found`)] : [];
        }
        const ki = { promoteId: function({ key: t2, value: e2 }) {
          if ("string" === Dn(e2)) return Si({ key: t2, value: e2 });
          {
            const r3 = [];
            for (const n2 in e2) r3.push(...Si({ key: `${t2}.${n2}`, value: e2[n2] }));
            return r3;
          }
        } };
        function Ii(t2) {
          const e2 = t2.value, r3 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
          if (!e2.type) return [new Wn(r3, e2, '"type" is required')];
          const s2 = Jt(e2.type);
          let a2;
          switch (s2) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a2 = Jn({ key: r3, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ki }), a2;
            case "geojson":
              if (a2 = Jn({ key: r3, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ki }), e2.cluster) for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                a2.push(...ri({ key: `${r3}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...ri({ key: `${r3}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
              return a2;
            case "video":
              return Jn({ key: r3, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
            case "image":
              return Jn({ key: r3, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
            case "canvas":
              return [new Wn(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ii({ key: `${r3}.type`, value: e2.type, valueSpec: { values: Mi(n2) }, style: i2, styleSpec: n2 });
          }
        }
        function Mi(t2) {
          return t2.source.reduce((e2, r3) => {
            const n2 = t2[r3];
            return "enum" === n2.type.type && (e2 = e2.concat(Object.keys(n2.type.values))), e2;
          }, []);
        }
        function Ti(t2) {
          const e2 = t2.value, r3 = t2.styleSpec, n2 = r3.light, i2 = t2.style;
          let s2 = [];
          const a2 = Dn(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new Wn("light", e2, `object expected, ${a2} found`)]), s2;
          for (const t3 in e2) {
            const a3 = t3.match(/^(.*)-transition$/);
            s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: r3.transition, style: i2, styleSpec: r3 }) : n2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r3 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          return s2;
        }
        function zi(t2) {
          const e2 = t2.value, r3 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
          let a2 = [];
          const o2 = Dn(e2);
          if (void 0 === e2) return a2;
          if ("object" !== o2) return a2 = a2.concat([new Wn("terrain", e2, `object expected, ${o2} found`)]), a2;
          for (const t3 in e2) {
            const r4 = t3.match(/^(.*)-transition$/);
            a2 = a2.concat(r4 && s2[r4[1]] && s2[r4[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          if (e2.source) {
            const t3 = n2.sources && n2.sources[e2.source], i3 = t3 && Jt(t3.type);
            t3 ? "raster-dem" !== i3 && a2.push(new Wn(r3, e2.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new Wn(r3, e2.source, `source "${e2.source}" not found`));
          } else a2.push(new Wn(r3, e2, 'terrain is missing required property "source"'));
          return a2;
        }
        function Bi(t2) {
          const e2 = t2.value, r3 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
          let s2 = [];
          const a2 = Dn(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new Wn("fog", e2, `object expected, ${a2} found`)]), s2;
          for (const t3 in e2) {
            const a3 = t3.match(/^(.*)-transition$/);
            s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: n2.transition, style: r3, styleSpec: n2 }) : i2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r3, styleSpec: n2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          return s2;
        }
        const Ei = { "*": () => [], array: Qn, boolean: function(t2) {
          const e2 = t2.value, r3 = t2.key, n2 = Dn(e2);
          return "boolean" !== n2 ? [new Wn(r3, e2, `boolean expected, ${n2} found`)] : [];
        }, number: ti, color: function(t2) {
          const e2 = t2.key, r3 = t2.value, n2 = Dn(r3);
          return "string" !== n2 ? [new Wn(e2, r3, `color expected, ${n2} found`)] : null === be(r3) ? [new Wn(e2, r3, `color expected, "${r3}" found`)] : [];
        }, enum: ii, filter: xi, function: ei, layer: Ai, object: Jn, source: Ii, light: Ti, terrain: zi, fog: Bi, string: Si, formatted: function(t2) {
          return 0 === Si(t2).length ? [] : ri(t2);
        }, resolvedImage: function(t2) {
          return 0 === Si(t2).length ? [] : ri(t2);
        }, projection: function(t2) {
          const e2 = t2.value, r3 = t2.styleSpec, n2 = r3.projection, i2 = t2.style;
          let s2 = [];
          const a2 = Dn(e2);
          if ("object" === a2) for (const t3 in e2) s2 = s2.concat(Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r3 }));
          else "string" !== a2 && (s2 = s2.concat([new Wn("projection", e2, `object or string expected, ${a2} found`)]));
          return s2;
        } };
        function Ci(t2) {
          const e2 = t2.value, r3 = t2.valueSpec, n2 = t2.styleSpec;
          return r3.expression && Vn(Jt(e2)) ? ei(t2) : r3.expression && Nn(Qt(e2)) ? ri(t2) : r3.type && Ei[r3.type] ? Ei[r3.type](t2) : Jn(Wt({}, t2, { valueSpec: r3.type ? n2[r3.type] : r3 }));
        }
        function Pi(t2) {
          const e2 = t2.value, r3 = t2.key, n2 = Si(t2);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Wn(r3, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Wn(r3, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function Di(t2, e2 = Ht) {
          return Fi(Ci({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Pi, "*": () => [] } }));
        }
        const Vi = (t2) => Fi(wi(t2)), Li = (t2) => Fi(_i(t2));
        function Fi(t2) {
          return t2.slice().sort((t3, e2) => t3.line && e2.line ? t3.line - e2.line : 0);
        }
        function Ri(t2, e2) {
          let r3 = false;
          if (e2 && e2.length) for (const n2 of e2) t2.fire(new Kt(new Error(n2.message))), r3 = true;
          return r3;
        }
        var ji = $i;
        function $i(t2, e2, r3) {
          var n2 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            var i2 = new Int32Array(this.arrayBuffer);
            t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r3 = i2[2]);
            for (var s2 = 0; s2 < this.d * this.d; s2++) {
              var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
              n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
            }
            var l2 = i2[3 + n2.length + 1];
            this.keys = i2.subarray(i2[3 + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r3;
            for (var u2 = 0; u2 < this.d * this.d; u2++) n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r3, this.scale = e2 / t2, this.uid = 0;
          var c2 = r3 / e2 * t2;
          this.min = -c2, this.max = t2 + c2;
        }
        $i.prototype.insert = function(t2, e2, r3, n2, i2) {
          this._forEachCell(e2, r3, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r3), this.bboxes.push(n2), this.bboxes.push(i2);
        }, $i.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, $i.prototype._insertCell = function(t2, e2, r3, n2, i2, s2) {
          this.cells[i2].push(s2);
        }, $i.prototype.query = function(t2, e2, r3, n2, i2) {
          var s2 = this.min, a2 = this.max;
          if (t2 <= s2 && e2 <= s2 && a2 <= r3 && a2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
          var o2 = [];
          return this._forEachCell(t2, e2, r3, n2, this._queryCell, o2, {}, i2), o2;
        }, $i.prototype._queryCell = function(t2, e2, r3, n2, i2, s2, a2, o2) {
          var l2 = this.cells[i2];
          if (null !== l2) for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
            var p2 = l2[h2];
            if (void 0 === a2[p2]) {
              var f2 = 4 * p2;
              (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t2 <= c2[f2 + 2] && e2 <= c2[f2 + 3] && r3 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
            }
          }
        }, $i.prototype._forEachCell = function(t2, e2, r3, n2, i2, s2, a2, o2) {
          for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r3), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++) for (var f2 = u2; f2 <= h2; f2++) {
            var d2 = this.d * f2 + p2;
            if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r3, n2, d2, s2, a2, o2)) return;
          }
        }, $i.prototype._convertFromCellCoord = function(t2) {
          return (t2 - this.padding) / this.scale;
        }, $i.prototype._convertToCellCoord = function(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }, $i.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer) return this.arrayBuffer;
          for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r3 = 0, n2 = 0; n2 < this.cells.length; n2++) r3 += this.cells[n2].length;
          var i2 = new Int32Array(e2 + r3 + this.keys.length + this.bboxes.length);
          i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
          for (var s2 = e2, a2 = 0; a2 < t2.length; a2++) {
            var o2 = t2[a2];
            i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
          }
          return i2[3 + t2.length] = s2, i2.set(this.keys, s2), i2[3 + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
        };
        const Ui = {};
        function Oi(t2, e2, r3 = {}) {
          Object.defineProperty(t2, "_classRegistryKey", { value: e2, writeable: false }), Ui[e2] = { klass: t2, omit: r3.omit || [] };
        }
        Oi(Object, "Object"), ji.serialize = function(t2, e2) {
          const r3 = t2.toArrayBuffer();
          return e2 && e2.push(r3), { buffer: r3 };
        }, ji.deserialize = function(t2) {
          return new ji(t2.buffer);
        }, Object.defineProperty(ji, "name", { value: "Grid" }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", { omit: ["_evaluator"] }), Oi(Xn, "ZoomDependentExpression"), Oi(Zn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t2 in Tn) Ui[Tn[t2]._classRegistryKey] || Oi(Tn[t2], `Expression${t2}`);
        function qi(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function Ni(t2) {
          return e.ImageBitmap && t2 instanceof e.ImageBitmap;
        }
        function Gi(t2, r3) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp) return t2;
          if (qi(t2) || Ni(t2)) return r3 && r3.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            const e2 = t2;
            return r3 && r3.push(e2.buffer), e2;
          }
          if (t2 instanceof e.ImageData) return r3 && r3.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const e2 = [];
            for (const n2 of t2) e2.push(Gi(n2, r3));
            return e2;
          }
          if ("object" == typeof t2) {
            const e2 = t2.constructor, n2 = e2._classRegistryKey;
            if (!n2) throw new Error(`can't serialize object of unregistered class ${n2}`);
            const i2 = e2.serialize ? e2.serialize(t2, r3) : {};
            if (!e2.serialize) {
              for (const e3 in t2) t2.hasOwnProperty(e3) && (Ui[n2].omit.indexOf(e3) >= 0 || (i2[e3] = Gi(t2[e3], r3)));
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n2 && (i2.$name = n2), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function Zi(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || qi(t2) || Ni(t2) || ArrayBuffer.isView(t2) || t2 instanceof e.ImageData) return t2;
          if (Array.isArray(t2)) return t2.map(Zi);
          if ("object" == typeof t2) {
            const e2 = t2.$name || "Object", { klass: r3 } = Ui[e2];
            if (!r3) throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r3.deserialize) return r3.deserialize(t2);
            const n2 = Object.create(r3.prototype);
            for (const e3 of Object.keys(t2)) "$name" !== e3 && (n2[e3] = Zi(t2[e3]));
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        const Xi = (t2) => t2 >= 1536 && t2 <= 1791, Ki = (t2) => t2 >= 1872 && t2 <= 1919, Yi = (t2) => t2 >= 2208 && t2 <= 2303, Hi = (t2) => t2 >= 11904 && t2 <= 12031, Wi = (t2) => t2 >= 12032 && t2 <= 12255, Ji = (t2) => t2 >= 12272 && t2 <= 12287, Qi = (t2) => t2 >= 12288 && t2 <= 12351, ts = (t2) => t2 >= 12352 && t2 <= 12447, es = (t2) => t2 >= 12448 && t2 <= 12543, rs = (t2) => t2 >= 12544 && t2 <= 12591, ns = (t2) => t2 >= 12704 && t2 <= 12735, is = (t2) => t2 >= 12736 && t2 <= 12783, ss = (t2) => t2 >= 12784 && t2 <= 12799, as = (t2) => t2 >= 12800 && t2 <= 13055, os = (t2) => t2 >= 13056 && t2 <= 13311, ls = (t2) => t2 >= 13312 && t2 <= 19903, us = (t2) => t2 >= 19968 && t2 <= 40959, cs = (t2) => t2 >= 40960 && t2 <= 42127, hs = (t2) => t2 >= 42128 && t2 <= 42191, ps = (t2) => t2 >= 44032 && t2 <= 55215, fs = (t2) => t2 >= 63744 && t2 <= 64255, ds = (t2) => t2 >= 64336 && t2 <= 65023, ys = (t2) => t2 >= 65040 && t2 <= 65055, ms = (t2) => t2 >= 65072 && t2 <= 65103, gs = (t2) => t2 >= 65104 && t2 <= 65135, xs = (t2) => t2 >= 65136 && t2 <= 65279, vs = (t2) => t2 >= 65280 && t2 <= 65519;
        function bs(t2) {
          for (const e2 of t2) if (As(e2.charCodeAt(0))) return true;
          return false;
        }
        function ws(t2) {
          for (const e2 of t2) if (!_s(e2.charCodeAt(0))) return false;
          return true;
        }
        function _s(t2) {
          return !(Xi(t2) || Ki(t2) || Yi(t2) || ds(t2) || xs(t2));
        }
        function As(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(ns(t2) || rs(t2) || ms(t2) && !(t2 >= 65097 && t2 <= 65103) || fs(t2) || os(t2) || Hi(t2) || is(t2) || !(!Qi(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || ls(t2) || us(t2) || as(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || ps(t2) || ts(t2) || Ji(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || Wi(t2) || ss(t2) || es(t2) && 12540 !== t2 || !(!vs(t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!gs(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || ys(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || cs(t2) || hs(t2))));
        }
        function Ss(t2) {
          return !(As(t2) || function(t3) {
            return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && 9251 !== t3 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Qi(t3) || es(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || ms(t3) || gs(t3) || vs(t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        function ks(t2) {
          return t2 >= 1424 && t2 <= 2303 || ds(t2) || xs(t2);
        }
        function Is(t2, e2) {
          return !(!e2 && ks(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
        }
        function Ms(t2) {
          for (const e2 of t2) if (ks(e2.charCodeAt(0))) return true;
          return false;
        }
        const Ts = "deferred", zs = "loading", Bs = "loaded";
        let Es = null, Cs = "unavailable", Ps = null;
        const Ds = function(t2) {
          t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t2);
        };
        function Vs() {
          Ls.fire(new Xt("pluginStateChange", { pluginStatus: Cs, pluginURL: Ps }));
        }
        const Ls = new Yt(), Fs = function() {
          return Cs;
        }, Rs = function() {
          if (Cs !== Ts || !Ps) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Cs = zs, Vs(), Ps && ut({ url: Ps }, (t2) => {
            t2 ? Ds(t2) : (Cs = Bs, Vs());
          });
        }, js = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Cs === Bs || null != js.applyArabicShaping, isLoading: () => Cs === zs, setState(t2) {
          Cs = t2.pluginStatus, Ps = t2.pluginURL;
        }, isParsed: () => null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText, getPluginURL: () => Ps };
        class $s {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (const r3 of t3) if (!Is(r3.charCodeAt(0), e2)) return false;
              return true;
            }(t2, js.isLoaded());
          }
        }
        class Us {
          constructor(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if (Vn(t3)) return new Yn(t3, e3);
              if (Nn(t3)) {
                const r3 = Kn(t3, e3);
                if ("error" === r3.result) throw new Error(r3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return r3.value;
              }
              {
                let r3 = t3;
                return "string" == typeof t3 && "color" === e3.type && (r3 = Me.parse(t3)), { kind: "constant", evaluate: () => r3 };
              }
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e2, r3) {
            return this.property.possiblyEvaluate(this, t2, e2, r3);
          }
        }
        class Os {
          constructor(t2) {
            this.property = t2, this.value = new Us(t2, void 0);
          }
          transitioned(t2, e2) {
            return new Ns(this.property, this.value, e2, z({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new Ns(this.property, this.value, null, {}, 0);
          }
        }
        class qs {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return j(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].value = new Us(this._values[t2].property, null === e2 ? void 0 : j(e2));
          }
          getTransition(t2) {
            return j(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].transition = j(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r3 = this.getValue(e2);
              void 0 !== r3 && (t2[e2] = r3);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t2[`${e2}-transition`] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r3 = new Gs(this._properties);
            for (const n2 of Object.keys(this._values)) r3._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r3;
          }
          untransitioned() {
            const t2 = new Gs(this._properties);
            for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class Ns {
          constructor(t2, e2, r3, n2, i2) {
            const s2 = n2.delay || 0, a2 = n2.duration || 0;
            i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r3);
          }
          possiblyEvaluate(t2, e2, r3) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r3), s2 = this.prior;
            if (s2) {
              if (n2 > this.end) return this.prior = null, i2;
              if (this.value.isDataDriven()) return this.prior = null, i2;
              if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r3);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r3), i2, w(a2));
              }
            }
            return i2;
          }
        }
        class Gs {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r3) {
            const n2 = new Ks(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r3);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
            return false;
          }
        }
        class Zs {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          getValue(t2) {
            return j(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new Us(this._values[t2].property, null === e2 ? void 0 : j(e2));
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r3 = this.getValue(e2);
              void 0 !== r3 && (t2[e2] = r3);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r3) {
            const n2 = new Ks(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r3);
            return n2;
          }
        }
        class Xs {
          constructor(t2, e2, r3) {
            this.property = t2, this.value = e2, this.parameters = r3;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r3, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r3, n2);
          }
        }
        class Ks {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class Ys {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r3) {
            const n2 = Tr[this.specification.type];
            return n2 ? n2(t2, e2, r3) : t2;
          }
        }
        class Hs {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r3, n2) {
            return new Xs(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r3, n2) } : t2.expression, e2);
          }
          interpolate(t2, e2, r3) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value) return new Xs(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = Tr[this.specification.type];
            return n2 ? new Xs(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r3) }, t2.parameters) : t2;
          }
          evaluate(t2, e2, r3, n2, i2, s2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r3, n2, i2, s2);
          }
        }
        class Ws {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r3, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r3, n2);
          }
          interpolate() {
            return false;
          }
        }
        class Js {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e2 = new $s(0, {});
            for (const r3 in t2) {
              const n2 = t2[r3];
              n2.specification.overridable && this.overridableProperties.push(r3);
              const i2 = this.defaultPropertyValues[r3] = new Us(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r3] = new Os(n2);
              this.defaultTransitioningPropertyValues[r3] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r3] = i2.possiblyEvaluate(e2);
            }
          }
        }
        function Qs(t2, e2) {
          return 256 * (t2 = S(Math.floor(t2), 0, 255)) + S(Math.floor(e2), 0, 255);
        }
        Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
        const ta = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class ea {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ra {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function na(t2, e2 = 1) {
          let r3 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            const i2 = ta[t3.type].BYTES_PER_ELEMENT, s2 = r3 = ia(r3, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r3 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }), size: ia(r3, Math.max(n2, e2)), alignment: e2 };
        }
        function ia(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class sa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t2, e2);
          }
          emplace(t2, e2, r3) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r3, t2;
          }
        }
        sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
        class aa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
          }
          emplace(t2, e2, r3, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r3, this.int16[i2 + 2] = n2, t2;
          }
        }
        aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
        class oa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
          }
          emplace(t2, e2, r3, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r3, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
        class la extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r3, n2, i2, s2, a2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
            return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r3, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
          }
        }
        la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
        class ua extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
          }
          emplace(t2, e2, r3, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r3, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
        class ca extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r3, n2, i2);
          }
          emplace(t2, e2, r3, n2, i2, s2) {
            const a2 = 6 * t2, o2 = 3 * t2;
            return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r3, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
          }
        }
        ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
        class ha extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
          }
          emplace(t2, e2, r3, n2, i2) {
            const s2 = 4 * t2;
            return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r3, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
          }
        }
        ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
        class pa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r3, n2, i2, s2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r3, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
        class fa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = 12 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r3, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
          }
        }
        fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
        class da extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r3, n2, i2, s2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = 10 * t2, l2 = 5 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r3, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
          }
        }
        da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
        class ya extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
        class ma extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = this.length;
            return this.resize(f2 + 1), this.emplace(f2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2) {
            const d2 = 20 * t2, y2 = 10 * t2;
            return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r3, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l2, this.float32[y2 + 6] = u2, this.int16[d2 + 14] = c2, this.uint32[y2 + 8] = h2, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
          }
        }
        ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
        class ga extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r3, n2, i2, s2, a2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = 8 * t2;
            return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r3, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
          }
        }
        ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
        class xa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r3, n2, i2);
          }
          emplace(t2, e2, r3, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
        class va extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
          }
          emplace(t2, e2, r3, n2, i2) {
            const s2 = 12 * t2, a2 = 3 * t2;
            return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r3, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
          }
        }
        va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
        class ba extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
          }
          emplace(t2, e2, r3, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r3, this.float32[i2 + 2] = n2, t2;
          }
        }
        ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
        class wa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r3);
          }
          emplace(t2, e2, r3, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r3, this.uint16[i2 + 2] = n2, t2;
          }
        }
        wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
        class _a extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2) {
            const w2 = this.length;
            return this.resize(w2 + 1), this.emplace(w2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2) {
            const _2 = 30 * t2, A2 = 15 * t2, S2 = 60 * t2;
            return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r3, this.int16[_2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u2, this.uint32[A2 + 7] = c2, this.uint16[_2 + 16] = h2, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = f2, this.float32[A2 + 10] = d2, this.float32[A2 + 11] = y2, this.uint8[S2 + 48] = m2, this.uint8[S2 + 49] = g2, this.uint8[S2 + 50] = x2, this.uint32[A2 + 13] = v2, this.int16[_2 + 28] = b2, this.uint8[S2 + 58] = w2, t2;
          }
        }
        _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Aa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2) {
            const B2 = this.length;
            return this.resize(B2 + 1), this.emplace(B2, t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2);
          }
          emplace(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2, B2) {
            const E2 = 38 * t2, C2 = 19 * t2;
            return this.int16[E2 + 0] = e2, this.int16[E2 + 1] = r3, this.int16[E2 + 2] = n2, this.float32[C2 + 2] = i2, this.float32[C2 + 3] = s2, this.int16[E2 + 8] = a2, this.int16[E2 + 9] = o2, this.int16[E2 + 10] = l2, this.int16[E2 + 11] = u2, this.int16[E2 + 12] = c2, this.int16[E2 + 13] = h2, this.uint16[E2 + 14] = p2, this.uint16[E2 + 15] = f2, this.uint16[E2 + 16] = d2, this.uint16[E2 + 17] = y2, this.uint16[E2 + 18] = m2, this.uint16[E2 + 19] = g2, this.uint16[E2 + 20] = x2, this.uint16[E2 + 21] = v2, this.uint16[E2 + 22] = b2, this.uint16[E2 + 23] = w2, this.uint16[E2 + 24] = _2, this.uint16[E2 + 25] = A2, this.uint16[E2 + 26] = S2, this.uint16[E2 + 27] = k2, this.uint16[E2 + 28] = I2, this.uint32[C2 + 15] = M2, this.float32[C2 + 16] = T2, this.float32[C2 + 17] = z2, this.float32[C2 + 18] = B2, t2;
          }
        }
        Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
        class Sa extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
        class ka extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r3, n2, i2);
          }
          emplace(t2, e2, r3, n2, i2, s2) {
            const a2 = 5 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
          }
        }
        ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
        class Ia extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r3, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r3, n2);
          }
          emplace(t2, e2, r3, n2, i2) {
            const s2 = 6 * t2;
            return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r3, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
          }
        }
        Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
        class Ma extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t2, e2);
          }
          emplace(t2, e2, r3) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r3, t2;
          }
        }
        Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
        class Ta extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
        class za extends ra {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t2, e2);
          }
          emplace(t2, e2, r3) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r3, t2;
          }
        }
        za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
        class Ba extends ea {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        Ba.prototype.size = 40;
        class Ea extends ma {
          get(t2) {
            return new Ba(this, t2);
          }
        }
        Oi(Ea, "CollisionBoxArray");
        class Ca extends ea {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 49] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 50] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 13] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t2) {
            this._structArray.uint8[this._pos1 + 58] = t2;
          }
        }
        Ca.prototype.size = 60;
        class Pa extends _a {
          get(t2) {
            return new Ca(this, t2);
          }
        }
        Oi(Pa, "PlacedSymbolArray");
        class Da extends ea {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 13];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 28];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 15];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 15] = t2;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 18];
          }
        }
        Da.prototype.size = 76;
        class Va extends Aa {
          get(t2) {
            return new Da(this, t2);
          }
        }
        Oi(Va, "SymbolInstanceArray");
        class La extends Sa {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        Oi(La, "GlyphOffsetArray");
        class Fa extends sa {
          getx(t2) {
            return this.int16[2 * t2 + 0];
          }
          gety(t2) {
            return this.int16[2 * t2 + 1];
          }
        }
        Oi(Fa, "SymbolLineVertexArray");
        class Ra extends ea {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        Ra.prototype.size = 12;
        class ja extends Ia {
          get(t2) {
            return new Ra(this, t2);
          }
        }
        Oi(ja, "FeatureIndexArray");
        class $a extends Ma {
          geta_centroid_pos0(t2) {
            return this.uint16[2 * t2 + 0];
          }
          geta_centroid_pos1(t2) {
            return this.uint16[2 * t2 + 1];
          }
        }
        Oi($a, "FillExtrusionCentroidArray");
        const Ua = na([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Oa = na([{ name: "a_dash", components: 4, type: "Uint16" }]);
        var qa = {}, Na = { get exports() {
          return qa;
        }, set exports(t2) {
          qa = t2;
        } }, Ga = {};
        ({ get exports() {
          return Ga;
        }, set exports(t2) {
          Ga = t2;
        } }).exports = function(t2, e2) {
          var r3, n2, i2, s2, a2, o2, l2, u2;
          for (n2 = t2.length - (r3 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; ) l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r3) {
            case 3:
              l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var Za = {};
        ({ get exports() {
          return Za;
        }, set exports(t2) {
          Za = t2;
        } }).exports = function(t2, e2) {
          for (var r3, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; ) r3 = 1540483477 * (65535 & (r3 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var Xa = Ga, Ka = Za;
        Na.exports = Xa, qa.murmur3 = Xa, qa.murmur2 = Ka;
        class Ya {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r3, n2) {
            this.ids.push(Ha(t2)), this.positions.push(e2, r3, n2);
          }
          getPositions(t2) {
            const e2 = Ha(t2);
            let r3 = 0, n2 = this.ids.length - 1;
            for (; r3 < n2; ) {
              const t3 = r3 + n2 >> 1;
              this.ids[t3] >= e2 ? n2 = t3 : r3 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r3] === e2; ) i2.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
            return i2;
          }
          static serialize(t2, e2) {
            const r3 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return Wa(r3, n2, 0, r3.length - 1), e2 && e2.push(r3.buffer, n2.buffer), { ids: r3, positions: n2 };
          }
          static deserialize(t2) {
            const e2 = new Ya();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          }
        }
        function Ha(t2) {
          const e2 = +t2;
          return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : qa(String(t2));
        }
        function Wa(t2, e2, r3, n2) {
          for (; r3 < n2; ) {
            const i2 = t2[r3 + n2 >> 1];
            let s2 = r3 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2) break;
              Ja(t2, s2, a2), Ja(e2, 3 * s2, 3 * a2), Ja(e2, 3 * s2 + 1, 3 * a2 + 1), Ja(e2, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r3 < n2 - a2 ? (Wa(t2, e2, r3, a2), r3 = a2 + 1) : (Wa(t2, e2, a2 + 1, n2), n2 = a2);
          }
        }
        function Ja(t2, e2, r3) {
          const n2 = t2[e2];
          t2[e2] = t2[r3], t2[r3] = n2;
        }
        Oi(Ya, "FeaturePositionMap");
        class Qa {
          constructor(t2) {
            this.gl = t2.gl, this.initialized = false;
          }
          fetchUniformLocation(t2, e2) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
          }
        }
        class to extends Qa {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && this.current !== r3 && (this.current = r3, this.gl.uniform1f(this.location, r3));
          }
        }
        class eo extends Qa {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0, 0];
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] && r3[3] === this.current[3] || (this.current = r3, this.gl.uniform4f(this.location, r3[0], r3[1], r3[2], r3[3])));
          }
        }
        class ro extends Qa {
          constructor(t2) {
            super(t2), this.current = Me.transparent;
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && (r3.r === this.current.r && r3.g === this.current.g && r3.b === this.current.b && r3.a === this.current.a || (this.current = r3, this.gl.uniform4f(this.location, r3.r, r3.g, r3.b, r3.a)));
          }
        }
        const no = new Float32Array(16), io = new Float32Array(9), so = new Float32Array(4);
        function ao(t2) {
          return [Qs(255 * t2.r, 255 * t2.g), Qs(255 * t2.b, 255 * t2.a)];
        }
        class oo {
          constructor(t2, e2, r3) {
            this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r3;
          }
          setUniform(t2, e2, r3, n2, i2) {
            e2.set(t2, i2, n2.constantOr(this.value));
          }
          getBinding(t2, e2) {
            return "color" === this.type ? new ro(t2) : new to(t2);
          }
        }
        class lo {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t2) {
            this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
          }
          setUniform(t2, e2, r3, n2, i2) {
            const s2 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
            s2 && e2.set(t2, i2, s2);
          }
          getBinding(t2, e2) {
            return "u_pattern" === e2 || "u_dash" === e2 ? new eo(t2) : new to(t2);
          }
        }
        class uo {
          constructor(t2, e2, r3, n2) {
            this.expression = t2, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r3 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r3, n2, i2, s2) {
            const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new $s(0), e2, {}, i2, n2, s2);
            this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
          }
          updatePaintArray(t2, e2, r3, n2, i2) {
            const s2 = this.expression.evaluate({ zoom: 0 }, r3, n2, void 0, i2);
            this._setPaintValue(t2, e2, s2);
          }
          _setPaintValue(t2, e2, r3) {
            if ("color" === this.type) {
              const n2 = ao(r3);
              for (let r4 = t2; r4 < e2; r4++) this.paintVertexArray.emplace(r4, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e2; n2++) this.paintVertexArray.emplace(n2, r3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class co {
          constructor(t2, e2, r3, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r3, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r3 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e2, r3, n2, i2, s2) {
            const a2 = this.expression.evaluate(new $s(this.zoom), e2, {}, i2, n2, s2), o2 = this.expression.evaluate(new $s(this.zoom + 1), e2, {}, i2, n2, s2), l2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(l2, t2, a2, o2);
          }
          updatePaintArray(t2, e2, r3, n2, i2) {
            const s2 = this.expression.evaluate({ zoom: this.zoom }, r3, n2, void 0, i2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n2, void 0, i2);
            this._setPaintValue(t2, e2, s2, a2);
          }
          _setPaintValue(t2, e2, r3, n2) {
            if ("color" === this.type) {
              const i2 = ao(r3), s2 = ao(n2);
              for (let r4 = t2; r4 < e2; r4++) this.paintVertexArray.emplace(r4, i2[0], i2[1], s2[0], s2[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++) this.paintVertexArray.emplace(i2, r3, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2, r3, n2, i2) {
            const s2 = this.useIntegerZoom ? Math.floor(r3.zoom) : r3.zoom, a2 = S(this.expression.interpolationFactor(s2, this.zoom, this.zoom + 1), 0, 1);
            e2.set(t2, i2, a2);
          }
          getBinding(t2, e2) {
            return new to(t2);
          }
        }
        class ho {
          constructor(t2, e2, r3, n2, i2) {
            this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r3 ? Oa : Ua).members;
            for (let t3 = 0; t3 < e2.length; ++t3) ;
            this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r3) {
            const n2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r3);
          }
          updatePaintArray(t2, e2, r3, n2, i2, s2) {
            this._setPaintValues(t2, e2, r3.patterns && r3.patterns[this.layerId], s2);
          }
          _setPaintValues(t2, e2, r3, n2) {
            if (!n2 || !r3) return;
            const i2 = n2[r3];
            if (!i2) return;
            const { tl: s2, br: a2, pixelRatio: o2 } = i2;
            for (let r4 = t2; r4 < e2; r4++) this.paintVertexArray.emplace(r4, s2[0], s2[1], a2[0], a2[1], o2);
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class po {
          constructor(t2, e2, r3 = () => true) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i2 in t2.paint._values) {
              if (!r3(i2)) continue;
              const s2 = t2.paint.get(i2);
              if (!(s2 instanceof Xs && En(s2.property.specification))) continue;
              const a2 = mo(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h2 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind;
              if ("constant" !== o2.kind || h2) if ("source" === o2.kind || h2 || c2) {
                const e3 = vo(i2, l2, "source");
                this.binders[i2] = c2 ? new ho(o2, a2, l2, e3, t2.id) : new uo(o2, a2, l2, e3), n2.push(`/a_${i2}`);
              } else {
                const t3 = vo(i2, l2, "composite");
                this.binders[i2] = new co(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
              else this.binders[i2] = c2 ? new lo(o2.value, a2) : new oo(o2.value, a2, l2), n2.push(`/u_${i2}`);
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof uo || e2 instanceof co ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r3, n2, i2, s2) {
            for (const a2 in this.binders) {
              const o2 = this.binders[a2];
              (o2 instanceof uo || o2 instanceof co || o2 instanceof ho) && o2.populatePaintArray(t2, e2, r3, n2, i2, s2);
            }
          }
          setConstantPatternPositions(t2) {
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              r3 instanceof lo && r3.setConstantPatternPositions(t2);
            }
          }
          updatePaintArrays(t2, e2, r3, n2, i2, s2) {
            let a2 = false;
            for (const o2 in t2) {
              const l2 = e2.getPositions(o2);
              for (const e3 of l2) {
                const l3 = r3.feature(e3.index);
                for (const r4 in this.binders) {
                  const u2 = this.binders[r4];
                  if ((u2 instanceof uo || u2 instanceof co || u2 instanceof ho) && true === u2.expression.isStateDependent) {
                    const c2 = n2.paint.get(r4);
                    u2.expression = c2.value, u2.updatePaintArray(e3.start, e3.end, l3, t2[o2], i2, s2), a2 = true;
                  }
                }
              }
            }
            return a2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              (r3 instanceof oo || r3 instanceof lo) && t2.push(...r3.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              if (r3 instanceof uo || r3 instanceof co || r3 instanceof ho) for (let e3 = 0; e3 < r3.paintVertexAttributes.length; e3++) t2.push(r3.paintVertexAttributes[e3].name);
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              if (r3 instanceof oo || r3 instanceof lo || r3 instanceof co) for (const e3 of r3.uniformNames) t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2) {
            const e2 = [];
            for (const r3 in this.binders) {
              const n2 = this.binders[r3];
              if (n2 instanceof oo || n2 instanceof lo || n2 instanceof co) for (const i2 of n2.uniformNames) e2.push({ name: i2, property: r3, binding: n2.getBinding(t2, i2) });
            }
            return e2;
          }
          setUniforms(t2, e2, r3, n2, i2) {
            for (const { name: e3, property: s2, binding: a2 } of r3) this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r3 = this.binders[e2];
              (r3 instanceof uo || r3 instanceof co || r3 instanceof ho) && r3.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.destroy();
            }
          }
        }
        class fo {
          constructor(t2, e2, r3 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2) this.programConfigurations[n2.id] = new po(n2, e2, r3);
            this.needsUpload = false, this._featureMap = new Ya(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r3, n2, i2, s2, a2) {
            for (const r4 in this.programConfigurations) this.programConfigurations[r4].populatePaintArrays(t2, e2, n2, i2, s2, a2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r3, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r3, n2, i2) {
            for (const s2 of r3) this.needsUpload = this.programConfigurations[s2.id].updatePaintArrays(t2, this._featureMap, e2, s2, n2, i2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
          }
        }
        const yo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function mo(t2, e2) {
          return yo[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        const go = { "line-pattern": { source: ca, composite: ca }, "fill-pattern": { source: ca, composite: ca }, "fill-extrusion-pattern": { source: ca, composite: ca }, "line-dasharray": { source: ha, composite: ha } }, xo = { color: { source: za, composite: ua }, number: { source: Sa, composite: za } };
        function vo(t2, e2, r3) {
          const n2 = go[t2];
          return n2 && n2[r3] || xo[e2][r3];
        }
        Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", { omit: ["_buffers"] }), Oi(fo, "ProgramConfigurationSet");
        const bo = "-transition";
        class wo extends Yt {
          constructor(t2, e2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Zs(e2.layout)), e2.paint)) {
              this._transitionablePaint = new qs(e2.paint);
              for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3], { validate: false });
              for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e2.paint);
            }
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2, r3 = {}) {
            null != e2 && this._validate(Li, `layers.${this.id}.layout.${t2}`, t2, e2, r3) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
          }
          getPaintProperty(t2) {
            return L(t2, bo) ? this._transitionablePaint.getTransition(t2.slice(0, -bo.length)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r3 = {}) {
            if (null != e2 && this._validate(Vi, `layers.${this.id}.paint.${t2}`, t2, e2, r3)) return false;
            if (L(t2, bo)) return this._transitionablePaint.setTransition(t2.slice(0, -bo.length), e2 || void 0), false;
            {
              const r4 = this._transitionablePaint._values[t2], n2 = r4.value.isDataDriven(), i2 = r4.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              const s2 = this._transitionablePaint._values[t2].value, a2 = s2.isDataDriven(), o2 = L(t2, "pattern") || "line-dasharray" === t2;
              return a2 || n2 || o2 || this._handleOverridablePaintPropertyUpdate(t2, i2, s2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          getProgramIds() {
            return null;
          }
          getProgramConfiguration(t2) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r3) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), R(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
          }
          _validate(t2, e2, r3, n2, i2 = {}) {
            return (!i2 || false !== i2.validate) && Ri(this, t2.call(Di, { key: e2, layerType: this.type, objectKey: r3, value: n2, styleSpec: Ht, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof Xs && En(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
        }
        const _o = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), Ao = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class So {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e2, r3, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > So.MAX_VERTEX_ARRAY_LENGTH && U(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > So.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r3, n2) {
            return new So([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r3, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");
        var ko = 8192;
        class Io {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
          }
          extend(t2) {
            const e2 = this._sw, r3 = this._ne;
            let n2, i2;
            if (t2 instanceof ru) n2 = t2, i2 = t2;
            else {
              if (!(t2 instanceof Io)) return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Io.convert(t2)) : this.extend(ru.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(ru.convert(t2)) : this;
              if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2) return this;
            }
            return e2 || r3 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r3.lng = Math.max(i2.lng, r3.lng), r3.lat = Math.max(i2.lat, r3.lat)) : (this._sw = new ru(n2.lng, n2.lat), this._ne = new ru(i2.lng, i2.lat)), this;
          }
          getCenter() {
            return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new ru(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new ru(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: e2, lat: r3 } = ru.convert(t2);
            let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && n2;
          }
          static convert(t2) {
            return !t2 || t2 instanceof Io ? t2 : new Io(t2);
          }
        }
        var Mo = 1e-6, To = "undefined" != typeof Float32Array ? Float32Array : Array;
        function zo() {
          var t2 = new To(9);
          return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        function Bo(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = r3[0], f2 = r3[1], d2 = r3[2], y2 = r3[3], m2 = r3[4], g2 = r3[5], x2 = r3[6], v2 = r3[7], b2 = r3[8];
          return t2[0] = p2 * n2 + f2 * a2 + d2 * u2, t2[1] = p2 * i2 + f2 * o2 + d2 * c2, t2[2] = p2 * s2 + f2 * l2 + d2 * h2, t2[3] = y2 * n2 + m2 * a2 + g2 * u2, t2[4] = y2 * i2 + m2 * o2 + g2 * c2, t2[5] = y2 * s2 + m2 * l2 + g2 * h2, t2[6] = x2 * n2 + v2 * a2 + b2 * u2, t2[7] = x2 * i2 + v2 * o2 + b2 * c2, t2[8] = x2 * s2 + v2 * l2 + b2 * h2, t2;
        }
        function Eo(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function Co(t2, e2) {
          var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r3 * o2 - n2 * a2, v2 = r3 * l2 - i2 * a2, b2 = r3 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, M2 = h2 * m2 - p2 * y2, T2 = h2 * g2 - f2 * y2, z2 = p2 * g2 - f2 * m2, B2 = x2 * z2 - v2 * T2 + b2 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
          return B2 ? (t2[0] = (o2 * z2 - l2 * T2 + u2 * M2) * (B2 = 1 / B2), t2[1] = (i2 * T2 - n2 * z2 - s2 * M2) * B2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * B2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * B2, t2[4] = (l2 * I2 - a2 * z2 - u2 * k2) * B2, t2[5] = (r3 * z2 - i2 * I2 + s2 * k2) * B2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * B2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * B2, t2[8] = (a2 * T2 - o2 * I2 + u2 * S2) * B2, t2[9] = (n2 * I2 - r3 * T2 - s2 * S2) * B2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * B2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * B2, t2[12] = (o2 * k2 - a2 * M2 - l2 * S2) * B2, t2[13] = (r3 * M2 - n2 * k2 + i2 * S2) * B2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * B2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * B2, t2) : null;
        }
        function Po(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r3[0], b2 = r3[1], w2 = r3[2], _2 = r3[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r3[4]) * n2 + (b2 = r3[5]) * o2 + (w2 = r3[6]) * h2 + (_2 = r3[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r3[8]) * n2 + (b2 = r3[9]) * o2 + (w2 = r3[10]) * h2 + (_2 = r3[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r3[12]) * n2 + (b2 = r3[13]) * o2 + (w2 = r3[14]) * h2 + (_2 = r3[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
        }
        function Do(t2, e2, r3) {
          var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r3[0], m2 = r3[1], g2 = r3[2];
          return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
        }
        function Vo(t2, e2, r3) {
          var n2 = r3[0], i2 = r3[1], s2 = r3[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }
        function Lo(t2, e2, r3) {
          var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }
        function Fo(t2, e2, r3) {
          var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
        }
        function Ro(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function jo(t2, e2, r3) {
          var n2, i2, s2, a2 = r3[0], o2 = r3[1], l2 = r3[2], u2 = Math.hypot(a2, o2, l2);
          return u2 < Mo ? null : (a2 *= u2 = 1 / u2, o2 *= u2, l2 *= u2, n2 = Math.sin(e2), i2 = Math.cos(e2), t2[0] = a2 * a2 * (s2 = 1 - i2) + i2, t2[1] = o2 * a2 * s2 + l2 * n2, t2[2] = l2 * a2 * s2 - o2 * n2, t2[3] = 0, t2[4] = a2 * o2 * s2 - l2 * n2, t2[5] = o2 * o2 * s2 + i2, t2[6] = l2 * o2 * s2 + a2 * n2, t2[7] = 0, t2[8] = a2 * l2 * s2 + o2 * n2, t2[9] = o2 * l2 * s2 - a2 * n2, t2[10] = l2 * l2 * s2 + i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e2 = arguments.length; e2--; ) t2 += arguments[e2] * arguments[e2];
          return Math.sqrt(t2);
        });
        var $o = Po;
        function Uo() {
          var t2 = new To(3);
          return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function Oo(t2) {
          var e2 = new To(3);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
        }
        function qo(t2) {
          return Math.hypot(t2[0], t2[1], t2[2]);
        }
        function No(t2, e2, r3) {
          var n2 = new To(3);
          return n2[0] = t2, n2[1] = e2, n2[2] = r3, n2;
        }
        function Go(t2, e2, r3) {
          return t2[0] = e2[0] + r3[0], t2[1] = e2[1] + r3[1], t2[2] = e2[2] + r3[2], t2;
        }
        function Zo(t2, e2, r3) {
          return t2[0] = e2[0] - r3[0], t2[1] = e2[1] - r3[1], t2[2] = e2[2] - r3[2], t2;
        }
        function Xo(t2, e2, r3) {
          return t2[0] = e2[0] * r3[0], t2[1] = e2[1] * r3[1], t2[2] = e2[2] * r3[2], t2;
        }
        function Ko(t2, e2, r3) {
          return t2[0] = Math.min(e2[0], r3[0]), t2[1] = Math.min(e2[1], r3[1]), t2[2] = Math.min(e2[2], r3[2]), t2;
        }
        function Yo(t2, e2, r3) {
          return t2[0] = Math.max(e2[0], r3[0]), t2[1] = Math.max(e2[1], r3[1]), t2[2] = Math.max(e2[2], r3[2]), t2;
        }
        function Ho(t2, e2, r3) {
          return t2[0] = e2[0] * r3, t2[1] = e2[1] * r3, t2[2] = e2[2] * r3, t2;
        }
        function Wo(t2, e2, r3, n2) {
          return t2[0] = e2[0] + r3[0] * n2, t2[1] = e2[1] + r3[1] * n2, t2[2] = e2[2] + r3[2] * n2, t2;
        }
        function Jo(t2, e2) {
          var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r3 * r3 + n2 * n2 + i2 * i2;
          return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
        }
        function Qo(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
        }
        function tl(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[0], o2 = r3[1], l2 = r3[2];
          return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
        }
        function el(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r3[3] * n2 + r3[7] * i2 + r3[11] * s2 + r3[15];
          return t2[0] = (r3[0] * n2 + r3[4] * i2 + r3[8] * s2 + r3[12]) / (a2 = a2 || 1), t2[1] = (r3[1] * n2 + r3[5] * i2 + r3[9] * s2 + r3[13]) / a2, t2[2] = (r3[2] * n2 + r3[6] * i2 + r3[10] * s2 + r3[14]) / a2, t2;
        }
        function rl(t2, e2, r3) {
          var n2 = r3[0], i2 = r3[1], s2 = r3[2], a2 = e2[0], o2 = e2[1], l2 = e2[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h2 = n2 * o2 - i2 * a2, p2 = i2 * h2 - s2 * c2, f2 = s2 * u2 - n2 * h2, d2 = n2 * c2 - i2 * u2, y2 = 2 * r3[3];
          return c2 *= y2, h2 *= y2, f2 *= 2, d2 *= 2, t2[0] = a2 + (u2 *= y2) + (p2 *= 2), t2[1] = o2 + c2 + f2, t2[2] = l2 + h2 + d2, t2;
        }
        var nl, il = Zo, sl = Xo, al = qo;
        function ol(t2, e2, r3) {
          return t2[0] = e2[0] * r3, t2[1] = e2[1] * r3, t2[2] = e2[2] * r3, t2[3] = e2[3] * r3, t2;
        }
        function ll(t2, e2) {
          var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 * r3 + n2 * n2 + i2 * i2 + s2 * s2;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r3 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
        }
        function ul(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
          return t2[0] = r3[0] * n2 + r3[4] * i2 + r3[8] * s2 + r3[12] * a2, t2[1] = r3[1] * n2 + r3[5] * i2 + r3[9] * s2 + r3[13] * a2, t2[2] = r3[2] * n2 + r3[6] * i2 + r3[10] * s2 + r3[14] * a2, t2[3] = r3[3] * n2 + r3[7] * i2 + r3[11] * s2 + r3[15] * a2, t2;
        }
        function cl() {
          var t2 = new To(4);
          return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function hl(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
        }
        function pl(t2, e2, r3) {
          r3 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
        }
        function fl(t2, e2, r3) {
          r3 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          return t2[0] = n2 * l2 - s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = s2 * l2 + n2 * o2, t2[3] = a2 * l2 - i2 * o2, t2;
        }
        Uo(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);
        var dl = ll;
        Uo(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();
        const yl = na([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: ml } = yl, gl = na([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var xl = na([{ name: "a_pos", type: "Int16", components: 2 }]);
        class vl {
          constructor(t2, e2) {
            this.pos = t2, this.dir = e2;
          }
          intersectsPlane(t2, e2, r3) {
            const n2 = Qo(e2, this.dir);
            if (Math.abs(n2) < 1e-6) return false;
            const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
            return r3[0] = this.pos[0] + this.dir[0] * i2, r3[1] = this.pos[1] + this.dir[1] * i2, r3[2] = this.pos[2] + this.dir[2] * i2, true;
          }
          closestPointOnSphere(t2, e2, r3) {
            if (function(t3, e3) {
              var r4 = t3[0], n3 = t3[1], i3 = t3[2], s3 = e3[0], a3 = e3[1], o3 = e3[2];
              return Math.abs(r4 - s3) <= Mo * Math.max(1, Math.abs(r4), Math.abs(s3)) && Math.abs(n3 - a3) <= Mo * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= Mo * Math.max(1, Math.abs(i3), Math.abs(o3));
            }(this.pos, t2) || 0 === e2) return r3[0] = r3[1] = r3[2] = 0, false;
            const [n2, i2, s2] = this.dir, a2 = this.pos[0] - t2[0], o2 = this.pos[1] - t2[1], l2 = this.pos[2] - t2[2], u2 = n2 * n2 + i2 * i2 + s2 * s2, c2 = 2 * (a2 * n2 + o2 * i2 + l2 * s2), h2 = c2 * c2 - 4 * u2 * (a2 * a2 + o2 * o2 + l2 * l2 - e2 * e2);
            if (h2 < 0) {
              const t3 = Math.max(-c2 / 2, 0), u3 = a2 + n2 * t3, h3 = o2 + i2 * t3, p2 = l2 + s2 * t3, f2 = Math.hypot(u3, h3, p2);
              return r3[0] = u3 * e2 / f2, r3[1] = h3 * e2 / f2, r3[2] = p2 * e2 / f2, false;
            }
            {
              const t3 = (-c2 - Math.sqrt(h2)) / (2 * u2);
              if (t3 < 0) {
                const t4 = Math.hypot(a2, o2, l2);
                return r3[0] = a2 * e2 / t4, r3[1] = o2 * e2 / t4, r3[2] = l2 * e2 / t4, false;
              }
              return r3[0] = a2 + n2 * t3, r3[1] = o2 + i2 * t3, r3[2] = l2 + s2 * t3, true;
            }
          }
        }
        class bl {
          constructor(t2, e2, r3, n2, i2) {
            this.TL = t2, this.TR = e2, this.BR = r3, this.BL = n2, this.horizon = i2;
          }
          static fromInvProjectionMatrix(t2, e2, r3) {
            const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = el(n2, n2, t2), l2 = el(i2, i2, t2), u2 = el(s2, s2, t2), c2 = el(a2, a2, t2);
            return new bl(o2, l2, u2, c2, e2 / r3);
          }
        }
        class wl {
          constructor(t2, e2) {
            this.points = t2, this.planes = e2;
          }
          static fromInvProjectionMatrix(t2, e2, r3, n2) {
            const i2 = Math.pow(2, r3), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r4) => {
              const s3 = ul([], r4, t2), a3 = 1 / s3[3] / e2 * i2;
              return function(t3, e3, r5) {
                return t3[0] = e3[0] * r5[0], t3[1] = e3[1] * r5[1], t3[2] = e3[2] * r5[2], t3[3] = e3[3] * r5[3], t3;
              }(s3, s3, [a3, a3, n2 ? 1 / s3[3] : a3, a3]);
            }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e3 = Jo([], tl([], il([], s2[t3[0]], s2[t3[1]]), il([], s2[t3[2]], s2[t3[1]]))), r4 = -Qo(e3, s2[t3[1]]);
              return e3.concat(r4);
            });
            return new wl(s2, a2);
          }
        }
        class _l {
          static fromPoints(t2) {
            const e2 = [1 / 0, 1 / 0, 1 / 0], r3 = [-1 / 0, -1 / 0, -1 / 0];
            for (const n2 of t2) Ko(e2, e2, n2), Yo(r3, r3, n2);
            return new _l(e2, r3);
          }
          static applyTransform(t2, e2) {
            const r3 = t2.getCorners();
            for (let t3 = 0; t3 < r3.length; ++t3) el(r3[t3], r3[t3], e2);
            return _l.fromPoints(r3);
          }
          constructor(t2, e2) {
            this.min = t2, this.max = e2, this.center = Ho([], Go([], this.min, this.max), 0.5);
          }
          quadrant(t2) {
            const e2 = [t2 % 2 == 0, t2 < 2], r3 = Oo(this.min), n2 = Oo(this.max);
            for (let t3 = 0; t3 < e2.length; t3++) r3[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
            return n2[2] = this.max[2], new _l(r3, n2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          distanceZ(t2) {
            return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
          }
          getCorners() {
            const t2 = this.min, e2 = this.max;
            return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
          }
          intersects(t2) {
            const e2 = this.getCorners();
            let r3 = true;
            for (let n2 = 0; n2 < t2.planes.length; n2++) {
              const i2 = t2.planes[n2];
              let s2 = 0;
              for (let t3 = 0; t3 < e2.length; t3++) s2 += Qo(i2, e2[t3]) + i2[3] >= 0;
              if (0 === s2) return 0;
              s2 !== e2.length && (r3 = false);
            }
            if (r3) return 2;
            for (let e3 = 0; e3 < 3; e3++) {
              let r4 = Number.MAX_VALUE, n2 = -Number.MAX_VALUE;
              for (let i2 = 0; i2 < t2.points.length; i2++) {
                const s2 = t2.points[i2][e3] - this.min[e3];
                r4 = Math.min(r4, s2), n2 = Math.max(n2, s2);
              }
              if (n2 < 0 || r4 > this.max[e3] - this.min[e3]) return 0;
            }
            return 1;
          }
        }
        const Al = ko / Math.PI / 2, Sl = 64, kl = [Sl, 32, 16], Il = -Al, Ml = Al, Tl = [new _l([Il, Il, Il], [Ml, Ml, Ml]), new _l([Il, Il, Il], [0, 0, Ml]), new _l([0, Il, Il], [Ml, 0, Ml]), new _l([Il, 0, Il], [0, Ml, Ml]), new _l([0, 0, Il], [Ml, Ml, Ml])];
        function zl(t2) {
          return t2 * Al / tu;
        }
        function Bl(t2, e2, r3, n2 = true) {
          const i2 = Ho([], t2._camera.position, t2.worldSize), s2 = [e2, r3, 1, 1];
          ul(s2, s2, t2.pixelMatrixInverse), ol(s2, s2, 1 / s2[3]);
          const a2 = Jo([], il([], s2, i2)), o2 = t2.globeMatrix, l2 = [o2[12], o2[13], o2[14]], u2 = il([], l2, i2), c2 = qo(u2), h2 = Jo([], u2), p2 = t2.worldSize / (2 * Math.PI), f2 = Qo(h2, a2), d2 = Math.asin(p2 / c2);
          if (d2 < Math.acos(f2)) {
            if (!n2) return null;
            const t3 = [], e3 = [];
            Ho(t3, a2, c2 / f2), Jo(e3, il(e3, t3, u2)), Jo(a2, Go(a2, u2, Ho(a2, e3, Math.tan(d2) * c2)));
          }
          const y2 = [];
          new vl(i2, a2).closestPointOnSphere(l2, p2, y2);
          const m2 = Jo([], Y(o2, 0)), g2 = Jo([], Y(o2, 1)), x2 = Jo([], Y(o2, 2)), b2 = Qo(m2, y2), w2 = Qo(g2, y2), _2 = Qo(x2, y2), A2 = v(Math.asin(-w2 / p2));
          let k2 = v(Math.atan2(b2, _2));
          k2 = t2.center.lng + function(t3, e3) {
            const r4 = (e3 - t3 + 180) % 360 - 180;
            return r4 < -180 ? r4 + 360 : r4;
          }(t2.center.lng, k2);
          const I2 = iu(k2), M2 = S(su(A2), 0, 1);
          return new pu(I2, M2);
        }
        class El {
          constructor(t2, e2, r3) {
            this.a = il([], t2, r3), this.b = il([], e2, r3), this.center = r3;
            const n2 = Jo([], this.a), i2 = Jo([], this.b);
            this.angle = Math.acos(Qo(n2, i2));
          }
        }
        function Cl(t2, e2) {
          if (0 === t2.angle) return null;
          let r3;
          return r3 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r3 < 0 || r3 > 1 ? null : function(t3, e3, r4, n2) {
            const i2 = Math.sin(r4);
            return t3 * (Math.sin((1 - n2) * r4) / i2) + e3 * (Math.sin(n2 * r4) / i2);
          }(t2.a[e2], t2.b[e2], t2.angle, S(r3, 0, 1)) + t2.center[e2];
        }
        function Pl(t2) {
          if (t2.z <= 1) return Tl[t2.z + 2 * t2.y + t2.x];
          const e2 = jl(Rl(t2));
          return _l.fromPoints(e2);
        }
        function Dl(t2, e2, r3) {
          return Ho(t2, t2, 1 - r3), Wo(t2, t2, e2, r3);
        }
        function Vl(t2, e2) {
          const r3 = Kl(e2.zoom);
          if (0 === r3) return Pl(t2);
          const n2 = Rl(t2), i2 = jl(n2), s2 = iu(n2.getWest()) * e2.worldSize, a2 = iu(n2.getEast()) * e2.worldSize, o2 = su(n2.getNorth()) * e2.worldSize, l2 = su(n2.getSouth()) * e2.worldSize, u2 = [s2, o2, 0], c2 = [a2, o2, 0], h2 = [s2, l2, 0], p2 = [a2, l2, 0], f2 = Co([], e2.globeMatrix);
          return el(u2, u2, f2), el(c2, c2, f2), el(h2, h2, f2), el(p2, p2, f2), i2[0] = Dl(i2[0], h2, r3), i2[1] = Dl(i2[1], p2, r3), i2[2] = Dl(i2[2], c2, r3), i2[3] = Dl(i2[3], u2, r3), _l.fromPoints(i2);
        }
        function Ll(t2, e2, r3) {
          for (const n2 of t2) el(n2, n2, e2), Ho(n2, n2, r3);
        }
        function Fl(t2, e2, r3) {
          const n2 = e2 / t2.worldSize, i2 = t2.globeMatrix;
          if (r3.z <= 1) {
            const t3 = Pl(r3).getCorners();
            return Ll(t3, i2, n2), _l.fromPoints(t3);
          }
          const s2 = Rl(r3), a2 = jl(s2);
          Ll(a2, i2, n2);
          const o2 = Number.MAX_VALUE, l2 = [-o2, -o2, -o2], u2 = [o2, o2, o2];
          if (s2.contains(t2.center)) {
            for (const t3 of a2) Ko(u2, u2, t3), Yo(l2, l2, t3);
            l2[2] = 0;
            const e3 = t2.point, r4 = [e3.x * n2, e3.y * n2, 0];
            return Ko(u2, u2, r4), Yo(l2, l2, r4), new _l(u2, l2);
          }
          const c2 = [i2[12] * n2, i2[13] * n2, i2[14] * n2], h2 = s2.getCenter(), p2 = S(t2.center.lat, -cu, cu), f2 = S(h2.lat, -cu, cu), d2 = iu(t2.center.lng), y2 = su(p2);
          let m2 = d2 - iu(h2.lng);
          const g2 = y2 - su(f2);
          m2 > 0.5 ? m2 -= 1 : m2 < -0.5 && (m2 += 1);
          let v2 = 0;
          Math.abs(m2) > Math.abs(g2) ? v2 = m2 >= 0 ? 1 : 3 : (v2 = g2 >= 0 ? 0 : 2, Wo(c2, c2, [i2[4] * n2, i2[5] * n2, i2[6] * n2], -Math.sin(x(g2 >= 0 ? s2.getSouth() : s2.getNorth())) * Al));
          const b2 = a2[v2], w2 = a2[(v2 + 1) % 4], _2 = new El(b2, w2, c2), A2 = [Cl(_2, 0) || b2[0], Cl(_2, 1) || b2[1], Cl(_2, 2) || b2[2]], k2 = Kl(t2.zoom);
          if (k2 > 0) {
            const n3 = function({ x: t3, y: e3, z: r4 }, n4, i4, s3, a3) {
              const o3 = 1 / (1 << r4);
              let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
              const f3 = (l3 + u3) / 2 - s3;
              return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h3 = (h3 * n4 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
            }(r3, e2, t2._pixelsPerMercatorPixel, d2, y2);
            for (let t3 = 0; t3 < a2.length; t3++) Dl(a2[t3], n3[t3], k2);
            const i3 = Go([], n3[v2], n3[(v2 + 1) % 4]);
            Ho(i3, i3, 0.5), Dl(A2, i3, k2);
          }
          for (const t3 of a2) Ko(u2, u2, t3), Yo(l2, l2, t3);
          return u2[2] = Math.min(b2[2], w2[2]), Ko(u2, u2, A2), Yo(l2, l2, A2), new _l(u2, l2);
        }
        function Rl({ x: t2, y: e2, z: r3 }) {
          const n2 = 1 / (1 << r3), i2 = new ru(ou(t2 * n2), lu((e2 + 1) * n2)), s2 = new ru(ou((t2 + 1) * n2), lu(e2 * n2));
          return new Io(i2, s2);
        }
        function jl(t2) {
          const e2 = x(t2.getNorth()), r3 = x(t2.getSouth()), n2 = Math.cos(e2), i2 = Math.cos(r3), s2 = Math.sin(e2), a2 = Math.sin(r3), o2 = t2.getWest(), l2 = t2.getEast();
          return [$l(i2, a2, o2), $l(i2, a2, l2), $l(n2, s2, l2), $l(n2, s2, o2)];
        }
        function $l(t2, e2, r3, n2 = Al) {
          return r3 = x(r3), [t2 * Math.sin(r3) * n2, -e2 * n2, t2 * Math.cos(r3) * n2];
        }
        function Ul(t2, e2, r3) {
          return $l(Math.cos(x(t2)), Math.sin(x(t2)), e2, r3);
        }
        function Ol(t2, e2, r3, n2) {
          const i2 = 1 << r3.z, s2 = (t2 / ko + r3.x) / i2;
          return Ul(lu((e2 / ko + r3.y) / i2), ou(s2), n2);
        }
        function ql({ min: t2, max: e2 }) {
          return 16383 / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
        }
        const Nl = new Float64Array(16);
        function Gl(t2) {
          const e2 = ql(t2), r3 = Ro(Nl, [e2, e2, e2]);
          return Do(r3, r3, ((n2 = [])[0] = -(i2 = t2.min)[0], n2[1] = -i2[1], n2[2] = -i2[2], n2));
          var n2, i2;
        }
        function Zl(t2) {
          const e2 = (n2 = t2.min, (r3 = Nl)[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = n2[0], r3[13] = n2[1], r3[14] = n2[2], r3[15] = 1, r3);
          var r3, n2;
          const i2 = 1 / ql(t2);
          return Vo(e2, e2, [i2, i2, i2]);
        }
        function Xl(t2, e2, r3, n2, i2) {
          const s2 = function(t3) {
            const e3 = ko / (2 * Math.PI);
            return t3 / (2 * Math.PI) / e3;
          }(r3), a2 = [t2, e2, -r3 / (2 * Math.PI)], o2 = Eo(new Float64Array(16));
          return Do(o2, o2, a2), Vo(o2, o2, [s2, s2, s2]), Lo(o2, o2, x(-i2)), Fo(o2, o2, x(-n2)), o2;
        }
        function Kl(t2) {
          return k(5, 6, t2);
        }
        function Yl(t2, e2) {
          const r3 = Ul(e2.lat, e2.lng), n2 = function(t3) {
            const e3 = Ul(t3._center.lat, t3._center.lng);
            let r4 = tl([], No(0, 1, 0), e3);
            const n3 = jo([], -t3.angle, e3);
            r4 = el(r4, r4, n3), jo(n3, -t3._pitch, r4);
            const i3 = Jo([], e3);
            return Ho(i3, i3, zl(t3.cameraToCenterDistance / t3.pixelsPerMeter)), el(i3, i3, n3), Go([], e3, i3);
          }(t2);
          return a2 = (i2 = Zo([], n2, r3))[0], o2 = i2[1], l2 = i2[2], u2 = (s2 = r3)[0], c2 = s2[1], h2 = s2[2], f2 = (p2 = Math.sqrt(a2 * a2 + o2 * o2 + l2 * l2) * Math.sqrt(u2 * u2 + c2 * c2 + h2 * h2)) && Qo(i2, s2) / p2, Math.acos(Math.min(Math.max(f2, -1), 1));
          var i2, s2, a2, o2, l2, u2, c2, h2, p2, f2;
        }
        function Hl(t2, e2) {
          return Yl(t2, e2) > Math.PI / 2 * 1.01;
        }
        const Wl = x(85), Jl = Math.cos(Wl), Ql = Math.sin(Wl), tu = 63710088e-1, eu = 2 * Math.PI * tu;
        class ru {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ru(I(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r3 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r3) * Math.sin(n2) + Math.cos(r3) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return tu * Math.acos(Math.min(i2, 1));
          }
          toBounds(t2 = 0) {
            const e2 = 360 * t2 / 40075017, r3 = e2 / Math.cos(Math.PI / 180 * this.lat);
            return new Io(new ru(this.lng - r3, this.lat - e2), new ru(this.lng + r3, this.lat + e2));
          }
          toEcef(t2) {
            const e2 = zl(t2);
            return Ul(this.lat, this.lng, Al + e2);
          }
          static convert(t2) {
            if (t2 instanceof ru) return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new ru(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new ru(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        function nu(t2) {
          return eu * Math.cos(t2 * Math.PI / 180);
        }
        function iu(t2) {
          return (180 + t2) / 360;
        }
        function su(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function au(t2, e2) {
          return t2 / nu(e2);
        }
        function ou(t2) {
          return 360 * t2 - 180;
        }
        function lu(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        function uu(t2, e2) {
          return t2 * nu(lu(e2));
        }
        const cu = 85.051129;
        function hu(t2) {
          return 1 / Math.cos(t2 * Math.PI / 180);
        }
        class pu {
          constructor(t2, e2, r3 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r3;
          }
          static fromLngLat(t2, e2 = 0) {
            const r3 = ru.convert(t2);
            return new pu(iu(r3.lng), su(r3.lat), au(e2, r3.lat));
          }
          toLngLat() {
            return new ru(ou(this.x), lu(this.y));
          }
          toAltitude() {
            return uu(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / eu * hu(lu(this.y));
          }
        }
        function fu(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          const u2 = (e2 + n2) / 2, c2 = (r3 + i2) / 2, h2 = new d(u2, c2);
          o2(h2), function(t3, e3, r4, n3, i3, s3) {
            const a3 = r4 - i3, o3 = n3 - s3;
            return Math.abs((n3 - e3) * a3 - (r4 - t3) * o3) / Math.hypot(a3, o3);
          }(h2.x, h2.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? (fu(t2, e2, r3, u2, c2, s2, h2, o2, l2), fu(t2, u2, c2, n2, i2, h2, a2, o2, l2)) : t2.push(a2);
        }
        function du(t2, e2, r3) {
          let n2 = t2[0], i2 = n2.x, s2 = n2.y;
          e2(n2);
          const a2 = [n2];
          for (let o2 = 1; o2 < t2.length; o2++) {
            const l2 = t2[o2], { x: u2, y: c2 } = l2;
            e2(l2), fu(a2, i2, s2, u2, c2, n2, l2, e2, r3), i2 = u2, s2 = c2, n2 = l2;
          }
          return a2;
        }
        function yu(t2, e2, r3, n2) {
          if (n2(e2, r3)) {
            const i2 = e2.add(r3)._mult(0.5);
            yu(t2, e2, i2, n2), yu(t2, i2, r3, n2);
          } else t2.push(r3);
        }
        function mu(t2, e2) {
          let r3 = t2[0];
          const n2 = [r3];
          for (let i2 = 1; i2 < t2.length; i2++) {
            const s2 = t2[i2];
            yu(n2, r3, s2, e2), r3 = s2;
          }
          return n2;
        }
        const gu = Math.pow(2, 14) - 1, xu = -gu - 1;
        function vu(t2, e2) {
          const r3 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
          return t2.x = S(r3, xu, gu), t2.y = S(n2, xu, gu), (r3 < t2.x || r3 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && U("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
        }
        function bu(t2, e2, r3) {
          const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = ko / i2;
          if (e2 && r3 && r3.projection.isReprojectedInTileSpace) {
            const s3 = 1 << e2.z, { scale: a2, x: o2, y: l2, projection: u2 } = r3, c2 = (t3) => {
              const r4 = ou((e2.x + t3.x / i2) / s3), n3 = lu((e2.y + t3.y / i2) / s3), c3 = u2.project(r4, n3);
              t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
            };
            for (let e3 = 0; e3 < n2.length; e3++) if (1 !== t2.type) n2[e3] = du(n2[e3], c2, 1);
            else {
              const t3 = [];
              for (const r4 of n2[e3]) r4.x < 0 || r4.x >= i2 || r4.y < 0 || r4.y >= i2 || (c2(r4), t3.push(r4));
              n2[e3] = t3;
            }
          }
          for (const t3 of n2) for (const e3 of t3) vu(e3, s2);
          return n2;
        }
        function wu(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? bu(t2) : [] };
        }
        function _u(t2, e2, r3, n2, i2) {
          t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r3 + (i2 + 1) / 2);
        }
        function Au(t2, e2, r3) {
          const n2 = 16384;
          t2.emplaceBack(e2.x, e2.y, e2.z, r3[0] * n2, r3[1] * n2, r3[2] * n2);
        }
        class Su {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.segments = new So(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r3, n2) {
            const i2 = this.layers[0], s2 = [];
            let a2 = null;
            "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
            for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), u2, r3)) continue;
              const c2 = a2 ? a2.evaluate(u2, {}, r3) : void 0, h2 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o3, geometry: t3 ? u2.geometry : bu(e3, r3, n2), patterns: {}, sortKey: c2 };
              s2.push(h2);
            }
            a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            let o2 = null;
            "globe" === n2.projection.name && (this.globeExtVertexArray = new pa(), o2 = n2.projection);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
              this.addFeature(n3, i3, s3, e2.availableImages, r3, o2), e2.featureIndex.insert(l2, i3, s3, a3, this.index);
            }
          }
          update(t2, e2, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3, n2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(t2, e2, r3, n2, i2, s2) {
            for (const r4 of e2) for (const e3 of r4) {
              const r5 = e3.x, n3 = e3.y;
              if (r5 < 0 || r5 >= ko || n3 < 0 || n3 >= ko) continue;
              if (s2) {
                const t3 = s2.projectTilePoint(r5, n3, i2), e4 = s2.upVector(i2, r5, n3), a3 = this.globeExtVertexArray;
                Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4);
              }
              const a2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a2.vertexLength;
              _u(this.layoutVertexArray, r5, n3, -1, -1), _u(this.layoutVertexArray, r5, n3, 1, -1), _u(this.layoutVertexArray, r5, n3, 1, 1), _u(this.layoutVertexArray, r5, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a2.vertexLength += 4, a2.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, {}, n2, i2);
          }
        }
        function ku(t2, e2) {
          for (let r3 = 0; r3 < t2.length; r3++) if (Du(e2, t2[r3])) return true;
          for (let r3 = 0; r3 < e2.length; r3++) if (Du(t2, e2[r3])) return true;
          return !!zu(t2, e2);
        }
        function Iu(t2, e2, r3) {
          return !!Du(t2, e2) || !!Eu(e2, t2, r3);
        }
        function Mu(t2, e2) {
          if (1 === t2.length) return Pu(e2, t2[0]);
          for (let r3 = 0; r3 < e2.length; r3++) {
            const n2 = e2[r3];
            for (let e3 = 0; e3 < n2.length; e3++) if (Du(t2, n2[e3])) return true;
          }
          for (let r3 = 0; r3 < t2.length; r3++) if (Pu(e2, t2[r3])) return true;
          for (let r3 = 0; r3 < e2.length; r3++) if (zu(t2, e2[r3])) return true;
          return false;
        }
        function Tu(t2, e2, r3) {
          if (t2.length > 1) {
            if (zu(t2, e2)) return true;
            for (let n2 = 0; n2 < e2.length; n2++) if (Eu(e2[n2], t2, r3)) return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++) if (Eu(t2[n2], e2, r3)) return true;
          return false;
        }
        function zu(t2, e2) {
          if (0 === t2.length || 0 === e2.length) return false;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n2 = t2[r3], i2 = t2[r3 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++) if (Bu(n2, i2, e2[t3], e2[t3 + 1])) return true;
          }
          return false;
        }
        function Bu(t2, e2, r3, n2) {
          return O(t2, r3, n2) !== O(e2, r3, n2) && O(t2, e2, r3) !== O(t2, e2, n2);
        }
        function Eu(t2, e2, r3) {
          const n2 = r3 * r3;
          if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
          for (let r4 = 1; r4 < e2.length; r4++) if (Cu(t2, e2[r4 - 1], e2[r4]) < n2) return true;
          return false;
        }
        function Cu(t2, e2, r3) {
          const n2 = e2.distSqr(r3);
          if (0 === n2) return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r3.x - e2.x) + (t2.y - e2.y) * (r3.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r3 : r3.sub(e2)._mult(i2)._add(e2));
        }
        function Pu(t2, e2) {
          let r3, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r3 = t2[a2];
            for (let t3 = 0, a3 = r3.length - 1; t3 < r3.length; a3 = t3++) n2 = r3[t3], i2 = r3[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function Du(t2, e2) {
          let r3 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r3 = !r3);
          }
          return r3;
        }
        function Vu(t2, e2, r3, n2, i2) {
          for (const s3 of t2) if (e2 <= s3.x && r3 <= s3.y && n2 >= s3.x && i2 >= s3.y) return true;
          const s2 = [new d(e2, r3), new d(e2, i2), new d(n2, i2), new d(n2, r3)];
          if (t2.length > 2) {
            for (const e3 of s2) if (Du(t2, e3)) return true;
          }
          for (let e3 = 0; e3 < t2.length - 1; e3++) if (Lu(t2[e3], t2[e3 + 1], s2)) return true;
          return false;
        }
        function Lu(t2, e2, r3) {
          const n2 = r3[0], i2 = r3[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
          const s2 = O(t2, e2, r3[0]);
          return s2 !== O(t2, e2, r3[1]) || s2 !== O(t2, e2, r3[2]) || s2 !== O(t2, e2, r3[3]);
        }
        function Fu(t2, e2, r3) {
          const n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r3.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function Ru(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function ju(t2, e2, r3, n2, i2) {
          if (!e2[0] && !e2[1]) return t2;
          const s2 = d.convert(e2)._mult(i2);
          "viewport" === r3 && s2._rotate(-n2);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3++) a2.push(t2[e3].sub(s2));
          return a2;
        }
        function $u(t2, e2, r3, n2) {
          const i2 = d.convert(t2)._mult(n2);
          return "viewport" === e2 && i2._rotate(-r3), i2;
        }
        Oi(Su, "CircleBucket", { omit: ["layers"] });
        const Uu = new Js({ "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"]) });
        var Ou = { paint: new Js({ "circle-radius": new Hs(Ht.paint_circle["circle-radius"]), "circle-color": new Hs(Ht.paint_circle["circle-color"]), "circle-blur": new Hs(Ht.paint_circle["circle-blur"]), "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]), "circle-translate": new Ys(Ht.paint_circle["circle-translate"]), "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"]) }), layout: Uu };
        function qu(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          if (s2 && t2.queryGeometry.isAboveHorizon) return false;
          s2 && (l2 *= t2.pixelToTileUnitsFactor);
          const u2 = t2.tileID.canonical, c2 = r3.projection.upVectorScale(u2, r3.center.lat, r3.worldSize).metersToTile;
          for (const h2 of e2) for (const e3 of h2) {
            const h3 = e3.add(o2), p2 = i2 && r3.elevation ? r3.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, f2 = r3.projection.projectTilePoint(h3.x, h3.y, u2);
            if (p2 > 0) {
              const t3 = r3.projection.upVector(u2, h3.x, h3.y);
              f2.x += t3[0] * c2 * p2, f2.y += t3[1] * c2 * p2, f2.z += t3[2] * c2 * p2;
            }
            const d2 = s2 ? h3 : Nu(f2.x, f2.y, f2.z, n2), y2 = s2 ? t2.tilespaceRays.map((t3) => Xu(t3, p2)) : t2.queryGeometry.screenGeometry, m2 = ul([], [f2.x, f2.y, f2.z, 1], n2);
            if (!a2 && s2 ? l2 *= m2[3] / r3.cameraToCenterDistance : a2 && !s2 && (l2 *= r3.cameraToCenterDistance / m2[3]), s2) {
              const t3 = lu((e3.y / ko + u2.y) / (1 << u2.z));
              l2 /= r3.projection.pixelsPerMeter(t3, 1) / au(1, t3);
            }
            if (Iu(y2, d2, l2)) return true;
          }
          return false;
        }
        function Nu(t2, e2, r3, n2) {
          const i2 = ul([], [t2, e2, r3, 1], n2);
          return new d(i2[0] / i2[3], i2[1] / i2[3]);
        }
        const Gu = No(0, 0, 0), Zu = No(0, 0, 1);
        function Xu(t2, e2) {
          const r3 = Uo();
          return Gu[2] = e2, t2.intersectsPlane(Gu, Zu, r3), new d(r3[0], r3[1]);
        }
        class Ku extends Su {
        }
        function Yu(t2, { width: e2, height: r3 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r3 * n2) throw new RangeError("mismatched image size");
          } else i2 = new Uint8Array(e2 * r3 * n2);
          return t2.width = e2, t2.height = r3, t2.data = i2, t2;
        }
        function Hu(t2, e2, r3) {
          const { width: n2, height: i2 } = e2;
          n2 === t2.width && i2 === t2.height || (Wu(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r3), t2.width = n2, t2.height = i2, t2.data = e2.data);
        }
        function Wu(t2, e2, r3, n2, i2, s2) {
          if (0 === i2.width || 0 === i2.height) return e2;
          if (i2.width > t2.width || i2.height > t2.height || r3.x > t2.width - i2.width || r3.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e2.data;
          for (let l2 = 0; l2 < i2.height; l2++) {
            const u2 = ((r3.y + l2) * t2.width + r3.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
            for (let t3 = 0; t3 < i2.width * s2; t3++) o2[c2 + t3] = a2[u2 + t3];
          }
          return e2;
        }
        Oi(Ku, "HeatmapBucket", { omit: ["layers"] });
        class Ju {
          constructor(t2, e2) {
            Yu(this, t2, 1, e2);
          }
          resize(t2) {
            Hu(this, new Ju(t2), 1);
          }
          clone() {
            return new Ju({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r3, n2, i2) {
            Wu(t2, e2, r3, n2, i2, 1);
          }
        }
        class Qu {
          constructor(t2, e2) {
            Yu(this, t2, 4, e2);
          }
          resize(t2) {
            Hu(this, new Qu(t2), 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Qu({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r3, n2, i2) {
            Wu(t2, e2, r3, n2, i2, 4);
          }
        }
        Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");
        var tc = { paint: new Js({ "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"]) }) };
        function ec(t2) {
          const e2 = {}, r3 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Qu({ width: r3, height: n2 }), s2 = (r4, n3, s3) => {
            e2[t2.evaluationKey] = s3;
            const a2 = t2.expression.evaluate(e2);
            i2.data[r4 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r4 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r4 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r4 + n3 + 3] = Math.floor(255 * a2.a);
          };
          if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r3) for (let n3 = 0, a2 = 0; n3 < r3; n3++, a2 += 4) {
            const o2 = n3 / (r3 - 1), { start: l2, end: u2 } = t2.clips[e3];
            s2(i3, a2, l2 * (1 - o2) + u2 * o2);
          }
          else for (let t3 = 0, e3 = 0; t3 < r3; t3++, e3 += 4) s2(0, e3, t3 / (r3 - 1));
          return i2;
        }
        var rc = { paint: new Js({ "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"]) }) };
        const nc = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ic } = nc;
        var sc = {};
        function ac(t2, e2, r3) {
          r3 = r3 || 2;
          var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r3 : t2.length, p2 = oc(t2, 0, h2, r3, true), f2 = [];
          if (!p2 || p2.next === p2.prev) return f2;
          if (c2 && (p2 = function(t3, e3, r4, n3) {
            var i3, s3, a3, o3 = [];
            for (i3 = 0, s3 = e3.length; i3 < s3; i3++) (a3 = oc(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(xc(a3));
            for (o3.sort(dc), i3 = 0; i3 < o3.length; i3++) r4 = yc(o3[i3], r4);
            return r4;
          }(t2, e2, p2, r3)), t2.length > 80 * r3) {
            n2 = s2 = t2[0], i2 = a2 = t2[1];
            for (var d2 = r3; d2 < h2; d2 += r3) (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
            u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 32767 / u2 : 0;
          }
          return uc(p2, f2, r3, n2, i2, u2, 0), f2;
        }
        function oc(t2, e2, r3, n2, i2) {
          var s2, a2;
          if (i2 === Ec(t2, e2, r3, n2) > 0) for (s2 = e2; s2 < r3; s2 += n2) a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
          else for (s2 = r3 - n2; s2 >= e2; s2 -= n2) a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
          return a2 && _c(a2, a2.next) && (zc(a2), a2 = a2.next), a2;
        }
        function lc(t2, e2) {
          if (!t2) return t2;
          e2 || (e2 = t2);
          var r3, n2 = t2;
          do {
            if (r3 = false, n2.steiner || !_c(n2, n2.next) && 0 !== wc(n2.prev, n2, n2.next)) n2 = n2.next;
            else {
              if (zc(n2), (n2 = e2 = n2.prev) === n2.next) break;
              r3 = true;
            }
          } while (r3 || n2 !== e2);
          return e2;
        }
        function uc(t2, e2, r3, n2, i2, s2, a2) {
          if (t2) {
            !a2 && s2 && function(t3, e3, r4, n3) {
              var i3 = t3;
              do {
                0 === i3.z && (i3.z = gc(i3.x, i3.y, e3, r4, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e4, r5, n4, i4, s3, a3, o3, l3, u3 = 1;
                do {
                  for (r5 = t4, t4 = null, s3 = null, a3 = 0; r5; ) {
                    for (a3++, n4 = r5, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++) ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; ) 0 !== o3 && (0 === l3 || !n4 || r5.z <= n4.z) ? (i4 = r5, r5 = r5.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                    r5 = n4;
                  }
                  s3.nextZ = null, u3 *= 2;
                } while (a3 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            for (var o2, l2, u2 = t2; t2.prev !== t2.next; ) if (o2 = t2.prev, l2 = t2.next, s2 ? hc(t2, n2, i2, s2) : cc(t2)) e2.push(o2.i / r3 | 0), e2.push(t2.i / r3 | 0), e2.push(l2.i / r3 | 0), zc(t2), t2 = l2.next, u2 = l2.next;
            else if ((t2 = l2) === u2) {
              a2 ? 1 === a2 ? uc(t2 = pc(lc(t2), e2, r3), e2, r3, n2, i2, s2, 2) : 2 === a2 && fc(t2, e2, r3, n2, i2, s2) : uc(lc(t2), e2, r3, n2, i2, s2, 1);
              break;
            }
          }
        }
        function cc(t2) {
          var e2 = t2.prev, r3 = t2, n2 = t2.next;
          if (wc(e2, r3, n2) >= 0) return false;
          for (var i2 = e2.x, s2 = r3.x, a2 = n2.x, o2 = e2.y, l2 = r3.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && vc(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && wc(d2.prev, d2, d2.next) >= 0) return false;
            d2 = d2.next;
          }
          return true;
        }
        function hc(t2, e2, r3, n2) {
          var i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (wc(i2, s2, a2) >= 0) return false;
          for (var o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = gc(f2, d2, e2, r3, n2), x2 = gc(y2, m2, e2, r3, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && vc(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && wc(v2.prev, v2, v2.next) >= 0) return false;
            if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && vc(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && wc(v2.prev, v2, v2.next) >= 0) return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function pc(t2, e2, r3) {
          var n2 = t2;
          do {
            var i2 = n2.prev, s2 = n2.next.next;
            !_c(i2, s2) && Ac(i2, n2, n2.next, s2) && Ic(i2, s2) && Ic(s2, i2) && (e2.push(i2.i / r3 | 0), e2.push(n2.i / r3 | 0), e2.push(s2.i / r3 | 0), zc(n2), zc(n2.next), n2 = t2 = s2), n2 = n2.next;
          } while (n2 !== t2);
          return lc(n2);
        }
        function fc(t2, e2, r3, n2, i2, s2) {
          var a2 = t2;
          do {
            for (var o2 = a2.next.next; o2 !== a2.prev; ) {
              if (a2.i !== o2.i && bc(a2, o2)) {
                var l2 = Mc(a2, o2);
                return a2 = lc(a2, a2.next), l2 = lc(l2, l2.next), uc(a2, e2, r3, n2, i2, s2, 0), void uc(l2, e2, r3, n2, i2, s2, 0);
              }
              o2 = o2.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function dc(t2, e2) {
          return t2.x - e2.x;
        }
        function yc(t2, e2) {
          var r3 = function(t3, e3) {
            var r4, n3 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
            do {
              if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i2 && o2 > a2 && (a2 = o2, r4 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2)) return r4;
              }
              n3 = n3.next;
            } while (n3 !== e3);
            if (!r4) return null;
            var l2, u2 = r4, c2 = r4.x, h2 = r4.y, p2 = 1 / 0;
            n3 = r4;
            do {
              i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && vc(s2 < h2 ? i2 : a2, s2, c2, h2, s2 < h2 ? a2 : i2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i2 - n3.x), Ic(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r4.x || n3.x === r4.x && mc(r4, n3))) && (r4 = n3, p2 = l2)), n3 = n3.next;
            } while (n3 !== u2);
            return r4;
          }(t2, e2);
          if (!r3) return e2;
          var n2 = Mc(r3, t2);
          return lc(n2, n2.next), lc(r3, r3.next);
        }
        function mc(t2, e2) {
          return wc(t2.prev, t2, e2.prev) < 0 && wc(e2.next, t2, t2.next) < 0;
        }
        function gc(t2, e2, r3, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r3) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function xc(t2) {
          var e2 = t2, r3 = t2;
          do {
            (e2.x < r3.x || e2.x === r3.x && e2.y < r3.y) && (r3 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r3;
        }
        function vc(t2, e2, r3, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r3 - a2) * (e2 - o2) && (r3 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
        }
        function bc(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            var r3 = t3;
            do {
              if (r3.i !== t3.i && r3.next.i !== t3.i && r3.i !== e3.i && r3.next.i !== e3.i && Ac(r3, r3.next, t3, e3)) return true;
              r3 = r3.next;
            } while (r3 !== t3);
            return false;
          }(t2, e2) && (Ic(t2, e2) && Ic(e2, t2) && function(t3, e3) {
            var r3 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
            do {
              r3.y > s2 != r3.next.y > s2 && r3.next.y !== r3.y && i2 < (r3.next.x - r3.x) * (s2 - r3.y) / (r3.next.y - r3.y) + r3.x && (n2 = !n2), r3 = r3.next;
            } while (r3 !== t3);
            return n2;
          }(t2, e2) && (wc(t2.prev, t2, e2.prev) || wc(t2, e2.prev, e2)) || _c(t2, e2) && wc(t2.prev, t2, t2.next) > 0 && wc(e2.prev, e2, e2.next) > 0);
        }
        function wc(t2, e2, r3) {
          return (e2.y - t2.y) * (r3.x - e2.x) - (e2.x - t2.x) * (r3.y - e2.y);
        }
        function _c(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function Ac(t2, e2, r3, n2) {
          var i2 = kc(wc(t2, e2, r3)), s2 = kc(wc(t2, e2, n2)), a2 = kc(wc(r3, n2, t2)), o2 = kc(wc(r3, n2, e2));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Sc(t2, r3, e2)) || !(0 !== s2 || !Sc(t2, n2, e2)) || !(0 !== a2 || !Sc(r3, t2, n2)) || !(0 !== o2 || !Sc(r3, e2, n2));
        }
        function Sc(t2, e2, r3) {
          return e2.x <= Math.max(t2.x, r3.x) && e2.x >= Math.min(t2.x, r3.x) && e2.y <= Math.max(t2.y, r3.y) && e2.y >= Math.min(t2.y, r3.y);
        }
        function kc(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function Ic(t2, e2) {
          return wc(t2.prev, t2, t2.next) < 0 ? wc(t2, e2, t2.next) >= 0 && wc(t2, t2.prev, e2) >= 0 : wc(t2, e2, t2.prev) < 0 || wc(t2, t2.next, e2) < 0;
        }
        function Mc(t2, e2) {
          var r3 = new Bc(t2.i, t2.x, t2.y), n2 = new Bc(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r3.next = i2, i2.prev = r3, n2.next = r3, r3.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function Tc(t2, e2, r3, n2) {
          var i2 = new Bc(t2, e2, r3);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function zc(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function Bc(t2, e2, r3) {
          this.i = t2, this.x = e2, this.y = r3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Ec(t2, e2, r3, n2) {
          for (var i2 = 0, s2 = e2, a2 = r3 - n2; s2 < r3; s2 += n2) i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
          return i2;
        }
        function Cc(t2, e2, r3, n2, i2) {
          Pc(t2, e2, r3 || 0, n2 || t2.length - 1, i2 || Vc);
        }
        function Pc(t2, e2, r3, n2, i2) {
          for (; n2 > r3; ) {
            if (n2 - r3 > 600) {
              var s2 = n2 - r3 + 1, a2 = e2 - r3 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
              Pc(t2, e2, Math.max(r3, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
            }
            var c2 = t2[e2], h2 = r3, p2 = n2;
            for (Dc(t2, r3, e2), i2(t2[n2], c2) > 0 && Dc(t2, r3, n2); h2 < p2; ) {
              for (Dc(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; ) h2++;
              for (; i2(t2[p2], c2) > 0; ) p2--;
            }
            0 === i2(t2[r3], c2) ? Dc(t2, r3, p2) : Dc(t2, ++p2, n2), p2 <= e2 && (r3 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
          }
        }
        function Dc(t2, e2, r3) {
          var n2 = t2[e2];
          t2[e2] = t2[r3], t2[r3] = n2;
        }
        function Vc(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Lc(t2, e2) {
          const r3 = t2.length;
          if (r3 <= 1) return [t2];
          const n2 = [];
          let i2, s2;
          for (let e3 = 0; e3 < r3; e3++) {
            const r4 = q(t2[e3]);
            0 !== r4 && (t2[e3].area = Math.abs(r4), void 0 === s2 && (s2 = r4 < 0), s2 === r4 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
          }
          if (i2 && n2.push(i2), e2 > 1) for (let t3 = 0; t3 < n2.length; t3++) n2[t3].length <= e2 || (Cc(n2[t3], e2, 1, n2[t3].length - 1, Fc), n2[t3] = n2[t3].slice(0, e2));
          return n2;
        }
        function Fc(t2, e2) {
          return e2.area - t2.area;
        }
        function Rc(t2, e2, r3) {
          const n2 = r3.patternDependencies;
          let i2 = false;
          for (const r4 of e2) {
            const e3 = r4.paint.get(`${t2}-pattern`);
            e3.isConstant() || (i2 = true);
            const s2 = e3.constantOr(null);
            s2 && (i2 = true, n2[s2] = true);
          }
          return i2;
        }
        function jc(t2, e2, r3, n2, i2) {
          const s2 = i2.patternDependencies;
          for (const a2 of e2) {
            const e3 = a2.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: n2 }, r3, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r3.patterns[a2.id] = t3;
            }
          }
          return r3;
        }
        ({ get exports() {
          return sc;
        }, set exports(t2) {
          sc = t2;
        } }).exports = ac, sc.default = ac, ac.deviation = function(t2, e2, r3, n2) {
          var i2 = e2 && e2.length, s2 = Math.abs(Ec(t2, 0, i2 ? e2[0] * r3 : t2.length, r3));
          if (i2) for (var a2 = 0, o2 = e2.length; a2 < o2; a2++) s2 -= Math.abs(Ec(t2, e2[a2] * r3, a2 < o2 - 1 ? e2[a2 + 1] * r3 : t2.length, r3));
          var l2 = 0;
          for (a2 = 0; a2 < n2.length; a2 += 3) {
            var u2 = n2[a2] * r3, c2 = n2[a2 + 1] * r3, h2 = n2[a2 + 2] * r3;
            l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
          }
          return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
        }, ac.flatten = function(t2) {
          for (var e2 = t2[0][0].length, r3 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var s2 = 0; s2 < t2[i2].length; s2++) for (var a2 = 0; a2 < e2; a2++) r3.vertices.push(t2[i2][s2][a2]);
            i2 > 0 && r3.holes.push(n2 += t2[i2 - 1].length);
          }
          return r3;
        };
        class $c {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.indexArray2 = new Ma(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.segments2 = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
          }
          populate(t2, e2, r3, n2) {
            this.hasPattern = Rc("fill", this.layers, e2);
            const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = wu(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), c2, r3)) continue;
              const h2 = i2 ? i2.evaluate(c2, {}, r3, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : bu(a2, r3, n2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = jc("fill", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r3, {}, e2.availableImages);
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3, n2);
          }
          addFeatures(t2, e2, r3, n2, i2) {
            for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e2, r3, n2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r3, n2, i2, s2 = []) {
            for (const t3 of Lc(e2, 500)) {
              let e3 = 0;
              for (const r5 of t3) e3 += r5.length;
              const r4 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r4.vertexLength, i3 = [], s3 = [];
              for (const e4 of t3) {
                if (0 === e4.length) continue;
                e4 !== t3[0] && s3.push(i3.length / 2);
                const r5 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r5.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                for (let t4 = 1; t4 < e4.length; t4++) this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                r5.vertexLength += e4.length, r5.primitiveLength += e4.length;
              }
              const a2 = sc(i3, s3);
              for (let t4 = 0; t4 < a2.length; t4 += 3) this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
              r4.vertexLength += e3, r4.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, s2, n2);
          }
        }
        Oi($c, "FillBucket", { omit: ["layers", "patternFeatures"] });
        const Uc = new Js({ "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"]) });
        var Oc = { paint: new Js({ "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]), "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]), "fill-color": new Hs(Ht.paint_fill["fill-color"]), "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]), "fill-translate": new Ys(Ht.paint_fill["fill-translate"]), "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]), "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"]) }), layout: Uc };
        const qc = na([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Nc = na([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Gc = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Zc } = qc;
        var Xc = {}, Kc = d, Yc = Hc;
        function Hc(t2, e2, r3, n2, i2) {
          this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Wc, this, e2);
        }
        function Wc(t2, e2, r3) {
          1 == t2 ? e2.id = r3.readVarint() : 2 == t2 ? function(t3, e3) {
            for (var r4 = t3.readVarint() + t3.pos; t3.pos < r4; ) {
              var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n2] = i2;
            }
          }(r3, e2) : 3 == t2 ? e2.type = r3.readVarint() : 4 == t2 && (e2._geometry = r3.pos);
        }
        function Jc(t2) {
          for (var e2, r3, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) n2 += ((r3 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r3.y);
          return n2;
        }
        Hc.types = ["Unknown", "Point", "LineString", "Polygon"], Hc.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r3 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r3; ) {
            if (i2 <= 0) {
              var l2 = t2.readVarint();
              n2 = 7 & l2, i2 = l2 >> 3;
            }
            if (i2--, 1 === n2 || 2 === n2) s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e2 && o2.push(e2), e2 = []), e2.push(new Kc(s2, a2));
            else {
              if (7 !== n2) throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, Hc.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r3 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
            if (n2 <= 0) {
              var c2 = t2.readVarint();
              r3 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, 1 === r3 || 2 === r3) (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
            else if (7 !== r3) throw new Error("unknown command " + r3);
          }
          return [a2, l2, o2, u2];
        }, Hc.prototype.toGeoJSON = function(t2, e2, r3) {
          var n2, i2, s2 = this.extent * Math.pow(2, r3), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = Hc.types[this.type];
          function c2(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r4 = t3[e3];
              t3[e3] = [360 * (r4.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o2) / s2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l2.length; n2++) h2[n2] = l2[n2][0];
              c2(l2 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++) c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1) return [t3];
                for (var r4, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                  var a3 = Jc(t3[s3]);
                  0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r4 && i3.push(r4), r4 = [t3[s3]]) : r4.push(t3[s3]));
                }
                return r4 && i3.push(r4), i3;
              }(l2), n2 = 0; n2 < l2.length; n2++) for (i2 = 0; i2 < l2[n2].length; i2++) c2(l2[n2][i2]);
          }
          1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var Qc = Yc, th = eh;
        function eh(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(rh, this, e2), this.length = this._features.length;
        }
        function rh(t2, e2, r3) {
          15 === t2 ? e2.version = r3.readVarint() : 1 === t2 ? e2.name = r3.readString() : 5 === t2 ? e2.extent = r3.readVarint() : 2 === t2 ? e2._features.push(r3.pos) : 3 === t2 ? e2._keys.push(r3.readString()) : 4 === t2 && e2._values.push(function(t3) {
            for (var e3 = null, r4 = t3.readVarint() + t3.pos; t3.pos < r4; ) {
              var n2 = t3.readVarint() >> 3;
              e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
            }
            return e3;
          }(r3));
        }
        eh.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new Qc(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var nh = th;
        function ih(t2, e2, r3) {
          if (3 === t2) {
            var n2 = new nh(r3, r3.readVarint() + r3.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        var sh = Xc.VectorTile = function(t2, e2) {
          this.layers = t2.readFields(ih, {}, e2);
        }, ah = Xc.VectorTileFeature = Yc;
        function oh(t2, e2, r3, n2) {
          const i2 = [], s2 = 0 === n2 ? (t3, e3, r4, n3, i3, s3) => {
            t3.push(new d(s3, r4 + (s3 - e3) / (n3 - e3) * (i3 - r4)));
          } : (t3, e3, r4, n3, i3, s3) => {
            t3.push(new d(e3 + (s3 - r4) / (i3 - r4) * (n3 - e3), s3));
          };
          for (const a2 of t2) {
            const t3 = [];
            for (const i3 of a2) {
              if (i3.length <= 2) continue;
              const a3 = [];
              for (let t4 = 0; t4 < i3.length - 1; t4++) {
                const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h2 = 0 === n2 ? o3 : l3, p2 = 0 === n2 ? u2 : c2;
                h2 < e2 ? p2 > e2 && s2(a3, o3, l3, u2, c2, e2) : h2 > r3 ? p2 < r3 && s2(a3, o3, l3, u2, c2, r3) : a3.push(i3[t4]), p2 < e2 && h2 >= e2 && s2(a3, o3, l3, u2, c2, e2), p2 > r3 && h2 <= r3 && s2(a3, o3, l3, u2, c2, r3);
              }
              let o2 = i3[i3.length - 1];
              const l2 = 0 === n2 ? o2.x : o2.y;
              l2 >= e2 && l2 <= r3 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
            }
            t3.length && i2.push(t3);
          }
          return i2;
        }
        Xc.VectorTileLayer = th;
        const lh = ah.types, uh = Math.pow(2, 13);
        function ch(t2, e2, r3, n2, i2, s2, a2, o2) {
          t2.emplaceBack((e2 << 1) + a2, (r3 << 1) + s2, (Math.floor(n2 * uh) << 1) + i2, Math.round(o2));
        }
        function hh(t2, e2, r3) {
          const n2 = 16384;
          t2.emplaceBack(e2.x, e2.y, e2.z, r3[0] * n2, r3[1] * n2, r3[2] * n2);
        }
        class ph {
          constructor() {
            this.acc = new d(0, 0), this.polyCount = [];
          }
          startRing(t2) {
            this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t2.x, t2.y), this.max = new d(t2.x, t2.y));
          }
          append(t2, e2) {
            this.currentPolyCount.edges++, this.acc._add(t2);
            const r3 = this.min, n2 = this.max;
            t2.x < r3.x ? r3.x = t2.x : t2.x > n2.x && (n2.x = t2.x), t2.y < r3.y ? r3.y = t2.y : t2.y > n2.y && (n2.y = t2.y), ((0 === t2.x || t2.x === ko) && t2.x === e2.x) != ((0 === t2.y || t2.y === ko) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, Mr(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > ko != t2.x > ko && this.addBorderIntersection(1, Mr(e2.y, t2.y, (ko - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, Mr(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > ko != t2.y > ko && this.addBorderIntersection(3, Mr(e2.x, t2.x, (ko - e2.y) / (t2.y - e2.y)));
          }
          addBorderIntersection(t2, e2) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r3 = this.borders[t2];
            e2 < r3[0] && (r3[0] = e2), e2 > r3[1] && (r3[1] = e2);
          }
          processBorderOverlap(t2, e2) {
            if (t2.x === e2.x) {
              if (t2.y === e2.y) return;
              const r3 = 0 === t2.x ? 0 : 1;
              this.addBorderIntersection(r3, e2.y), this.addBorderIntersection(r3, t2.y);
            } else {
              const r3 = 0 === t2.y ? 2 : 3;
              this.addBorderIntersection(r3, e2.x), this.addBorderIntersection(r3, t2.x);
            }
          }
          centroid() {
            const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
            return 0 !== t2 ? this.acc.div(t2)._round() : new d(0, 0);
          }
          span() {
            return new d(this.max.x - this.min.x, this.max.y - this.min.y);
          }
          intersectsCount() {
            return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
          }
        }
        class fh {
          constructor(t2) {
            this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.layoutVertexArray = new oa(), this.centroidVertexArray = new $a(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
          }
          populate(t2, e2, r3, n2) {
            this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t3) {
              const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
              return 80150034 * e3 / (e3 * e3 + 1) / ko / (1 << t3.z);
            }(r3), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
            for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, l2 = wu(i2, t3);
              if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), l2, r3)) continue;
              const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : bu(i2, r3, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u2, this.zoom, e2)) : this.addFeature(u2, u2.geometry, a2, r3, {}, e2.availableImages, n2), e2.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
            }
            this.sortBorders();
          }
          addFeatures(t2, e2, r3, n2, i2) {
            for (const t3 of this.features) {
              const { geometry: s2 } = t3;
              this.addFeature(t3, s2, t3.index, e2, r3, n2, i2);
            }
            this.sortBorders();
          }
          update(t2, e2, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3, n2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Zc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Gc.members, true))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          uploadCentroid(t2) {
            0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Nc.members, true), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = [new d(0, 0), new d(ko, ko)], l2 = a2.projection, u2 = "globe" === l2.name, c2 = this.enableTerrain && !u2 ? new ph() : null, h2 = "Polygon" === lh[t2.type];
            u2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa());
            const p2 = Lc(e2, 500);
            for (let t3 = p2.length - 1; t3 >= 0; t3--) {
              const e3 = p2[t3];
              (0 === e3.length || (f2 = e3[0]).every((t4) => t4.x <= 0) || f2.every((t4) => t4.x >= ko) || f2.every((t4) => t4.y <= 0) || f2.every((t4) => t4.y >= ko)) && p2.splice(t3, 1);
            }
            var f2;
            let y2;
            if (u2) y2 = wh(p2, o2, n2);
            else {
              y2 = [];
              for (const t3 of p2) y2.push({ polygon: t3, bounds: o2 });
            }
            const m2 = h2 ? this.edgeRadius : 0;
            for (const { polygon: t3, bounds: e3 } of y2) {
              let r4 = 0, i3 = 0;
              for (const e4 of t3) h2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += h2 ? e4.length - 1 : e4.length;
              const s3 = this.segments.prepareSegment((h2 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
              if (h2) {
                const e4 = [], i4 = [];
                r4 = s3.vertexLength;
                for (const r5 of t3) {
                  let a4, o3;
                  r5.length && r5 !== t3[0] && i4.push(e4.length / 2), a4 = r5[1].sub(r5[0])._perp()._unit();
                  for (let t4 = 1; t4 < r5.length; t4++) {
                    const i5 = r5[t4], c3 = r5[t4 === r5.length - 1 ? 1 : t4 + 1];
                    let { x: h3, y: p3 } = i5;
                    if (m2) {
                      o3 = c3.sub(i5)._perp()._unit();
                      const t5 = a4.add(o3)._unit(), e5 = m2 * Math.min(4, 1 / (a4.x * t5.x + a4.y * t5.y));
                      h3 += e5 * t5.x, p3 += e5 * t5.y, a4 = o3;
                    }
                    ch(this.layoutVertexArray, h3, p3, 0, 0, 1, 1, 0), s3.vertexLength++, e4.push(i5.x, i5.y), u2 && hh(this.layoutVertexExtArray, l2.projectTilePoint(h3, p3, n2), l2.upVector(n2, h3, p3));
                  }
                }
                const a3 = sc(e4, i4);
                for (let t4 = 0; t4 < a3.length; t4 += 3) this.indexArray.emplaceBack(r4 + a3[t4], r4 + a3[t4 + 2], r4 + a3[t4 + 1]), s3.primitiveLength++;
              }
              for (const i4 of t3) {
                c2 && i4.length && c2.startRing(i4[0]);
                let t4, a3, o3, p3 = i4.length > 4 && xh(i4[i4.length - 2], i4[0], i4[1]), f3 = m2 ? yh(i4[i4.length - 2], i4[0], i4[1], m2) : 0;
                a3 = i4[1].sub(i4[0])._perp()._unit();
                let d2 = true;
                for (let y3 = 1, g2 = 0; y3 < i4.length; y3++) {
                  let x2 = i4[y3 - 1], v2 = i4[y3];
                  const b2 = i4[y3 === i4.length - 1 ? 1 : y3 + 1];
                  if (c2 && h2 && c2.currentPolyCount.top++, gh(v2, x2, e3)) {
                    m2 && (a3 = b2.sub(v2)._perp()._unit(), d2 = !d2);
                    continue;
                  }
                  c2 && c2.append(v2, x2);
                  const w2 = v2.sub(x2)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x2.dist(v2);
                  if (g2 + S2 > 32768 && (g2 = 0), m2) {
                    o3 = b2.sub(v2)._perp()._unit();
                    let t5 = mh(x2, v2, b2, dh(a3, o3), m2);
                    isNaN(t5) && (t5 = 0);
                    const e4 = v2.sub(x2)._unit();
                    x2 = x2.add(e4.mult(f3))._round(), v2 = v2.add(e4.mult(-t5))._round(), f3 = t5, a3 = o3;
                  }
                  const k2 = s3.vertexLength, I2 = i4.length > 4 && xh(x2, v2, b2);
                  let M2 = vh(g2, p3, d2);
                  if (ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 1, M2), g2 += S2, M2 = vh(g2, I2, !d2), p3 = I2, ch(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 1, M2), s3.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s3.primitiveLength += 2, m2) {
                    const n3 = r4 + (1 === y3 ? i4.length - 2 : y3 - 2), a4 = 1 === y3 ? r4 : n3 + 1;
                    if (this.indexArray.emplaceBack(k2 + 1, n3, k2 + 3), this.indexArray.emplaceBack(n3, a4, k2 + 3), s3.primitiveLength += 2, void 0 === t4 && (t4 = k2), !gh(b2, i4[y3], e3)) {
                      const e4 = y3 === i4.length - 1 ? t4 : s3.vertexLength;
                      this.indexArray.emplaceBack(k2 + 2, k2 + 3, e4), this.indexArray.emplaceBack(k2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(k2 + 3, a4, e4 + 1), s3.primitiveLength += 3;
                    }
                    d2 = !d2;
                  }
                  if (u2) {
                    const t5 = this.layoutVertexExtArray, e4 = l2.projectTilePoint(x2.x, x2.y, n2), r5 = l2.projectTilePoint(v2.x, v2.y, n2), i5 = l2.upVector(n2, x2.x, x2.y), s4 = l2.upVector(n2, v2.x, v2.y);
                    hh(t5, e4, i5), hh(t5, e4, i5), hh(t5, r5, s4), hh(t5, r5, s4);
                  }
                }
                h2 && (r4 += i4.length - 1);
              }
            }
            if (c2 && c2.polyCount.length > 0) {
              if (c2.borders) {
                c2.vertexArrayOffset = this.centroidVertexArray.length;
                const t3 = c2.borders, e3 = this.featuresOnBorder.push(c2) - 1;
                for (let r4 = 0; r4 < 4; r4++) t3[r4][0] !== Number.MAX_VALUE && this.borders[r4].push(e3);
              }
              this.encodeCentroid(c2.borders ? void 0 : c2.centroid(), c2);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, s2, n2);
          }
          sortBorders() {
            for (let t2 = 0; t2 < 4; t2++) this.borders[t2].sort((e2, r3) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r3].borders[t2][0]);
          }
          encodeCentroid(t2, e2, r3 = true) {
            let n2, i2;
            if (t2) if (0 !== t2.y) {
              const r4 = e2.span()._mult(this.tileToMeter);
              n2 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r4.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r4.y / 10));
            } else n2 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
            else n2 = 0, i2 = +r3;
            let s2 = r3 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
            for (const t3 of e2.polyCount) {
              r3 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
              for (let e3 = 0; e3 < t3.top; e3++) this.centroidVertexArray.emplace(s2++, n2, i2);
              for (let e3 = 0; e3 < 2 * t3.edges; e3++) this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n2, i2);
            }
          }
        }
        function dh(t2, e2) {
          const r3 = t2.add(e2)._unit();
          return t2.x * r3.x + t2.y * r3.y;
        }
        function yh(t2, e2, r3, n2) {
          const i2 = e2.sub(t2)._perp()._unit(), s2 = r3.sub(e2)._perp()._unit();
          return mh(t2, e2, r3, dh(i2, s2), n2);
        }
        function mh(t2, e2, r3, n2, i2) {
          const s2 = Math.sqrt(1 - n2 * n2);
          return Math.min(t2.dist(e2) / 3, e2.dist(r3) / 3, i2 * s2 / n2);
        }
        function gh(t2, e2, r3) {
          return t2.x < r3[0].x && e2.x < r3[0].x || t2.x > r3[1].x && e2.x > r3[1].x || t2.y < r3[0].y && e2.y < r3[0].y || t2.y > r3[1].y && e2.y > r3[1].y;
        }
        function xh(t2, e2, r3) {
          if (t2.x < 0 || t2.x >= ko || e2.x < 0 || e2.x >= ko || r3.x < 0 || r3.x >= ko) return false;
          const n2 = r3.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
          return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
        }
        function vh(t2, e2, r3) {
          const n2 = e2 ? 2 | t2 : -3 & t2;
          return r3 ? 1 | n2 : -2 & n2;
        }
        function bh() {
          const t2 = Math.PI / 32, e2 = Math.tan(t2), r3 = tu;
          return r3 * Math.sqrt(1 + 2 * e2 * e2) - r3;
        }
        function wh(t2, e2, r3) {
          const n2 = 1 << r3.z, i2 = ou(r3.x / n2), s2 = ou((r3.x + 1) / n2), a2 = lu(r3.y / n2), o2 = lu((r3.y + 1) / n2);
          return function(t3, e3, r4, n3, i3 = 0, s3) {
            const a3 = [];
            if (!t3.length || !r4 || !n3) return a3;
            const o3 = (t4, e4) => {
              for (const r5 of t4) a3.push({ polygon: r5, bounds: e4 });
            }, l2 = Math.ceil(Math.log2(r4)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h2 = [];
            for (let t4 = 0; t4 < Math.abs(c2); t4++) h2.push(c2 > 0 ? 0 : 1);
            for (let t4 = 0; t4 < Math.min(l2, u2); t4++) h2.push(0), h2.push(1);
            let p2 = t3;
            if (p2 = oh(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = oh(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length) return a3;
            const f2 = [];
            for (h2.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); f2.length; ) {
              const t4 = f2.pop(), e4 = t4.depth, r5 = h2[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r5 ? n4.x : n4.y, u3 = 0 === r5 ? a4.x : a4.y, c3 = s3 ? s3(r5, l3, u3) : 0.5 * (l3 + u3), p3 = oh(t4.polygons, l3 - i3, c3 + i3, r5), y2 = oh(t4.polygons, c3 - i3, u3 + i3, r5);
              if (p3.length) {
                const t5 = [n4, new d(0 === r5 ? c3 : a4.x, 1 === r5 ? c3 : a4.y)];
                h2.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
              }
              if (y2.length) {
                const t5 = [new d(0 === r5 ? c3 : n4.x, 1 === r5 ? c3 : n4.y), a4];
                h2.length > e4 + 1 ? f2.push({ polygons: y2, bounds: t5, depth: e4 + 1 }) : o3(y2, t5);
              }
            }
            return a3;
          }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
            if (0 === t3) return 0.5 * (e3 + i3);
            {
              const t4 = lu((r3.y + e3 / ko) / n2);
              return (su(0.5 * (lu((r3.y + i3 / ko) / n2) + t4)) * n2 - r3.y) * ko;
            }
          });
        }
        Oi(fh, "FillExtrusionBucket", { omit: ["layers", "features"] }), Oi(ph, "PartMetadata");
        const _h = new Js({ "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
        var Ah = { paint: new Js({ "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: _h };
        function Sh(t2, e2, r3) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class kh {
          constructor(t2, e2, r3) {
            this.z = t2, this.x = e2, this.y = r3, this.key = Th(0, t2, t2, e2, r3);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2) {
            const r3 = function(t3, e3, r4) {
              var n3 = Sh(256 * t3, 256 * (e3 = Math.pow(2, r4) - e3 - 1), r4), i2 = Sh(256 * (t3 + 1), 256 * (e3 + 1), r4);
              return n3[0] + "," + n3[1] + "," + i2[0] + "," + i2[1];
            }(this.x, this.y, this.z), n2 = function(t3, e3, r4) {
              let n3, i2 = "";
              for (let s2 = t3; s2 > 0; s2--) n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r4 & n3 ? 2 : 0);
              return i2;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r3);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Ih {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = Th(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class Mh {
          constructor(t2, e2, r3, n2, i2) {
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new kh(r3, +n2, +i2), this.key = 0 === e2 && t2 === r3 ? this.canonical.key : Th(e2, t2, r3, n2, i2);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new Mh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2 = true) {
            if (this.overscaledZ === t2 && e2) return this.key;
            if (t2 > this.canonical.z) return Th(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r3 = this.canonical.z - t2;
              return Th(this.wrap * +e2, t2, t2, this.canonical.x >> r3, this.canonical.y >> r3);
            }
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap) return false;
            const e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2) return [new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new Mh(e2, this.wrap, e2, r3, n2), new Mh(e2, this.wrap, e2, r3 + 1, n2), new Mh(e2, this.wrap, e2, r3, n2 + 1), new Mh(e2, this.wrap, e2, r3 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new Mh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Ih(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function Th(t2, e2, r3, n2, i2) {
          const s2 = 1 << Math.min(r3, 22);
          let a2 = s2 * (i2 % s2) + n2 % s2;
          return t2 && r3 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r3)))), 16 * (32 * a2 + r3) + (e2 - r3);
        }
        Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", { omit: ["projMatrix"] });
        class zh extends d {
          constructor(t2, e2, r3) {
            super(t2, e2), this.z = r3;
          }
        }
        function Bh(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function Eh(t2, e2) {
          if (1 === t2.length) {
            let r3 = 0;
            const n2 = e2[r3++];
            let i2;
            for (; !i2 || n2.equals(i2); ) if (i2 = e2[r3++], !i2) return 1 / 0;
            for (; r3 < e2.length; r3++) {
              const s2 = e2[r3], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Bh(o2, o2), h2 = Bh(o2, l2), p2 = Bh(l2, l2), f2 = Bh(u2, o2), d2 = Bh(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
              if (isFinite(x2)) return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r3 of e2) t3 = Math.min(t3, r3.z);
            return t3;
          }
        }
        function Ch(t2, e2, r3, n2, i2, s2, a2, o2) {
          const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r4) {
            const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r4), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r5, n4, i4) {
              return [t4.getElevationAtPixel(e4, r5, true), t4.getElevationAtPixel(e4 + i4, r5, true), t4.getElevationAtPixel(e4, r5 + i4, true), t4.getElevationAtPixel(e4 + n4, r5 + i4, true)];
            }(t3, h2.x - u3, h2.y - c3, p2, f2), y2 = Math.abs(d2[0] - d2[1]), m2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (y2 + m2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / f2);
            return o3 + Math.max(x2 * s3, v2 * a3);
          }(i2, s2, o2) : l2;
          return { base: l2 + (0 === r3) ? -1 : r3, top: u2 ? Math.max(c2 + n2, l2 + r3 + 2) : l2 + n2 };
        }
        const Ph = na([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: Dh } = Ph, Vh = na([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Lh } = Vh, Fh = ah.types, Rh = Math.cos(Math.PI / 180 * 37.5);
        class jh {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r3, n2) {
            this.hasPattern = Rc("line", this.layers, e2);
            const i2 = this.layers[0].layout.get("line-sort-key"), s2 = [];
            for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new $s(this.zoom), u2, r3)) continue;
              const c2 = i2 ? i2.evaluate(u2, {}, r3) : void 0, h2 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : bu(e3, r3, n2), patterns: {}, sortKey: c2 };
              s2.push(h2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            const { lineAtlas: a2, featureIndex: o2 } = e2, l2 = this.addConstantDashes(a2);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: u2 } = n3;
              if (l2 && this.addFeatureDashes(n3, a2), this.hasPattern) {
                const t3 = jc("line", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r3, a2.positions, e2.availableImages);
              o2.insert(t2[s3].feature, i3, s3, u2, this.index);
            }
          }
          addConstantDashes(t2) {
            let e2 = false;
            for (const r3 of this.layers) {
              const n2 = r3.paint.get("line-dasharray").value, i2 = r3.layout.get("line-cap").value;
              if ("constant" !== n2.kind || "constant" !== i2.kind) e2 = true;
              else {
                const e3 = i2.value, r4 = n2.value;
                if (!r4) continue;
                t2.addDash(r4, e3);
              }
            }
            return e2;
          }
          addFeatureDashes(t2, e2) {
            const r3 = this.zoom;
            for (const n2 of this.layers) {
              const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
              if ("constant" === i2.kind && "constant" === s2.kind) continue;
              let a2, o2;
              if ("constant" === i2.kind) {
                if (a2 = i2.value, !a2) continue;
              } else a2 = i2.evaluate({ zoom: r3 }, t2);
              o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r3 }, t2), e2.addDash(a2, o2), t2.patterns[n2.id] = e2.getKey(a2, o2);
            }
          }
          update(t2, e2, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r3, n2);
          }
          addFeatures(t2, e2, r3, n2, i2) {
            for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e2, r3, n2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r3, n2, i2, s2) {
            const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l2 = a2.get("line-cap").evaluate(t2, {}), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r4 of e2) this.addLine(r4, t2, o2, l2, u2, c2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r3, i2, s2, n2);
          }
          addLine(t2, e2, r3, n2, i2, s2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++) this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = "Polygon" === Fh[e2.type];
            let o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); ) o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); ) l2++;
            if (o2 < (a2 ? 3 : 2)) return;
            "bevel" === r3 && (i2 = 1.05);
            const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h2, p2, f2, d2, y2;
            this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
            for (let e3 = l2; e3 < o2; e3++) {
              if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2)) continue;
              y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
              let m2 = d2.add(y2);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rh && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
              if (w2 && e3 > l2) {
                const t3 = h2.dist(p2);
                if (t3 > 2 * u2) {
                  const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                  this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                }
              }
              const A2 = p2 && f2;
              let S2 = A2 ? r3 : a2 ? "butt" : n2;
              if (A2 && "round" === S2 && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i2 && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === S2) m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("flipbevel" === S2) {
                if (v2 > 100) m2 = y2.mult(-1);
                else {
                  const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                  m2._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r4 = _2 ? 0 : t3;
                if (p2 && this.addCurrentVertex(h2, d2, e4, r4, c2), "fakeround" === S2) {
                  const t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r5 = e5 / t4;
                    if (0.5 !== r5) {
                      const t5 = r5 - 0.5;
                      r5 += r5 * t5 * (r5 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y2.sub(d2)._mult(r5)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y2, -e4, -r4, c2);
              } else if ("butt" === S2) this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("square" === S2) {
                const t3 = p2 ? 1 : -1;
                p2 || this.addCurrentVertex(h2, m2, t3, t3, c2), this.addCurrentVertex(h2, m2, 0, 0, c2), p2 && this.addCurrentVertex(h2, m2, t3, t3, c2);
              } else "round" === S2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
              if (w2 && e3 < o2 - 1) {
                const t3 = h2.dist(f2);
                if (t3 > 2 * u2) {
                  const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                  this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r3, n2, i2, s2 = false) {
            const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r3, e2.y - e2.x * r3, s2, false, r3, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
          }
          addHalfVertex({ x: t2, y: e2 }, r3, n2, i2, s2, a2, o2) {
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
            const l2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
            } else this.lineSoFar = this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        Oi(jh, "LineBucket", { omit: ["layers", "patternFeatures"] });
        const $h = new Js({ "line-cap": new Hs(Ht.layout_line["line-cap"]), "line-join": new Hs(Ht.layout_line["line-join"]), "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]), "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]), "line-sort-key": new Hs(Ht.layout_line["line-sort-key"]) });
        var Uh = { paint: new Js({ "line-opacity": new Hs(Ht.paint_line["line-opacity"]), "line-color": new Hs(Ht.paint_line["line-color"]), "line-translate": new Ys(Ht.paint_line["line-translate"]), "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]), "line-width": new Hs(Ht.paint_line["line-width"]), "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]), "line-offset": new Hs(Ht.paint_line["line-offset"]), "line-blur": new Hs(Ht.paint_line["line-blur"]), "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]), "line-pattern": new Hs(Ht.paint_line["line-pattern"]), "line-gradient": new Ws(Ht.paint_line["line-gradient"]), "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"]) }), layout: $h };
        const Oh = new class extends Hs {
          possiblyEvaluate(t2, e2) {
            return e2 = new $s(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r3, n2) {
            return e2 = z({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r3, n2);
          }
        }(Uh.paint.properties["line-width"].specification);
        function qh(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        Oh.useIntegerZoom = true;
        const Nh = na([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Gh = na([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Zh = na([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        na([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Xh = na([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Kh = na([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
        na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Yh = na([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Hh = na([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        na([{ name: "triangle", components: 3, type: "Uint16" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), na([{ type: "Float32", name: "offsetX" }]), na([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var Wh = 24;
        const Jh = 128;
        function Qh(t2, e2) {
          const { expression: r3 } = e2;
          if ("constant" === r3.kind) return { kind: "constant", layoutSize: r3.evaluate(new $s(t2 + 1)) };
          if ("source" === r3.kind) return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n2 } = r3;
            let i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; ) i2++;
            i2 = Math.max(0, i2 - 1);
            let s2 = i2;
            for (; s2 < e3.length && e3[s2] < t2 + 1; ) s2++;
            s2 = Math.min(e3.length - 1, s2);
            const a2 = e3[i2], o2 = e3[s2];
            return "composite" === r3.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r3.evaluate(new $s(a2)), maxSize: r3.evaluate(new $s(o2)), interpolationType: n2 };
          }
        }
        function tp(t2, { uSize: e2, uSizeT: r3 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / Jh : "composite" === t2.kind ? Mr(n2 / Jh, i2 / Jh, r3) : e2;
        }
        function ep(t2, e2) {
          let r3 = 0, n2 = 0;
          if ("constant" === t2.kind) n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? S(Kr.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = Mr(t2.minSize, t2.maxSize, o2) : r3 = o2;
          }
          return { uSizeT: r3, uSize: n2 };
        }
        var rp = Object.freeze({ __proto__: null, getSizeData: Qh, evaluateSizeForFeature: tp, evaluateSizeForZoom: ep, SIZE_PACK_FACTOR: Jh });
        function np(t2, e2, r3) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r4) {
              const n2 = e3.layout.get("text-transform").evaluate(r4, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), js.applyArabicShaping && (t4 = js.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r3);
          }), t2;
        }
        const ip = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
        function sp(t2) {
          return "\uFE36" === t2 || "\uFE48" === t2 || "\uFE38" === t2 || "\uFE44" === t2 || "\uFE42" === t2 || "\uFE3E" === t2 || "\uFE3C" === t2 || "\uFE3A" === t2 || "\uFE18" === t2 || "\uFE40" === t2 || "\uFE10" === t2 || "\uFE13" === t2 || "\uFE14" === t2 || "\uFF40" === t2 || "\uFFE3" === t2 || "\uFE11" === t2 || "\uFE12" === t2;
        }
        function ap(t2) {
          return "\uFE35" === t2 || "\uFE47" === t2 || "\uFE37" === t2 || "\uFE43" === t2 || "\uFE41" === t2 || "\uFE3D" === t2 || "\uFE3B" === t2 || "\uFE39" === t2 || "\uFE17" === t2 || "\uFE3F" === t2;
        }
        var op = cp, lp = function(t2, e2, r3, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r3 ? i2 - 1 : 0, p2 = r3 ? -1 : 1, f2 = t2[e2 + h2];
          for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
          if (0 === s2) s2 = 1 - u2;
          else {
            if (s2 === l2) return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        }, up = function(t2, e2, r3, n2, i2, s2) {
          var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r3 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8) ;
          for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r3 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8) ;
          t2[r3 + f2 - d2] |= 128 * y2;
        };
        function cp(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;
        var hp = 4294967296, pp = 1 / hp, fp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function dp(t2) {
          return t2.type === cp.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function yp(t2, e2, r3) {
          return r3 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function mp(t2, e2, r3) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r3.realloc(n2);
          for (var i2 = r3.pos - 1; i2 >= t2; i2--) r3.buf[i2 + n2] = r3.buf[i2];
        }
        function gp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeVarint(t2[r3]);
        }
        function xp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeSVarint(t2[r3]);
        }
        function vp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeFloat(t2[r3]);
        }
        function bp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeDouble(t2[r3]);
        }
        function wp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeBoolean(t2[r3]);
        }
        function _p(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeFixed32(t2[r3]);
        }
        function Ap(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeSFixed32(t2[r3]);
        }
        function Sp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeFixed64(t2[r3]);
        }
        function kp(t2, e2) {
          for (var r3 = 0; r3 < t2.length; r3++) e2.writeSFixed64(t2[r3]);
        }
        function Ip(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function Mp(t2, e2, r3) {
          t2[r3] = e2, t2[r3 + 1] = e2 >>> 8, t2[r3 + 2] = e2 >>> 16, t2[r3 + 3] = e2 >>> 24;
        }
        function Tp(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        function zp(t2, e2, r3) {
          e2.glyphs = [], 1 === t2 && r3.readMessage(Bp, e2);
        }
        function Bp(t2, e2, r3) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r3.readMessage(Ep, {});
            e2.glyphs.push({ id: t3, bitmap: new Ju({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
          } else 4 === t2 ? e2.ascender = r3.readSVarint() : 5 === t2 && (e2.descender = r3.readSVarint());
        }
        function Ep(t2, e2, r3) {
          1 === t2 ? e2.id = r3.readVarint() : 2 === t2 ? e2.bitmap = r3.readBytes() : 3 === t2 ? e2.width = r3.readVarint() : 4 === t2 ? e2.height = r3.readVarint() : 5 === t2 ? e2.left = r3.readSVarint() : 6 === t2 ? e2.top = r3.readSVarint() : 7 === t2 && (e2.advance = r3.readVarint());
        }
        function Cp(t2) {
          let e2 = 0, r3 = 0;
          for (const n3 of t2) e2 += n3.w * n3.h, r3 = Math.max(r3, n3.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r3), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r4 = n2[t3];
            if (!(e3.w > r4.w || e3.h > r4.h)) {
              if (e3.x = r4.x, e3.y = r4.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r4.w && e3.h === r4.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else e3.h === r4.h ? (r4.x += e3.w, r4.w -= e3.w) : e3.w === r4.w ? (r4.y += e3.h, r4.h -= e3.h) : (n2.push({ x: r4.x + e3.w, y: r4.y, w: r4.w - e3.w, h: e3.h }), r4.y += e3.h, r4.h -= e3.h);
              break;
            }
          }
          return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
        }
        cp.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = Ip(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Tp(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = lp(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = lp(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r3, n2 = this.buf;
          return e2 = 127 & (r3 = n2[this.pos++]), r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 7, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 14, r3 < 128 ? e2 : (e2 |= (127 & (r3 = n2[this.pos++])) << 21, r3 < 128 ? e2 : function(t3, e3, r4) {
            var n3, i2, s2 = r4.buf;
            if (n3 = (112 & (i2 = s2[r4.pos++])) >> 4, i2 < 128) return yp(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r4.pos++])) << 3, i2 < 128) return yp(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r4.pos++])) << 10, i2 < 128) return yp(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r4.pos++])) << 17, i2 < 128) return yp(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r4.pos++])) << 24, i2 < 128) return yp(t3, n3, e3);
            if (n3 |= (1 & (i2 = s2[r4.pos++])) << 31, i2 < 128) return yp(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r3 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && fp ? function(t3, e3, r3) {
            return fp.decode(t3.subarray(e3, r3));
          }(this.buf, e2, t2) : function(t3, e3, r3) {
            for (var n2 = "", i2 = e3; i2 < r3; ) {
              var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + c2 > r3) break;
              1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== cp.Bytes) return t2.push(this.readVarint(e2));
          var r3 = dp(this);
          for (t2 = t2 || []; this.pos < r3; ) t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readSVarint());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readBoolean());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readFloat());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readDouble());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readFixed32());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readSFixed32());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readFixed64());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== cp.Bytes) return t2.push(this.readSFixed64());
          var e2 = dp(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === cp.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (e2 === cp.Bytes) this.pos = this.readVarint() + this.pos;
          else if (e2 === cp.Fixed32) this.pos += 4;
          else {
            if (e2 !== cp.Fixed64) throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; ) e2 *= 2;
          if (e2 !== this.length) {
            var r3 = new Uint8Array(e2);
            r3.set(this.buf), this.buf = r3, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r3, n2;
            if (t3 >= 0 ? (r3 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r3 = ~(-t3 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r4) {
              r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, t4 >>>= 7, r4.buf[r4.pos++] = 127 & t4 | 128, r4.buf[r4.pos] = 127 & (t4 >>>= 7);
            }(r3, 0, e2), function(t4, e3) {
              var r4 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r4 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r4) {
            for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
              if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || s2 + 1 === e3.length ? (t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else i2 && (t3[r4++] = 239, t3[r4++] = 191, t3[r4++] = 189, i2 = null);
              n2 < 128 ? t3[r4++] = n2 : (n2 < 2048 ? t3[r4++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r4++] = n2 >> 12 | 224 : (t3[r4++] = n2 >> 18 | 240, t3[r4++] = n2 >> 12 & 63 | 128), t3[r4++] = n2 >> 6 & 63 | 128), t3[r4++] = 63 & n2 | 128);
            }
            return r4;
          }(this.buf, t2, this.pos);
          var r3 = this.pos - e2;
          r3 >= 128 && mp(e2, r3, this), this.pos = e2 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(t2) {
          this.realloc(4), up(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), up(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r3 = 0; r3 < e2; r3++) this.buf[this.pos++] = t2[r3];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r3 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r3;
          n2 >= 128 && mp(r3, n2, this), this.pos = r3 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e2, r3) {
          this.writeTag(t2, cp.Bytes), this.writeRawMessage(e2, r3);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, gp, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, xp, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, wp, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, vp, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, bp, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, _p, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ap, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Sp, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, kp, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, cp.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, cp.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, cp.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, cp.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, cp.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, cp.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, cp.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, cp.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, cp.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, cp.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        class Pp {
          constructor(t2, { pixelRatio: e2, version: r3, stretchX: n2, stretchY: i2, content: s2 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r3;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Dp {
          constructor(t2, e2) {
            const r3 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r3, i2), this.addImages(e2, n2, i2);
            const { w: s2, h: a2 } = Cp(i2), o2 = new Qu({ width: s2 || 1, height: a2 || 1 });
            for (const e3 in t2) {
              const n3 = t2[e3], i3 = r3[e3].paddedRect;
              Qu.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
            }
            for (const t3 in e2) {
              const r4 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r4.data.width, u2 = r4.data.height;
              Qu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r4.data), Qu.copy(r4.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Qu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Qu.copy(r4.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Qu.copy(r4.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r3, this.patternPositions = n2;
          }
          addImages(t2, e2, r3) {
            for (const n2 in t2) {
              const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
              r3.push(s2), e2[n2] = new Pp(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e2) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r3 in t2.updatedImages) this.patchUpdatedImage(this.iconPositions[r3], t2.getImage(r3), e2), this.patchUpdatedImage(this.patternPositions[r3], t2.getImage(r3), e2);
          }
          patchUpdatedImage(t2, e2, r3) {
            if (!t2 || !e2) return;
            if (t2.version === e2.version) return;
            t2.version = e2.version;
            const [n2, i2] = t2.tl;
            r3.update(e2.data, void 0, { x: n2, y: i2 });
          }
        }
        Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");
        const Vp = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Lp {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e2) {
            const r3 = new Lp();
            return r3.scale = t2 || 1, r3.fontStack = e2, r3;
          }
          static forImage(t2) {
            const e2 = new Lp();
            return e2.imageName = t2, e2;
          }
        }
        class Fp {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            const r3 = new Fp();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              const i2 = t2.sections[n2];
              i2.image ? r3.addImageSection(i2) : r3.addTextSection(i2, e2);
            }
            return r3;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation(t2) {
            this.text = function(t3, e2) {
              let r3 = "";
              for (let n2 = 0; n2 < t3.length; n2++) {
                const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                r3 += !e2 && (i2 && Ss(i2) && !ip[t3[n2 + 1]] || s2 && Ss(s2) && !ip[t3[n2 - 1]]) || !ip[t3[n2]] ? t3[n2] : ip[t3[n2]];
              }
              return r3;
            }(this.text, t2);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && jp[this.text.charCodeAt(e3)]; e3++) t2++;
            let e2 = this.text.length;
            for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t2 && jp[this.text.charCodeAt(r3)]; r3--) e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            const r3 = new Fp();
            return r3.text = this.text.substring(t2, e2), r3.sectionIndex = this.sectionIndex.slice(t2, e2), r3.sections = this.sections, r3;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(Lp.forText(t2.scale, t2.fontStack || e2));
            const r3 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3) this.sectionIndex.push(r3);
          }
          addImageSection(t2) {
            const e2 = t2.image ? t2.image.name : "";
            if (0 === e2.length) return void U("Can't add FormattedSection with an empty image.");
            const r3 = this.getNextImageSectionCharCode();
            r3 ? (this.text += String.fromCharCode(r3), this.sections.push(Lp.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : U("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Rp(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2) {
          const y2 = Fp.fromFeature(t2, i2);
          h2 === Vp.vertical && y2.verticalizePunctuation(p2);
          let m2 = [];
          const g2 = function(t3, e3, r4, n3, i3, s3) {
            if (!t3) return [];
            const a3 = [], o3 = function(t4, e4, r5, n4, i4, s4) {
              let a4 = 0;
              for (let r6 = 0; r6 < t4.length(); r6++) {
                const o4 = t4.getSection(r6);
                a4 += Up(t4.getCharCode(r6), o4, n4, i4, e4, s4);
              }
              return a4 / Math.max(1, Math.ceil(a4 / r5));
            }(t3, e3, r4, n3, i3, s3), l3 = t3.text.indexOf("\u200B") >= 0;
            let u3 = 0;
            for (let r5 = 0; r5 < t3.length(); r5++) {
              const h3 = t3.getSection(r5), p3 = t3.getCharCode(r5);
              if (jp[p3] || (u3 += Up(p3, h3, n3, i3, e3, s3)), r5 < t3.length() - 1) {
                const e4 = !((c3 = p3) < 11904 || !(ns(c3) || rs(c3) || ms(c3) || fs(c3) || os(c3) || Hi(c3) || is(c3) || Qi(c3) || ls(c3) || us(c3) || as(c3) || vs(c3) || ts(c3) || Ji(c3) || Wi(c3) || ss(c3) || es(c3) || ys(c3) || hs(c3) || cs(c3)));
                ($p[p3] || e4 || h3.imageName) && a3.push(Np(r5 + 1, u3, o3, a3, qp(p3, t3.getCharCode(r5 + 1), e4 && l3), false));
              }
            }
            var c3;
            return Gp(Np(t3.length(), u3, o3, a3, 0, true));
          }(y2, u2, s2, e2, n2, f2), { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = js;
          if (x2 && 1 === y2.sections.length) {
            const t3 = x2(y2.toString(), g2);
            for (const e3 of t3) {
              const t4 = new Fp();
              t4.text = e3, t4.sections = y2.sections;
              for (let r4 = 0; r4 < e3.length; r4++) t4.sectionIndex.push(0);
              m2.push(t4);
            }
          } else if (v2) {
            const t3 = v2(y2.text, y2.sectionIndex, g2);
            for (const e3 of t3) {
              const t4 = new Fp();
              t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, m2.push(t4);
            }
          } else m2 = function(t3, e3) {
            const r4 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3) r4.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r4.push(t3.substring(i3, n3.length)), r4;
          }(y2, g2);
          const b2 = [], w2 = { positionedLines: b2, text: y2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t3, e3, r4, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
            let p3 = 0, f3 = 0, d3 = 0;
            const y3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
            let m3 = false;
            for (const t4 of i3) {
              const r5 = t4.getSections();
              for (const t5 of r5) {
                if (t5.imageName) continue;
                const r6 = e3[t5.fontStack];
                if (r6 && (m3 = void 0 !== r6.ascender && void 0 !== r6.descender, !m3)) break;
              }
              if (!m3) break;
            }
            let g3 = 0;
            for (const a4 of i3) {
              a4.trim();
              const i4 = a4.getMaxScale(), o4 = (i4 - 1) * Wh, v4 = { positionedGlyphs: [], lineOffset: 0 };
              t3.positionedLines[g3] = v4;
              const b4 = v4.positionedGlyphs;
              let w4 = 0;
              if (!a4.length()) {
                f3 += s3, ++g3;
                continue;
              }
              let _2 = 0, A2 = 0;
              for (let s4 = 0; s4 < a4.length(); s4++) {
                const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4);
                let g4 = o5.scale, v5 = null, S3 = null, k2 = null, I2 = Wh, M2 = 0;
                const T2 = !(l3 === Vp.horizontal || !c3 && !As(y4) || c3 && (jp[y4] || (x3 = y4, Xi(x3) || Ki(x3) || Yi(x3) || ds(x3) || xs(x3))));
                if (o5.imageName) {
                  const e4 = n3[o5.imageName];
                  if (!e4) continue;
                  k2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, S3 = e4.paddedRect;
                  const r5 = e4.displaySize;
                  g4 = g4 * Wh / h3, v5 = { width: r5[0], height: r5[1], left: 1, top: -3, advance: T2 ? r5[1] : r5[0], localGlyph: false }, M2 = m3 ? -v5.height * g4 : i4 * Wh - 17 - r5[1] * g4, I2 = v5.advance;
                  const s5 = (T2 ? r5[0] : r5[1]) * g4 - Wh * i4;
                  s5 > 0 && s5 > w4 && (w4 = s5);
                } else {
                  const t4 = r4[o5.fontStack];
                  if (!t4) continue;
                  t4[y4] && (S3 = t4[y4]);
                  const n4 = e3[o5.fontStack];
                  if (!n4) continue;
                  const s5 = n4.glyphs[y4];
                  if (!s5) continue;
                  if (v5 = s5.metrics, I2 = 8203 !== y4 ? Wh : 0, m3) {
                    const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r5 = (t5 + e4) * g4;
                    _2 < r5 && (_2 = r5, A2 = (t5 - e4) / 2 * g4), M2 = -t5 * g4;
                  } else M2 = (i4 - g4) * Wh - 17;
                }
                T2 ? (t3.verticalizable = true, b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: S3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: S3 }), p3 += v5.advance * g4 + u3);
              }
              0 !== b4.length && (d3 = Math.max(p3 - u3, d3), m3 ? Xp(b4, y3, w4, A2, s3 * i4 / 2) : Xp(b4, y3, w4, 0, s3 / 2)), p3 = 0;
              const S2 = s3 * i4 + w4;
              v4.lineOffset = Math.max(w4, o4), f3 += S2, ++g3;
            }
            var x3;
            const v3 = f3, { horizontalAlign: b3, verticalAlign: w3 } = Zp(a3);
            (function(t4, e4, r5, n4, i4, s4) {
              const a4 = (e4 - r5) * i4, o4 = -s4 * n4;
              for (const e5 of t4) for (const t5 of e5.positionedGlyphs) t5.x += a4, t5.y += o4;
            })(t3.positionedLines, y3, b3, w3, d3, v3), t3.top += -w3 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = m3;
          }(w2, e2, r3, n2, m2, a2, o2, l2, h2, u2, p2, d2), !function(t3) {
            for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
            return true;
          }(b2) && w2;
        }
        const jp = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, $p = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Up(t2, e2, r3, n2, i2, s2) {
          if (e2.imageName) {
            const t3 = n2[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * Wh / s2 + i2 : 0;
          }
          {
            const n3 = r3[e2.fontStack], s3 = n3 && n3.glyphs[t2];
            return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function Op(t2, e2, r3, n2) {
          const i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r3) * r3;
        }
        function qp(t2, e2, r3) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r3 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function Np(t2, e2, r3, n2, i2, s2) {
          let a2 = null, o2 = Op(e2, r3, i2, s2);
          for (const t3 of n2) {
            const n3 = Op(e2 - t3.x, r3, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function Gp(t2) {
          return t2 ? Gp(t2.priorBreak).concat(t2.index) : [];
        }
        function Zp(t2) {
          let e2 = 0.5, r3 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r3 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r3 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r3 };
        }
        function Xp(t2, e2, r3, n2, i2) {
          if (!(e2 || r3 || n2 || i2)) return;
          const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
          for (let e3 = 0; e3 <= s2; e3++) t2[e3].x -= o2, t2[e3].y += r3 + n2 + i2;
        }
        function Kp(t2, e2, r3) {
          const { horizontalAlign: n2, verticalAlign: i2 } = Zp(r3), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
        }
        function Yp(t2, e2, r3, n2, i2, s2) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l2 = e2.left * s2, u2 = e2.right * s2;
          let c2, h2, p2, f2;
          "width" === r3 || "both" === r3 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
          const d2 = e2.top * s2, y2 = e2.bottom * s2;
          return "height" === r3 || "both" === r3 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        class Hp extends d {
          constructor(t2, e2, r3, n2, i2) {
            super(t2, e2), this.angle = n2, this.z = r3, void 0 !== i2 && (this.segment = i2);
          }
          clone() {
            return new Hp(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function Wp(t2, e2, r3, n2, i2) {
          if (void 0 === e2.segment) return true;
          let s2 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r3 / 2; ) {
            if (a2--, a2 < 0) return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r3 / 2; ) {
            const e3 = t2[a2], r4 = t2[a2 + 1];
            if (!r4) return false;
            let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r4);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; ) u2 -= l2.shift().angleDelta;
            if (u2 > i2) return false;
            a2++, o2 += e3.dist(r4);
          }
          return true;
        }
        function Jp(t2) {
          let e2 = 0;
          for (let r3 = 0; r3 < t2.length - 1; r3++) e2 += t2[r3].dist(t2[r3 + 1]);
          return e2;
        }
        function Qp(t2, e2, r3) {
          return t2 ? 0.6 * e2 * r3 : 0;
        }
        function tf(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function ef(t2, e2, r3, n2, i2, s2) {
          const a2 = Qp(r3, i2, s2), o2 = tf(r3, n2) * s2;
          let l2 = 0;
          const u2 = Jp(t2) / 2;
          for (let r4 = 0; r4 < t2.length - 1; r4++) {
            const n3 = t2[r4], i3 = t2[r4 + 1], s3 = n3.dist(i3);
            if (l2 + s3 > u2) {
              const c2 = (u2 - l2) / s3, h2 = Mr(n3.x, i3.x, c2), p2 = Mr(n3.y, i3.y, c2), f2 = new Hp(h2, p2, 0, i3.angleTo(n3), r4);
              return !a2 || Wp(t2, f2, o2, a2, e2) ? f2 : void 0;
            }
            l2 += s3;
          }
        }
        function rf(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          const u2 = Qp(n2, s2, a2), c2 = tf(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nf(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r3, h2, p2, false, l2);
        }
        function nf(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          const u2 = s2 / 2, c2 = Jp(t2);
          let h2 = 0, p2 = e2 - r3, f2 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
            for (; p2 + r3 < h2 + d2; ) {
              p2 += r3;
              const m2 = (p2 - h2) / d2, g2 = Mr(a3.x, o3.x, m2), x2 = Mr(a3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r4 = new Hp(g2, x2, 0, y2, e3);
                r4._round(), n2 && !Wp(t2, r4, s2, n2, i2) || f2.push(r4);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || a2 || (f2 = nf(t2, h2 / 2, r3, n2, i2, s2, a2, true, l2)), f2;
        }
        function sf(t2, e2, r3, n2, i2) {
          const s2 = [];
          for (let a2 = 0; a2 < t2.length; a2++) {
            const o2 = t2[a2];
            let l2;
            for (let t3 = 0; t3 < o2.length - 1; t3++) {
              let a3 = o2[t3], u2 = o2[t3 + 1];
              a3.x < e2 && u2.x < e2 || (a3.x < e2 ? a3 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e2 && (u2 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r3 && u2.y < r3 || (a3.y < r3 ? a3 = new d(a3.x + (r3 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r3)._round() : u2.y < r3 && (u2 = new d(a3.x + (r3 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r3)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
            }
          }
          return s2;
        }
        Oi(Hp, "Anchor");
        const af = 1e20;
        function of(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          for (let u2 = e2; u2 < e2 + n2; u2++) lf(t2, r3 * s2 + u2, s2, i2, a2, o2, l2);
          for (let u2 = r3; u2 < r3 + i2; u2++) lf(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
        }
        function lf(t2, e2, r3, n2, i2, s2, a2) {
          s2[0] = 0, a2[0] = -af, a2[1] = af, i2[0] = t2[e2];
          for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
            i2[o2] = t2[e2 + o2 * r3];
            const n3 = o2 * o2;
            do {
              const t3 = s2[l2];
              u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
            } while (u2 <= a2[l2] && --l2 > -1);
            l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = af;
          }
          for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
            for (; a2[l2 + 1] < o2; ) l2++;
            const n3 = s2[l2], u2 = o2 - n3;
            t2[e2 + o2 * r3] = i2[n3] + u2 * u2;
          }
        }
        const uf = { none: 0, ideographs: 1, all: 2 };
        class cf {
          constructor(t2, e2, r3) {
            this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r3, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(t2, e2) {
            const r3 = [];
            for (const e3 in t2) for (const n2 of t2[e3]) r3.push({ stack: e3, id: n2 });
            M(r3, ({ stack: t3, id: e3 }, r4) => {
              let n2 = this.entries[t3];
              n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i2 = n2.glyphs[e3];
              if (void 0 !== i2) return void r4(null, { stack: t3, id: e3, glyph: i2 });
              if (i2 = this._tinySDF(n2, t3, e3), i2) return n2.glyphs[e3] = i2, void r4(null, { stack: t3, id: e3, glyph: i2 });
              const s2 = Math.floor(e3 / 256);
              if (256 * s2 > 65535) return void r4(new Error("glyphs > 65535 not supported"));
              if (n2.ranges[s2]) return void r4(null, { stack: t3, id: e3, glyph: i2 });
              let a2 = n2.requests[s2];
              a2 || (a2 = n2.requests[s2] = [], cf.loadGlyphRange(t3, s2, this.url, this.requestManager, (t4, e4) => {
                if (e4) {
                  n2.ascender = e4.ascender, n2.descender = e4.descender;
                  for (const t5 in e4.glyphs) this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                  n2.ranges[s2] = true;
                }
                for (const r5 of a2) r5(t4, e4);
                delete n2.requests[s2];
              })), a2.push((n3, i3) => {
                n3 ? r4(n3) : i3 && r4(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
              });
            }, (t3, r4) => {
              if (t3) e2(t3);
              else if (r4) {
                const t4 = {};
                for (const { stack: e3, id: n2, glyph: i2 } of r4) void 0 === t4[e3] && (t4[e3] = {}), void 0 === t4[e3].glyphs && (t4[e3].glyphs = {}), t4[e3].glyphs[n2] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
                e2(null, t4);
              }
            });
          }
          _doesCharSupportLocalGlyph(t2) {
            return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t2) || ps(t2) || ts(t2) || es(t2) || Qi(t2)));
          }
          _tinySDF(t2, e2, r3) {
            const n2 = this.localFontFamily;
            if (!n2 || !this._doesCharSupportLocalGlyph(r3)) return;
            let i2 = t2.tinySDF;
            if (!i2) {
              let r4 = "400";
              /bold/i.test(e2) ? r4 = "900" : /medium/i.test(e2) ? r4 = "500" : /light/i.test(e2) && (r4 = "200"), i2 = t2.tinySDF = new cf.TinySDF({ fontFamily: n2, fontWeight: r4, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r4;
            }
            if (this.localGlyphs[i2.fontWeight][r3]) return this.localGlyphs[i2.fontWeight][r3];
            const s2 = String.fromCharCode(r3), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
            return this.localGlyphs[i2.fontWeight][r3] = { id: r3, bitmap: new Ju({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: f2 / 2, localGlyph: true } };
          }
        }
        function hf(t2, e2, r3, n2) {
          const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2, l2 = s2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = h2.reduce(f2, 0), m2 = p2.reduce(f2, 0), g2 = o2 - y2, x2 = l2 - m2;
          let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, S2 = g2, k2 = 0, I2 = x2;
          if (s2.content && n2) {
            const t3 = s2.content;
            v2 = pf(h2, 0, t3[0]), w2 = pf(p2, 0, t3[1]), b2 = pf(h2, t3[0], t3[2]), _2 = pf(p2, t3[1], t3[3]), A2 = t3[0] - v2, k2 = t3[1] - w2, S2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - _2;
          }
          const M2 = (n3, i3, o3, l3) => {
            const h3 = df(n3.stretch - v2, b2, u2, t2.left), p3 = yf(n3.fixed - A2, S2, n3.stretch, y2), f3 = df(i3.stretch - w2, _2, c2, t2.top), g3 = yf(i3.fixed - k2, I2, i3.stretch, m2), x3 = df(o3.stretch - v2, b2, u2, t2.left), M3 = yf(o3.fixed - A2, S2, o3.stretch, y2), T2 = df(l3.stretch - w2, _2, c2, t2.top), z2 = yf(l3.fixed - k2, I2, l3.stretch, m2), B2 = new d(h3, f3), E2 = new d(x3, f3), C2 = new d(x3, T2), P2 = new d(h3, T2), D2 = new d(p3 / a2, g3 / a2), V2 = new d(M3 / a2, z2 / a2), L2 = e2 * Math.PI / 180;
            if (L2) {
              const t3 = Math.sin(L2), e3 = Math.cos(L2), r4 = [e3, -t3, t3, e3];
              B2._matMult(r4), E2._matMult(r4), P2._matMult(r4), C2._matMult(r4);
            }
            const F2 = n3.stretch + n3.fixed, R2 = i3.stretch + i3.fixed;
            return { tl: B2, tr: E2, bl: P2, br: C2, tex: { x: s2.paddedRect.x + 1 + F2, y: s2.paddedRect.y + 1 + R2, w: o3.stretch + o3.fixed - F2, h: l3.stretch + l3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: S2 / a2 / u2, minFontScaleY: I2 / a2 / c2, isSDF: r3 };
          };
          if (n2 && (s2.stretchX || s2.stretchY)) {
            const t3 = ff(h2, g2, y2), e3 = ff(p2, x2, m2);
            for (let r4 = 0; r4 < t3.length - 1; r4++) {
              const n3 = t3[r4], s3 = t3[r4 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++) i2.push(M2(n3, e3[t4], s3, e3[t4 + 1]));
            }
          } else i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return i2;
        }
        function pf(t2, e2, r3) {
          let n2 = 0;
          for (const i2 of t2) n2 += Math.max(e2, Math.min(r3, i2[1])) - Math.max(e2, Math.min(r3, i2[0]));
          return n2;
        }
        function ff(t2, e2, r3) {
          const n2 = [{ fixed: -1, stretch: 0 }];
          for (const [e3, r4] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r4 - e3) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r3 }), n2;
        }
        function df(t2, e2, r3, n2) {
          return t2 / e2 * r3 + n2;
        }
        function yf(t2, e2, r3, n2) {
          return t2 - e2 * r3 / n2;
        }
        function mf(t2, e2, r3, n2) {
          const i2 = e2 + t2.positionedLines[n2].lineOffset;
          return 0 === n2 ? r3 + i2 / 2 : r3 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
        }
        cf.loadGlyphRange = function(t2, e2, r3, n2, i2) {
          const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r3).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), st.Glyphs);
          ut(o2, (t3, e3) => {
            if (t3) i2(t3);
            else if (e3) {
              const t4 = {}, r4 = function(t5) {
                return new op(t5).readFields(zp, {});
              }(e3);
              for (const e4 of r4.glyphs) t4[e4.id] = e4;
              i2(null, { glyphs: t4, ascender: r4.ascender, descender: r4.descender });
            }
          });
        }, cf.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r3 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = n2, this.radius = r3;
            const o2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
          }
          _createCanvas(t2) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            const { width: e2, actualBoundingBoxAscent: r3, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r3), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h2), f2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === o2 || 0 === l2) return f2;
            const { ctx: d2, buffer: y2, gridInner: m2, gridOuter: g2 } = this;
            d2.clearRect(y2, y2, o2, l2), d2.fillText(t2, y2, y2 + a2);
            const x2 = d2.getImageData(y2, y2, o2, l2);
            g2.fill(af, 0, h2), m2.fill(0, 0, h2);
            for (let t3 = 0; t3 < l2; t3++) for (let e3 = 0; e3 < o2; e3++) {
              const r4 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (0 === r4) continue;
              const n3 = (t3 + y2) * u2 + e3 + y2;
              if (1 === r4) g2[n3] = 0, m2[n3] = af;
              else {
                const t4 = 0.5 - r4;
                g2[n3] = t4 > 0 ? t4 * t4 : 0, m2[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
            of(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), of(m2, y2, y2, o2, l2, u2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < h2; t3++) {
              const e3 = Math.sqrt(g2[t3]) - Math.sqrt(m2[t3]);
              p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return f2;
          }
        };
        class gf {
          constructor(t2 = [], e2 = xf) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r3 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r3(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r3 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1), s2 = e2[n3];
              const a2 = n3 + 1;
              if (a2 < this.length && r3(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r3(s2, i2) >= 0) break;
              e2[t2] = s2, t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        function xf(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function vf(t2, e2 = 1, r3 = false) {
          let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          const o2 = t2[0];
          for (let t3 = 0; t3 < o2.length; t3++) {
            const e3 = o2[t3];
            (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
          }
          const l2 = Math.min(s2 - n2, a2 - i2);
          let u2 = l2 / 2;
          const c2 = new gf([], bf);
          if (0 === l2) return new d(n2, i2);
          for (let e3 = n2; e3 < s2; e3 += l2) for (let r4 = i2; r4 < a2; r4 += l2) c2.push(new wf(e3 + u2, r4 + u2, u2, t2));
          let h2 = function(t3) {
            let e3 = 0, r4 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
              const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
              r4 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new wf(r4 / e3, n3 / e3, 0, t3);
          }(t2), p2 = c2.length;
          for (; c2.length; ) {
            const n3 = c2.pop();
            (n3.d > h2.d || !h2.d) && (h2 = n3, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new wf(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
          }
          return r3 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
        }
        function bf(t2, e2) {
          return e2.max - t2.max;
        }
        class wf {
          constructor(t2, e2, r3, n2) {
            this.p = new d(t2, e2), this.h = r3, this.d = function(t3, e3) {
              let r4 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s2 = e3[i2];
                for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s2[e4], o2 = s2[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r4 = !r4), n3 = Math.min(n3, Cu(t3, i4, o2));
                }
              }
              return (r4 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const _f = Number.POSITIVE_INFINITY, Af = Math.sqrt(2);
        function Sf(t2, [e2, r3]) {
          let n2 = 0, i2 = 0;
          if (r3 === _f) {
            e2 < 0 && (e2 = 0);
            const r4 = e2 / Af;
            switch (t2) {
              case "top-right":
              case "top-left":
                i2 = r4 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                i2 = 7 - r4;
                break;
              case "bottom":
                i2 = 7 - e2;
                break;
              case "top":
                i2 = e2 - 7;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
                n2 = -r4;
                break;
              case "top-left":
              case "bottom-left":
                n2 = r4;
                break;
              case "left":
                n2 = e2;
                break;
              case "right":
                n2 = -e2;
            }
          } else {
            switch (e2 = Math.abs(e2), r3 = Math.abs(r3), t2) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r3 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r3;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e2;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e2;
            }
          }
          return [n2, i2];
        }
        function kf(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2) {
          t2.createArrays(), t2.tilePixelRatio = ko / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
          const c2 = t2.layers[0].layout, h2 = t2.layers[0]._unevaluatedLayout._values, p2 = {};
          if ("composite" === t2.textSizeData.kind) {
            const { minZoom: e3, maxZoom: r4 } = t2.textSizeData;
            p2.compositeTextSizes = [h2["text-size"].possiblyEvaluate(new $s(e3), o2), h2["text-size"].possiblyEvaluate(new $s(r4), o2)];
          }
          if ("composite" === t2.iconSizeData.kind) {
            const { minZoom: e3, maxZoom: r4 } = t2.iconSizeData;
            p2.compositeIconSizes = [h2["icon-size"].possiblyEvaluate(new $s(e3), o2), h2["icon-size"].possiblyEvaluate(new $s(r4), o2)];
          }
          p2.layoutTextSize = h2["text-size"].possiblyEvaluate(new $s(l2 + 1), o2), p2.layoutIconSize = h2["icon-size"].possiblyEvaluate(new $s(l2 + 1), o2), p2.textMaxSize = h2["text-size"].possiblyEvaluate(new $s(18), o2);
          const f2 = "map" === c2.get("text-rotation-alignment") && "point" !== c2.get("symbol-placement"), d2 = c2.get("text-size");
          for (const s3 of t2.features) {
            const l3 = c2.get("text-font").evaluate(s3, {}, o2).join(","), h3 = d2.evaluate(s3, {}, o2), y2 = p2.layoutTextSize.evaluate(s3, {}, o2), m2 = (p2.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s3.text;
            let x2, v2 = [0, 0];
            if (g2) {
              const n3 = g2.toString(), a3 = c2.get("text-letter-spacing").evaluate(s3, {}, o2) * Wh, u3 = c2.get("text-line-height").evaluate(s3, {}, o2) * Wh, p3 = ws(n3) ? a3 : 0, d3 = c2.get("text-anchor").evaluate(s3, {}, o2), x3 = c2.get("text-variable-anchor");
              if (!x3) {
                const t3 = c2.get("text-radial-offset").evaluate(s3, {}, o2);
                v2 = t3 ? Sf(d3, [t3 * Wh, _f]) : c2.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * Wh);
              }
              let b3 = f2 ? "center" : c2.get("text-justify").evaluate(s3, {}, o2);
              const w3 = "point" === c2.get("symbol-placement"), _2 = w3 ? c2.get("text-max-width").evaluate(s3, {}, o2) * Wh : 1 / 0, A2 = (s4) => {
                t2.allowVerticalPlacement && bs(n3) && (m2.vertical = Rp(g2, e2, r3, i2, l3, _2, u3, d3, s4, p3, v2, Vp.vertical, true, y2, h3));
              };
              if (!f2 && x3) {
                const t3 = "auto" === b3 ? x3.map((t4) => If(t4)) : [b3];
                let n4 = false;
                for (let s4 = 0; s4 < t3.length; s4++) {
                  const a4 = t3[s4];
                  if (!m2.horizontal[a4]) if (n4) m2.horizontal[a4] = m2.horizontal[0];
                  else {
                    const t4 = Rp(g2, e2, r3, i2, l3, _2, u3, "center", a4, p3, v2, Vp.horizontal, false, y2, h3);
                    t4 && (m2.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                  }
                }
                A2("left");
              } else {
                if ("auto" === b3 && (b3 = If(d3)), w3 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n3)) {
                  const t3 = Rp(g2, e2, r3, i2, l3, _2, u3, d3, b3, p3, v2, Vp.horizontal, false, y2, h3);
                  t3 && (m2.horizontal[b3] = t3);
                }
                A2(w3 ? "left" : b3);
              }
            }
            let b2 = false;
            if (s3.icon && s3.icon.name) {
              const e3 = n2[s3.icon.name];
              e3 && (x2 = Kp(i2[s3.icon.name], c2.get("icon-offset").evaluate(s3, {}, o2), c2.get("icon-anchor").evaluate(s3, {}, o2)), b2 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && U("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== c2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
            }
            const w2 = Bf(m2.horizontal) || m2.vertical;
            t2.iconsInText || (t2.iconsInText = !!w2 && w2.iconsInText), (w2 || x2) && Mf(t2, s3, m2, x2, n2, p2, y2, 0, v2, b2, a2, o2, u2);
          }
          s2 && t2.generateCollisionDebugBuffers(l2, t2.collisionBoxArray);
        }
        function If(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Mf(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          let f2 = s2.textMaxSize.evaluate(e2, {}, h2);
          void 0 === f2 && (f2 = a2);
          const d2 = t2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(e2, {}, h2), m2 = Bf(r3.horizontal) || r3.vertical, g2 = "globe" === p2.name, v2 = a2 / 24, b2 = t2.tilePixelRatio * f2 / 24, w2 = (z2 = t2.overscaling, t2.zoom > 18 && z2 > 2 && (z2 >>= 1), Math.max(ko / (512 * z2), 1) * d2.get("symbol-spacing")), _2 = d2.get("text-padding") * t2.tilePixelRatio, A2 = d2.get("icon-padding") * t2.tilePixelRatio, S2 = x(d2.get("text-max-angle")), k2 = "map" === d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), I2 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), M2 = d2.get("symbol-placement"), T2 = w2 / 2;
          var z2;
          const B2 = d2.get("icon-text-fit");
          let E2;
          n2 && "none" !== B2 && (t2.allowVerticalPlacement && r3.vertical && (E2 = Yp(n2, r3.vertical, B2, d2.get("icon-text-fit-padding"), y2, v2)), m2 && (n2 = Yp(n2, m2, B2, d2.get("icon-text-fit-padding"), y2, v2)));
          const C2 = (a3, o3, f3) => {
            if (o3.x < 0 || o3.x >= ko || o3.y < 0 || o3.y >= ko) return;
            let d3 = null;
            if (g2) {
              const { x: t3, y: e3, z: r4 } = p2.projectTilePoint(o3.x, o3.y, f3);
              d3 = { anchor: new Hp(t3, e3, r4, 0, void 0), up: p2.upVector(f3, o3.x, o3.y) };
            }
            !function(t3, e3, r4, n3, i3, s3, a4, o4, l3, u3, c3, h3, p3, f4, d4, y3, m3, g3, x2, v3, b3, w3, _3, A3, S3) {
              const k3 = t3.addToLineVertexArray(e3, n3);
              let I3, M3, T3, z3, B3, E3, C3, P2 = 0, D2 = 0, V2 = 0, L2 = 0, F2 = -1, R2 = -1;
              const j2 = {};
              let $2 = qa("");
              const O2 = r4 ? r4.anchor : e3;
              let q2 = 0, N2 = 0;
              if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [q2, N2] = l3.layout.get("text-offset").evaluate(b3, {}, S3).map((t4) => t4 * Wh) : (q2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, S3) * Wh, N2 = _f), t3.allowVerticalPlacement && i3.vertical) {
                const t4 = i3.vertical;
                if (d4) E3 = Cf(t4), o4 && (C3 = Cf(o4));
                else {
                  const r5 = l3.layout.get("text-rotate").evaluate(b3, {}, S3) + 90;
                  T3 = Ef(u3, O2, e3, c3, h3, p3, t4, f4, r5, y3), o4 && (z3 = Ef(u3, O2, e3, c3, h3, p3, o4, g3, r5));
                }
              }
              if (s3) {
                const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, S3), i4 = "none" !== l3.layout.get("icon-text-fit"), a5 = hf(s3, n4, _3, i4), f5 = o4 ? hf(o4, n4, _3, i4) : void 0;
                M3 = Ef(u3, O2, e3, c3, h3, p3, s3, g3, n4), P2 = 4 * a5.length;
                const d5 = t3.iconSizeData;
                let y4 = null;
                "source" === d5.kind ? (y4 = [Jh * l3.layout.get("icon-size").evaluate(b3, {}, S3)], y4[0] > Tf && U(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d5.kind && (y4 = [Jh * w3.compositeIconSizes[0].evaluate(b3, {}, S3), Jh * w3.compositeIconSizes[1].evaluate(b3, {}, S3)], (y4[0] > Tf || y4[1] > Tf) && U(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, a5, y4, v3, x2, b3, false, r4, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F2 = t3.icon.placedSymbolArray.length - 1, f5 && (D2 = 4 * f5.length, t3.addSymbols(t3.icon, f5, y4, v3, x2, b3, Vp.vertical, r4, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R2 = t3.icon.placedSymbolArray.length - 1);
              }
              for (const n4 in i3.horizontal) {
                const s4 = i3.horizontal[n4];
                I3 || ($2 = qa(s4.text), d4 ? B3 = Cf(s4) : I3 = Ef(u3, O2, e3, c3, h3, p3, s4, f4, l3.layout.get("text-rotate").evaluate(b3, {}, S3), y3));
                const o5 = 1 === s4.positionedLines.length;
                if (V2 += zf(t3, r4, e3, s4, a4, l3, d4, b3, y3, k3, i3.vertical ? Vp.horizontal : Vp.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], j2, F2, w3, A3, S3), o5) break;
              }
              i3.vertical && (L2 += zf(t3, r4, e3, i3.vertical, a4, l3, d4, b3, y3, k3, Vp.vertical, ["vertical"], j2, R2, w3, A3, S3));
              let G2 = -1;
              const Z2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
              G2 = Z2(B3, G2), G2 = Z2(E3, G2), G2 = Z2(C3, G2);
              const X2 = G2 > -1 ? 1 : 0;
              t3.glyphOffsetArray.length >= hd.MAX_GLYPHS && U("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(O2.x, O2.y, O2.z, e3.x, e3.y, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, F2, R2, $2, void 0 !== I3 ? I3 : t3.collisionBoxArray.length, void 0 !== I3 ? I3 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 + 1 : t3.collisionBoxArray.length, z3 || t3.collisionBoxArray.length, z3 ? z3 + 1 : t3.collisionBoxArray.length, c3, V2, L2, P2, D2, X2, 0, q2, N2, G2);
            }(t2, o3, d3, a3, r3, n2, i2, E2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, _2, k2, l2, 0, A2, I2, y2, e2, s2, u2, c2, h2);
          };
          if ("line" === M2) for (const i3 of sf(e2.geometry, 0, 0, ko, ko)) {
            const e3 = rf(i3, w2, S2, r3.vertical || m2, n2, 24, b2, t2.overscaling, ko);
            for (const r4 of e3) {
              const e4 = m2;
              e4 && Pf(t2, e4.text, T2, r4) || C2(i3, r4, h2);
            }
          }
          else if ("line-center" === M2) {
            for (const t3 of e2.geometry) if (t3.length > 1) {
              const e3 = ef(t3, S2, r3.vertical || m2, n2, 24, b2);
              e3 && C2(t3, e3, h2);
            }
          } else if ("Polygon" === e2.type) for (const t3 of Lc(e2.geometry, 0)) {
            const e3 = vf(t3, 16);
            C2(t3[0], new Hp(e3.x, e3.y, 0, 0, void 0), h2);
          }
          else if ("LineString" === e2.type) for (const t3 of e2.geometry) C2(t3, new Hp(t3[0].x, t3[0].y, 0, 0, void 0), h2);
          else if ("Point" === e2.type) for (const t3 of e2.geometry) for (const e3 of t3) C2([e3], new Hp(e3.x, e3.y, 0, 0, void 0), h2);
        }
        const Tf = 32640;
        function zf(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, y2, m2, g2) {
          const x2 = function(t3, e3, r4, n3, i3, s3, a3, o3) {
            const l3 = [];
            if (0 === e3.positionedLines.length) return l3;
            const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
              const e4 = t4[0], r5 = t4[1], n4 = e4 * r5;
              return n4 > 0 ? [e4, -r5] : n4 < 0 ? [-e4, r5] : 0 === e4 ? [r5, e4] : [r5, -e4];
            }(r4);
            let h3 = Math.abs(e3.top - e3.bottom);
            for (const t4 of e3.positionedLines) h3 -= t4.lineOffset;
            const p3 = e3.positionedLines.length, f3 = h3 / p3;
            let y3 = e3.top - r4[1];
            for (let t4 = 0; t4 < p3; ++t4) {
              const n4 = e3.positionedLines[t4];
              y3 = mf(e3, f3, y3, t4);
              for (const t5 of n4.positionedGlyphs) {
                if (!t5.rect) continue;
                const n5 = t5.rect || {};
                let s4 = 4, h4 = true, p4 = 1, f4 = 0;
                if (t5.imageName) {
                  const e4 = a3[t5.imageName];
                  if (!e4) continue;
                  if (e4.sdf) {
                    U("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  h4 = false, p4 = e4.pixelRatio, s4 = 1 / p4;
                }
                const m3 = (i3 || o3) && t5.vertical, g3 = t5.metrics.advance * t5.scale / 2, x3 = t5.metrics, v3 = t5.rect;
                if (null === v3) continue;
                o3 && e3.verticalizable && (f4 = t5.imageName ? g3 - t5.metrics.width * t5.scale / 2 : 0);
                const b3 = i3 ? [t5.x + g3, t5.y] : [0, 0];
                let w2 = [0, 0], _2 = [0, 0], A2 = false;
                i3 || (m3 ? (_2 = [t5.x + g3 + c3[0], t5.y + c3[1] - f4], A2 = true) : w2 = [t5.x + g3 + r4[0], t5.y + r4[1] - f4]);
                const S2 = v3.w * t5.scale / (p4 * (t5.localGlyph ? 2 : 1)), k2 = v3.h * t5.scale / (p4 * (t5.localGlyph ? 2 : 1));
                let I2, M2, T2, z2;
                if (m3) {
                  const e4 = t5.y - y3, r5 = new d(-g3, g3 - e4), n6 = -Math.PI / 2, i4 = new d(..._2);
                  I2 = new d(-g3 + w2[0], w2[1]), I2._rotateAround(n6, r5)._add(i4), I2.x += -e4 + g3, I2.y -= (x3.left - s4) * t5.scale;
                  const a4 = t5.imageName ? x3.advance * t5.scale : Wh * t5.scale, o4 = String.fromCharCode(t5.glyph);
                  sp(o4) ? I2.x += (1 - s4) * t5.scale : ap(o4) ? I2.x += a4 - x3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.imageName || x3.width + 2 * s4 === v3.w && x3.height + 2 * s4 === v3.h ? (a4 - k2) / 2 : (a4 - (x3.height + 2 * s4) * t5.scale) / 2, M2 = new d(I2.x, I2.y - S2), T2 = new d(I2.x + k2, I2.y), z2 = new d(I2.x + k2, I2.y - S2);
                } else {
                  const e4 = (x3.left - s4) * t5.scale - g3 + w2[0], r5 = (-x3.top - s4) * t5.scale + w2[1], n6 = e4 + S2, i4 = r5 + k2;
                  I2 = new d(e4, r5), M2 = new d(n6, r5), T2 = new d(e4, i4), z2 = new d(n6, i4);
                }
                if (u3) {
                  let t6;
                  t6 = i3 ? new d(0, 0) : A2 ? new d(c3[0], c3[1]) : new d(r4[0], r4[1]), I2._rotateAround(u3, t6), M2._rotateAround(u3, t6), T2._rotateAround(u3, t6), z2._rotateAround(u3, t6);
                }
                const B2 = new d(0, 0), E2 = new d(0, 0);
                l3.push({ tl: I2, tr: M2, bl: T2, br: z2, tex: n5, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: B2, pixelOffsetBR: E2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return l3;
          }(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), v2 = t2.textSizeData;
          let b2 = null;
          "source" === v2.kind ? (b2 = [Jh * s2.layout.get("text-size").evaluate(o2, {}, g2)], b2[0] > Tf && U(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v2.kind && (b2 = [Jh * y2.compositeTextSizes[0].evaluate(o2, {}, g2), Jh * y2.compositeTextSizes[1].evaluate(o2, {}, g2)], (b2[0] > Tf || b2[1] > Tf) && U(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, x2, b2, l2, a2, o2, c2, e2, r3, u2.lineStartIndex, u2.lineLength, f2, m2, g2);
          for (const e3 of h2) p2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * x2.length;
        }
        function Bf(t2) {
          for (const e2 in t2) return t2[e2];
          return null;
        }
        function Ef(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2) {
          let c2 = a2.top, h2 = a2.bottom, p2 = a2.left, f2 = a2.right;
          const y2 = a2.collisionPadding;
          if (y2 && (p2 -= y2[0], c2 -= y2[1], f2 += y2[2], h2 += y2[3]), l2) {
            const t3 = new d(p2, c2), e3 = new d(f2, c2), r4 = new d(p2, h2), n3 = new d(f2, h2), i3 = x(l2);
            let s3 = new d(0, 0);
            u2 && (s3 = new d(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r4._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r4.x, n3.x), f2 = Math.max(t3.x, e3.x, r4.x, n3.x), c2 = Math.min(t3.y, e3.y, r4.y, n3.y), h2 = Math.max(t3.y, e3.y, r4.y, n3.y);
          }
          return t2.emplaceBack(e2.x, e2.y, e2.z, r3.x, r3.y, p2, c2, f2, h2, o2, n2, i2, s2), t2.length - 1;
        }
        function Cf(t2) {
          t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
          const e2 = t2.bottom - t2.top;
          return e2 > 0 ? Math.max(10, e2) : null;
        }
        function Pf(t2, e2, r3, n2) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r3) return true;
          } else i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        function Df(t2, e2) {
          const r3 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r3) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r3, 0.01)), a2 = Math.sin(t2._pitch) * s2 + i2;
          return Math.min(1.01 * a2, i2 * (1 / t2._horizonShift));
        }
        function Vf(t2, e2) {
          if (!e2.isReprojectedInTileSpace) return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
          const r3 = Math.pow(2, -t2.z), n2 = t2.x * r3, i2 = (t2.x + 1) * r3, s2 = t2.y * r3, a2 = (t2.y + 1) * r3, o2 = ou(n2), l2 = ou(i2), u2 = lu(s2), c2 = lu(a2), h2 = e2.project(o2, u2), p2 = e2.project(l2, u2), f2 = e2.project(l2, c2), d2 = e2.project(o2, c2);
          let y2 = Math.min(h2.x, p2.x, f2.x, d2.x), m2 = Math.min(h2.y, p2.y, f2.y, d2.y), g2 = Math.max(h2.x, p2.x, f2.x, d2.x), x2 = Math.max(h2.y, p2.y, f2.y, d2.y);
          const v2 = r3 / 16;
          function b2(t3, r4, n3, i3, s3, a3) {
            const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e2.project(ou(o3), lu(l3)), c3 = Math.max(0, y2 - u3.x, m2 - u3.y, u3.x - g2, u3.y - x2);
            y2 = Math.min(y2, u3.x), g2 = Math.max(g2, u3.x), m2 = Math.min(m2, u3.y), x2 = Math.max(x2, u3.y), c3 > v2 && (b2(t3, u3, n3, i3, o3, l3), b2(u3, r4, o3, l3, s3, a3));
          }
          b2(h2, p2, n2, s2, i2, s2), b2(p2, f2, i2, s2, i2, a2), b2(f2, d2, i2, a2, n2, a2), b2(d2, h2, n2, a2, n2, s2), y2 -= v2, m2 -= v2, g2 += v2, x2 += v2;
          const w2 = 1 / Math.max(g2 - y2, x2 - m2);
          return { scale: w2, x: y2 * w2, y: m2 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
        }
        const Lf = Eo(new Float32Array(16));
        class Ff {
          constructor(t2) {
            this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t2, e2) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t2, e2) {
            return new ru(0, 0);
          }
          projectTilePoint(t2, e2, r3) {
            return { x: t2, y: e2, z: 0 };
          }
          locationPoint(t2, e2, r3 = true) {
            return t2._coordinatePoint(t2.locationCoordinate(e2), r3);
          }
          pixelsPerMeter(t2, e2) {
            return au(1, t2) * e2;
          }
          pixelSpaceConversion(t2, e2, r3) {
            return 1;
          }
          farthestPixelDistance(t2) {
            return Df(t2, t2.pixelsPerMeter);
          }
          pointCoordinate(t2, e2, r3, n2) {
            const i2 = t2.horizonLineFromTop(false), s2 = new d(e2, Math.max(i2, r3));
            return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
          }
          pointCoordinate3D(t2, e2, r3) {
            const n2 = new d(e2, r3);
            if (t2.elevation) return t2.elevation.pointCoordinate(n2);
            {
              const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
              return [e3.x, e3.y, e3.z];
            }
          }
          isPointAboveHorizon(t2, e2) {
            if (t2.elevation) return !this.pointCoordinate3D(t2, e2.x, e2.y);
            const r3 = t2.horizonLineFromTop();
            return e2.y < r3;
          }
          createInversionMatrix(t2, e2) {
            return Lf;
          }
          createTileMatrix(t2, e2, r3) {
            let n2, i2, s2;
            const a2 = r3.canonical, o2 = Eo(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const l2 = Vf(a2, this);
              n2 = 1, i2 = l2.x + r3.wrap * l2.scale, s2 = l2.y, Vo(o2, o2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
            } else n2 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r3.wrap) * n2, s2 = a2.y * n2;
            return Do(o2, o2, [i2, s2, 0]), Vo(o2, o2, [n2 / ko, n2 / ko, 1]), o2;
          }
          upVector(t2, e2, r3) {
            return [0, 0, 1];
          }
          upVectorScale(t2, e2, r3) {
            return { metersToTile: 1 };
          }
        }
        class Rf extends Ff {
          constructor(t2) {
            super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
            const [e2, r3] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(x(e2));
            this.n = (n2 + Math.sin(x(r3))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t2, e2) {
            const { n: r3, c: n2, r0: i2 } = this, s2 = x(t2 - this.center[0]), a2 = x(e2), o2 = Math.sqrt(n2 - 2 * r3 * Math.sin(a2)) / r3;
            return { x: o2 * Math.sin(s2 * r3), y: o2 * Math.cos(s2 * r3) - i2, z: 0 };
          }
          unproject(t2, e2) {
            const { n: r3, c: n2, r0: i2 } = this, s2 = i2 + e2;
            let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
            s2 * r3 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
            const o2 = x(this.center[0]) * r3;
            a2 = I(a2, -Math.PI - o2, Math.PI - o2);
            const l2 = S(v(a2 / r3) + this.center[0], -180, 180), u2 = Math.asin(S((n2 - (t2 * t2 + s2 * s2) * r3 * r3) / (2 * r3), -1, 1)), c2 = S(v(u2), -cu, cu);
            return new ru(l2, c2);
          }
        }
        const jf = 1.340264, $f = -0.081106, Uf = 893e-6, Of = 3796e-6, qf = Math.sqrt(3) / 2;
        class Nf extends Ff {
          project(t2, e2) {
            e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
            const r3 = Math.asin(qf * Math.sin(e2)), n2 = r3 * r3, i2 = n2 * n2 * n2;
            return { x: 0.5 * (t2 * Math.cos(r3) / (qf * (jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r3 * (jf + $f * n2 + i2 * (Uf + Of * n2)) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r3 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r3 * r3, i2 = n2 * n2 * n2;
            for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r3 * (jf + $f * n2 + i2 * (Uf + Of * n2)) - e2, a3 = jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2), t3 = s3 / a3, r3 = S(r3 - t3, -Math.PI / 3, Math.PI / 3), n2 = r3 * r3, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3) ;
            const s2 = qf * t2 * (jf + 3 * $f * n2 + i2 * (7 * Uf + 9 * Of * n2)) / Math.cos(r3), a2 = Math.asin(Math.sin(r3) / qf), o2 = S(180 * s2 / Math.PI, -180, 180), l2 = S(180 * a2 / Math.PI, -cu, cu);
            return new ru(o2, l2);
          }
        }
        class Gf extends Ff {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
          }
          unproject(t2, e2) {
            const r3 = 360 * (t2 - 0.5), n2 = S(360 * (0.5 - e2), -cu, cu);
            return new ru(r3, n2);
          }
        }
        const Zf = Math.PI / 2;
        function Xf(t2) {
          return Math.tan((Zf + t2) / 2);
        }
        class Kf extends Ff {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 30];
            const [e2, r3] = this.parallels = t2.parallels || [30, 30];
            let n2 = x(e2), i2 = x(r3);
            this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
            const s2 = Math.cos(n2), a2 = Xf(n2);
            this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(Xf(i2) / a2), this.f = s2 * Math.pow(Xf(n2), this.n) / this.n;
          }
          project(t2, e2) {
            e2 = x(e2), this.southernCenter && (e2 = -e2), t2 = x(t2 - this.center[0]);
            const r3 = 1e-6, { n: n2, f: i2 } = this;
            i2 > 0 ? e2 < -Zf + r3 && (e2 = -Zf + r3) : e2 > Zf - r3 && (e2 = Zf - r3);
            const s2 = i2 / Math.pow(Xf(e2), n2);
            let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
            return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
            const { n: r3, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), a2 = Math.sign(r3) * Math.sqrt(t2 * t2 + i2 * i2);
            let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
            i2 * r3 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
            const l2 = S(v(o2 / r3) + this.center[0], -180, 180), u2 = S(v(2 * Math.atan(Math.pow(n2 / a2, 1 / r3)) - Zf), -cu, cu);
            return new ru(l2, this.southernCenter ? -u2 : u2);
          }
        }
        class Yf extends Ff {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t2, e2) {
            return { x: iu(t2), y: su(e2), z: 0 };
          }
          unproject(t2, e2) {
            const r3 = ou(t2), n2 = lu(e2);
            return new ru(r3, n2);
          }
        }
        const Hf = x(cu);
        class Wf extends Ff {
          project(t2, e2) {
            const r3 = (e2 = x(e2)) * e2, n2 = r3 * r3;
            return { x: 0.5 * ((t2 = x(t2)) * (0.8707 - 0.131979 * r3 + n2 * (n2 * (3971e-6 * r3 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r3 * (0.015085 + n2 * (0.028874 * r3 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r3 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r3 * r3;
            do {
              s2 = r3 * r3;
              const t3 = s2 * s2;
              i2 = (r3 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r3 = S(r3 - i2, -Hf, Hf);
            } while (Math.abs(i2) > 1e-6 && --n2 > 0);
            s2 = r3 * r3;
            const a2 = S(v(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = v(r3);
            return new ru(a2, o2);
          }
        }
        const Jf = x(cu);
        class Qf extends Ff {
          project(t2, e2) {
            e2 = x(e2), t2 = x(t2);
            const r3 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r3 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r3 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
            return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            let r3 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
            const s2 = 1e-6;
            let a2 = 0, o2 = 0;
            do {
              const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h2 = Math.cos(r3 / 2), p2 = Math.sin(r3 / 2), f2 = 2 * h2 * p2, d2 = p2 * p2, y2 = 1 - c2 * h2 * h2, m2 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i3 * h2) * Math.sqrt(1 / y2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r3 / Math.PI) - t2, v2 = 0.5 * (g2 * s3 + n2) - e2, b2 = 0.5 * m2 * (c2 * d2 + g2 * i3 * h2 * u2) + 1 / Math.PI, w2 = m2 * (f2 * l2 / 4 - g2 * s3 * p2), _2 = 0.125 * m2 * (l2 * p2 - g2 * s3 * c2 * f2), A2 = 0.5 * m2 * (u2 * h2 + g2 * d2 * i3) + 0.5, k2 = w2 * _2 - A2 * b2;
              a2 = (v2 * w2 - x2 * A2) / k2, o2 = (x2 * _2 - v2 * b2) / k2, r3 = S(r3 - a2, -Math.PI, Math.PI), n2 = S(n2 - o2, -Jf, Jf);
            } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
            return new ru(v(r3), v(n2));
          }
        }
        class td extends Ff {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            const { scale: r3, cosPhi: n2 } = this;
            return { x: x(t2) * n2 * r3 + 0.5, y: -Math.sin(x(e2)) / n2 * r3 + 0.5, z: 0 };
          }
          unproject(t2, e2) {
            const { scale: r3, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r3, s2 = S(v((t2 - 0.5) / r3) / n2, -180, 180), a2 = Math.asin(S(i2 * n2, -1, 1)), o2 = S(v(a2), -cu, cu);
            return new ru(s2, o2);
          }
        }
        class ed extends Yf {
          constructor(t2) {
            super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(t2, e2, r3) {
            const n2 = Ol(t2, e2, r3);
            return el(n2, n2, Gl(Pl(r3))), { x: n2[0], y: n2[1], z: n2[2] };
          }
          locationPoint(t2, e2) {
            const r3 = Ul(e2.lat, e2.lng), n2 = Jo([], r3), i2 = t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
            Wo(r3, r3, n2, au(1, 0) * ko * i2);
            const s2 = Eo(new Float64Array(16));
            return Po(s2, t2.pixelMatrix, t2.globeMatrix), el(r3, r3, s2), new d(r3[0], r3[1]);
          }
          pixelsPerMeter(t2, e2) {
            return au(1, 0) * e2;
          }
          pixelSpaceConversion(t2, e2, r3) {
            const n2 = au(1, t2) * e2, i2 = Mr(au(1, 45) * e2, n2, r3);
            return this.pixelsPerMeter(t2, e2) / i2;
          }
          createTileMatrix(t2, e2, r3) {
            const n2 = Zl(Pl(r3.canonical));
            return Po(new Float64Array(16), t2.globeMatrix, n2);
          }
          createInversionMatrix(t2, e2) {
            const { center: r3 } = t2, n2 = Gl(Pl(e2));
            return Fo(n2, n2, x(r3.lng)), Lo(n2, n2, x(r3.lat)), Vo(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
          }
          pointCoordinate(t2, e2, r3, n2) {
            return Bl(t2, e2, r3, true) || new pu(0, 0);
          }
          pointCoordinate3D(t2, e2, r3) {
            const n2 = this.pointCoordinate(t2, e2, r3, 0);
            return [n2.x, n2.y, n2.z];
          }
          isPointAboveHorizon(t2, e2) {
            return !Bl(t2, e2.x, e2.y, false);
          }
          farthestPixelDistance(t2) {
            const e2 = function(t3, e3) {
              const r4 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = Go([], Ho([], s2, -r4), [0, 0, n2]), o2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -o2], u2 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h2 = Ho([], i2.up(), c2), p2 = Ho([], i2.right(), c2 * u2), f2 = Jo([], Go([], Go([], s2, h2), p2)), d2 = [];
              let y2;
              if (new vl(a2, f2).closestPointOnSphere(l2, o2, d2)) {
                const e4 = Go([], d2, l2), r5 = il([], e4, a2);
                y2 = Math.cos(t3.fovAboveCenter) * qo(r5);
              } else {
                const t4 = il([], a2, l2), e4 = il([], l2, a2);
                Jo(e4, e4);
                const r5 = qo(t4) - o2;
                y2 = Math.sqrt(r5 * (r5 + 2 * o2));
                const n3 = Math.acos(y2 / (o2 + r5)) - Math.acos(Qo(s2, e4));
                y2 *= Math.cos(n3);
              }
              return 1.01 * y2;
            }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r3 = Kl(t2.zoom);
            if (r3 > 0) {
              const n2 = Df(t2, au(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
              return Mr(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r3, 10));
            }
            return e2;
          }
          upVector(t2, e2, r3) {
            return Ol(e2, r3, t2, 1);
          }
          upVectorScale(t2) {
            return { metersToTile: zl(ql(Pl(t2))) };
          }
        }
        function rd(t2) {
          const e2 = t2.parallels, r3 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
          switch (t2.name) {
            case "mercator":
              return new Yf(t2);
            case "equirectangular":
              return new Gf(t2);
            case "naturalEarth":
              return new Wf(t2);
            case "equalEarth":
              return new Nf(t2);
            case "winkelTripel":
              return new Qf(t2);
            case "albers":
              return r3 ? new td(t2) : new Rf(t2);
            case "lambertConformalConic":
              return r3 ? new td(t2) : new Kf(t2);
            case "globe":
              return new ed(t2);
          }
          throw new Error(`Invalid projection name: ${t2.name}`);
        }
        const nd = ah.types, id = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function sd(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const f2 = o2 ? Math.min(Tf, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Tf, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r3, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function ad(t2, e2, r3, n2, i2, s2, a2) {
          t2.emplaceBack(e2, r3, n2, i2, s2, a2);
        }
        function od(t2, e2, r3, n2, i2) {
          t2.emplaceBack(e2, r3, n2, i2), t2.emplaceBack(e2, r3, n2, i2), t2.emplaceBack(e2, r3, n2, i2), t2.emplaceBack(e2, r3, n2, i2);
        }
        function ld(t2) {
          for (const e2 of t2.sections) if (Ms(e2.text)) return true;
          return false;
        }
        class ud {
          constructor(t2) {
            this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t2, this.segments = new So(), this.dynamicLayoutVertexArray = new ua(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Pa(), this.globeExtVertexArray = new da();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e2, r3, n2) {
            this.isEmpty() || (r3 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Zh.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, id, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Gh.members, true)), this.opacityVertexBuffer.itemSize = 1), (r3 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
        }
        Oi(ud, "SymbolBuffers");
        class cd {
          constructor(t2, e2, r3) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r3(), this.segments = new So(), this.collisionVertexArray = new va(), this.collisionVertexArrayExt = new ba();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Xh.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Oi(cd, "CollisionBuffers");
        class hd {
          constructor(t2) {
            this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);
            const e2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Qh(this.zoom, e2["text-size"]), this.iconSizeData = Qh(this.zoom, e2["icon-size"]);
            const r3 = this.layers[0].layout, n2 = r3.get("symbol-sort-key"), i2 = r3.get("symbol-z-order");
            this.canOverlap = r3.get("text-allow-overlap") || r3.get("icon-allow-overlap") || r3.get("text-ignore-placement") || r3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r3.get("text-writing-mode").map((t3) => Vp[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection;
          }
          createArrays() {
            this.text = new ud(new fo(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new ud(new fo(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new La(), this.lineVertexArray = new Fa(), this.symbolInstances = new Va();
          }
          calculateGlyphDependencies(t2, e2, r3, n2, i2) {
            for (let r4 = 0; r4 < t2.length; r4++) if (e2[t2.charCodeAt(r4)] = true, n2 && i2) {
              const n3 = ip[t2.charAt(r4)];
              n3 && (e2[n3.charCodeAt(0)] = true);
            }
          }
          populate(t2, e2, r3, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = "globe" === this.projection.name, o2 = s2.get("text-font"), l2 = s2.get("text-field"), u2 = s2.get("icon-image"), c2 = ("constant" !== l2.value.kind || l2.value.value instanceof Be && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), h2 = "constant" !== u2.value.kind || !!u2.value.value || Object.keys(u2.parameters).length > 0, p2 = s2.get("symbol-sort-key");
            if (this.features = [], !c2 && !h2) return;
            const f2 = e2.iconDependencies, d2 = e2.glyphDependencies, y2 = e2.availableImages, m2 = new $s(this.zoom);
            for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: g2 } of t2) {
              const t3 = i2._featureFilter.needGeometry, x2 = wu(e3, t3);
              if (!i2._featureFilter.filter(m2, x2, r3)) continue;
              if (t3 || (x2.geometry = bu(e3, r3, n2)), a2 && 1 !== e3.type && r3.z <= 5) {
                const t4 = x2.geometry, e4 = 0.98078528056, n3 = (t5, n4) => Qo(Ol(t5.x, t5.y, r3, 1), Ol(n4.x, n4.y, r3, 1)) < e4;
                for (let e5 = 0; e5 < t4.length; e5++) t4[e5] = mu(t4[e5], n3);
              }
              let v2, b2;
              if (c2) {
                const t4 = i2.getValueAndResolveTokens("text-field", x2, r3, y2), e4 = Be.factory(t4);
                ld(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v2 = np(e4, i2, x2));
              }
              if (h2) {
                const t4 = i2.getValueAndResolveTokens("icon-image", x2, r3, y2);
                b2 = t4 instanceof Ee ? t4 : Ee.fromString(t4);
              }
              if (!v2 && !b2) continue;
              const w2 = this.sortFeaturesByKey ? p2.evaluate(x2, {}, r3) : void 0;
              if (this.features.push({ id: l3, text: v2, icon: b2, index: u3, sourceLayerIndex: g2, geometry: x2.geometry, properties: e3.properties, type: nd[e3.type], sortKey: w2 }), b2 && (f2[b2.name] = true), v2) {
                const t4 = o2.evaluate(x2, {}, r3).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;
                for (const r4 of v2.sections) if (r4.image) f2[r4.image.name] = true;
                else {
                  const n3 = bs(v2.toString()), i3 = r4.fontStack || t4, s3 = d2[i3] = d2[i3] || {};
                  this.calculateGlyphDependencies(r4.text, s3, e4, this.allowVerticalPlacement, n3);
                }
              }
            }
            "line" === s2.get("symbol-placement") && (this.features = function(t3) {
              const e3 = {}, r4 = {}, n3 = [];
              let i3 = 0;
              function s3(e4) {
                n3.push(t3[e4]), i3++;
              }
              function a3(t4, e4, i4) {
                const s4 = r4[t4];
                return delete r4[t4], r4[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t4, r5, i4) {
                const s4 = e3[r5];
                return delete e3[r5], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l3(t4, e4, r5) {
                const n4 = r5 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t4}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t3.length; u3++) {
                const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                if (f3 in r4 && d3 in e3 && r4[f3] !== e3[d3]) {
                  const t4 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t4].geometry);
                  delete e3[f3], delete r4[d3], r4[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                } else f3 in r4 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r4[d3] = i3 - 1);
              }
              return n3.filter((t4) => t4.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
          }
          update(t2, e2, r3, n2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r3, n2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r3, n2));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r3 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) for (const { x: t3, y: r4 } of e2) this.lineVertexArray.emplaceBack(t3, r4);
            return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
          }
          addSymbols(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2) {
            const d2 = t2.indexArray, y2 = t2.layoutVertexArray, m2 = t2.globeExtVertexArray, g2 = t2.segments.prepareSegment(4 * e2.length, y2, d2, this.canOverlap ? s2.sortKey : void 0), x2 = this.glyphOffsetArray.length, v2 = g2.vertexLength, b2 = this.allowVerticalPlacement && a2 === Vp.vertical ? Math.PI / 2 : 0, w2 = s2.text && s2.text.sections;
            for (let n3 = 0; n3 < e2.length; n3++) {
              const { tl: i3, tr: a3, bl: u3, br: c3, tex: h3, pixelOffsetTL: x3, pixelOffsetBR: v3, minFontScaleX: _3, minFontScaleY: A2, glyphOffset: S2, isSDF: k2, sectionIndex: I2 } = e2[n3], M2 = g2.vertexLength, T2 = S2[1];
              if (sd(y2, l2.x, l2.y, i3.x, T2 + i3.y, h3.x, h3.y, r3, k2, x3.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, a3.x, T2 + a3.y, h3.x + h3.w, h3.y, r3, k2, v3.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, u3.x, T2 + u3.y, h3.x, h3.y + h3.h, r3, k2, x3.x, v3.y, _3, A2), sd(y2, l2.x, l2.y, c3.x, T2 + c3.y, h3.x + h3.w, h3.y + h3.h, r3, k2, v3.x, v3.y, _3, A2), o2) {
                const { x: e3, y: r4, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
                ad(m2, e3, r4, n4, i4, s3, a4), ad(m2, e3, r4, n4, i4, s3, a4), ad(m2, e3, r4, n4, i4, s3, a4), ad(m2, e3, r4, n4, i4, s3, a4), od(t2.dynamicLayoutVertexArray, e3, r4, n4, b2);
              } else od(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, b2);
              d2.emplaceBack(M2, M2 + 1, M2 + 2), d2.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n3 !== e2.length - 1 && I2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(y2.length, s2, s2.index, {}, p2, f2, w2 && w2[I2]);
            }
            const _2 = o2 ? o2.anchor : l2;
            t2.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l2.x, l2.y, x2, this.glyphOffsetArray.length - x2, v2, u2, c2, l2.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, n2[0], n2[1], a2, 0, false, 0, h2, 0);
          }
          _commitLayoutVertex(t2, e2, r3, n2, i2, s2, a2) {
            t2.emplaceBack(e2, r3, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
          }
          _addCollisionDebugVertices(t2, e2, r3, n2, i2, s2, a2) {
            const o2 = r3.segments.prepareSegment(4, r3.layoutVertexArray, r3.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
            for (let t3 = 0; t3 < 4; t3++) r3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            r3.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r3.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r3.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y2)), this._commitLayoutVertex(r3.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y2)), o2.vertexLength += 4;
            const h2 = r3.indexArray;
            h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
              this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
            }
          }
          _addIconDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r3.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
            }
          }
          generateCollisionDebugBuffers(t2, e2) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);
            const r3 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
            for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
              const s2 = this.symbolInstances.get(i2);
              this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r3, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
            }
          }
          getSymbolInstanceTextSize(t2, e2, r3, n2) {
            const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = tp(this.textSizeData, t2, i2) / Wh;
            return this.tilePixelRatio * s2;
          }
          getSymbolInstanceIconSize(t2, e2, r3) {
            const n2 = this.icon.placedSymbolArray.get(r3), i2 = tp(this.iconSizeData, t2, n2);
            return this.tilePixelRatio * i2;
          }
          _commitDebugCollisionVertexUpdate(t2, e2, r3) {
            t2.emplaceBack(e2, -r3, -r3), t2.emplaceBack(e2, r3, -r3), t2.emplaceBack(e2, r3, r3), t2.emplaceBack(e2, -r3, r3);
          }
          _updateTextDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r3.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding);
            }
          }
          _updateIconDebugCollisionBoxes(t2, e2, r3, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r3.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding);
            }
          }
          updateCollisionDebugBuffers(t2, e2) {
            if (!this.hasDebugData()) return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r3 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
            for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
              const s2 = this.symbolInstances.get(i2);
              this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r3, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r3, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2.placedIconSymbolIndex);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const u2 = {};
            if (e2 < r3) {
              const { x1: r4, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(e2);
              u2.textBox = { x1: r4, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.textFeatureIndex = f2;
            }
            if (n2 < i2) {
              const { x1: e3, y1: r4, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
              u2.verticalTextBox = { x1: e3, y1: r4, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = f2;
            }
            if (s2 < a2) {
              const { x1: e3, y1: r4, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
              u2.iconBox = { x1: e3, y1: r4, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.iconFeatureIndex = f2;
            }
            if (o2 < l2) {
              const { x1: e3, y1: r4, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(o2);
              u2.verticalIconBox = { x1: e3, y1: r4, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = f2;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r3 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r3 = t2.placedSymbolArray.get(e2), n2 = r3.vertexStartIndex + 4 * r3.numGlyphs;
            for (let e3 = r3.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r3 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * a2.tileAnchorX + r3 * a2.tileAnchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
          }
          addToSortKeyRanges(t2, e2) {
            const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r3 && r3.sortKey === e2 ? r3.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex);
                const { rightJustifiedTextSymbolIndex: r3, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
                r3 >= 0 && this.addIndicesForPlacedSymbol(this.text, r3), n2 >= 0 && n2 !== r3 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r3 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        Oi(hd, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;
        const pd = new Js({ "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]), "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]), "icon-size": new Hs(Ht.layout_symbol["icon-size"]), "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]), "icon-image": new Hs(Ht.layout_symbol["icon-image"]), "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]), "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]), "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]), "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]), "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]), "text-field": new Hs(Ht.layout_symbol["text-field"]), "text-font": new Hs(Ht.layout_symbol["text-font"]), "text-size": new Hs(Ht.layout_symbol["text-size"]), "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]), "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]), "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]), "text-justify": new Hs(Ht.layout_symbol["text-justify"]), "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]), "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]), "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]), "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]), "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]), "text-padding": new Ys(Ht.layout_symbol["text-padding"]), "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]), "text-transform": new Hs(Ht.layout_symbol["text-transform"]), "text-offset": new Hs(Ht.layout_symbol["text-offset"]), "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]), "text-optional": new Ys(Ht.layout_symbol["text-optional"]) });
        var fd = { paint: new Js({ "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]), "icon-color": new Hs(Ht.paint_symbol["icon-color"]), "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]), "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]), "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]), "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]), "text-color": new Hs(Ht.paint_symbol["text-color"], { runtimeType: le, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]), "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]), "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]), "text-translate": new Ys(Ht.paint_symbol["text-translate"]), "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"]) }), layout: pd };
        class dd {
          constructor(t2) {
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ie, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Oi(dd, "FormatSectionOverride", { omit: ["defaultValue"] });
        class yd extends wo {
          constructor(t2) {
            super(t2, fd);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r3 = this.layout.get("text-writing-mode");
            if (r3) {
              const t3 = [];
              for (const e3 of r3) t3.indexOf(e3) < 0 && t3.push(e3);
              this.layout._values["text-writing-mode"] = t3;
            } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r3, n2) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r3, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || Nn(s2.value) || !i2 ? i2 : function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r4) => r4 in t3 ? String(t3[r4]) : "");
            }(e2.properties, i2);
          }
          createBucket(t2) {
            return new hd(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t2 of fd.paint.overridableProperties) {
              if (!yd.hasPaintOverride(this.layout, t2)) continue;
              const e2 = this.paint.get(t2), r3 = new dd(e2), n2 = new qn(r3, e2.property.specification);
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Zn("source", n2) : new Xn("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new Xs(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r3) {
            return !(!this.layout || e2.isDataDriven() || r3.isDataDriven()) && yd.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r3 = t2.get("text-field"), n2 = fd.paint.properties[e2];
            let i2 = false;
            const s2 = (t3) => {
              for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
            };
            if ("constant" === r3.value.kind && r3.value.value instanceof Be) s2(r3.value.value.sections);
            else if ("source" === r3.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof Fe && De(e4.value) === pe ? s2(e4.value.sections) : e4 instanceof Oe ? s2(e4.sections) : e4.eachChild(t3));
              }, e3 = r3.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
        }
        var md = { paint: new Js({ "background-color": new Ys(Ht.paint_background["background-color"]), "background-pattern": new Ys(Ht.paint_background["background-pattern"]), "background-opacity": new Ys(Ht.paint_background["background-opacity"]) }) }, gd = { paint: new Js({ "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]), "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]), "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]), "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]), "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"]) }) };
        class xd extends wo {
          constructor(t2) {
            super(t2, {}), this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isLayerDraped() {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t2) {
            this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
          }
          onRemove(t2) {
            this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
          }
        }
        var vd = { paint: new Js({ "sky-type": new Ys(Ht.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"]) }) };
        function bd(t2, e2, r3) {
          const n2 = [0, 0, 1], i2 = hl([]);
          return fl(i2, i2, r3 ? -x(t2) + Math.PI : x(t2)), pl(i2, i2, -x(e2)), rl(n2, n2, i2), Jo(n2, n2);
        }
        const wd = { circle: class extends wo {
          constructor(t2) {
            super(t2, Ou);
          }
          createBucket(t2) {
            return new Su(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return Fu("circle-radius", this, e2) + Fu("circle-stroke-width", this, e2) + Ru(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = $u(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r3) + this.paint.get("circle-stroke-width").evaluate(e2, r3);
            return qu(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
          }
          getProgramIds() {
            return ["circle"];
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
        }, heatmap: class extends wo {
          createBucket(t2) {
            return new Ku(t2);
          }
          constructor(t2) {
            super(t2, tc), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = ec({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t2) {
            return Fu("heatmap-radius", this, t2);
          }
          queryIntersectsFeature(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = this.paint.get("heatmap-radius").evaluate(e2, r3);
            return qu(t2, n2, s2, a2, o2, true, true, new d(0, 0), l2);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
        }, hillshade: class extends wo {
          constructor(t2) {
            super(t2, rc);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
        }, fill: class extends wo {
          constructor(t2) {
            super(t2, Oc);
          }
          getProgramIds() {
            const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r3 = [e2 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r3.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r3;
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r3 = this.paint._values["fill-outline-color"];
            "constant" === r3.value.kind && void 0 === r3.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new $c(t2);
          }
          queryRadius() {
            return Ru(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r3, n2, i2, s2) {
            return !t2.queryGeometry.isAboveHorizon && Mu(ju(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends wo {
          constructor(t2) {
            super(t2, Ah);
          }
          createBucket(t2) {
            return new fh(t2);
          }
          queryRadius() {
            return Ru(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
          queryIntersectsFeature(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const u2 = $u(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r3), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r3), p2 = [0, 0], f2 = o2 && s2.elevation, y2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
            if (f2 && m2 instanceof fh) {
              const t3 = m2.centroidVertexArray, e3 = l2 + 1;
              e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
            }
            if (0 === p2[0] && 1 === p2[1]) return false;
            "globe" === s2.projection.name && (n2 = wh([n2], [new d(0, 0), new d(ko, ko)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
            const g2 = f2 ? o2 : null, [x2, v2] = function(t3, e3, r4, n3, i3, s3, a3, o3, l3, u3, c3) {
              return "globe" === t3.projection.name ? function(t4, e4, r5, n4, i4, s4, a4, o4, l4, u4, c4) {
                const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d2 = [0, 0, 0, 1], y3 = [0, 0, 0, 1], m3 = (t5, e5, r6, n5) => {
                  t5[0] = e5, t5[1] = r6, t5[2] = n5, t5[3] = 1;
                }, g3 = bh();
                r5 > 0 && (r5 += g3), n4 += g3;
                for (const g4 of e4) {
                  const e5 = [], x3 = [];
                  for (const h4 of g4) {
                    const p4 = h4.x + i4.x, g5 = h4.y + i4.y, v3 = t4.projection.projectTilePoint(p4, g5, c4), b3 = t4.projection.upVector(c4, h4.x, h4.y);
                    let w2 = r5, _2 = n4;
                    if (a4) {
                      const t5 = Ch(p4, g5, r5, n4, a4, o4, l4, u4);
                      w2 += t5.base, _2 += t5.top;
                    }
                    0 !== r5 ? m3(d2, v3.x + b3[0] * f3 * w2, v3.y + b3[1] * f3 * w2, v3.z + b3[2] * f3 * w2) : m3(d2, v3.x, v3.y, v3.z), m3(y3, v3.x + b3[0] * f3 * _2, v3.y + b3[1] * f3 * _2, v3.z + b3[2] * f3 * _2), el(d2, d2, s4), el(y3, y3, s4), e5.push(new zh(d2[0], d2[1], d2[2])), x3.push(new zh(y3[0], y3[1], y3[2]));
                  }
                  h3.push(e5), p3.push(x3);
                }
                return [h3, p3];
              }(t3, e3, r4, n3, i3, s3, a3, o3, l3, u3, c3) : a3 ? function(t4, e4, r5, n4, i4, s4, a4, o4, l4) {
                const u4 = [], c4 = [], h3 = [0, 0, 0, 1];
                for (const p3 of t4) {
                  const t5 = [], f3 = [];
                  for (const u5 of p3) {
                    const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d2 = Ch(c5, p4, e4, r5, s4, a4, o4, l4);
                    h3[0] = c5, h3[1] = p4, h3[2] = d2.base, h3[3] = 1, ul(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                    const y3 = new zh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                    h3[0] = c5, h3[1] = p4, h3[2] = d2.top, h3[3] = 1, ul(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                    const m3 = new zh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                    t5.push(y3), f3.push(m3);
                  }
                  u4.push(t5), c4.push(f3);
                }
                return [u4, c4];
              }(e3, r4, n3, i3, s3, a3, o3, l3, u3) : function(t4, e4, r5, n4, i4) {
                const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r5, p3 = i4[9] * r5, f3 = i4[10] * r5, d2 = i4[11] * r5;
                for (const e5 of t4) {
                  const t5 = [], r6 = [];
                  for (const s5 of e5) {
                    const e6 = s5.x + n4.x, a5 = s5.y + n4.y, y3 = i4[0] * e6 + i4[4] * a5 + i4[12], m3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x3 = i4[3] * e6 + i4[7] * a5 + i4[15], v3 = y3 + o4, b3 = m3 + l4, w2 = g3 + u4, _2 = Math.max(x3 + c4, 1e-5), A2 = y3 + h3, S2 = m3 + p3, k2 = g3 + f3, I2 = Math.max(x3 + d2, 1e-5);
                    t5.push(new zh(v3 / _2, b3 / _2, w2 / _2)), r6.push(new zh(A2 / I2, S2 / I2, k2 / I2));
                  }
                  s4.push(t5), a4.push(r6);
                }
                return [s4, a4];
              }(e3, r4, n3, i3, s3);
            }(s2, n2, h2, c2, u2, a2, g2, p2, y2, s2.center.lat, t2.tileID.canonical), b2 = t2.queryGeometry;
            return function(t3, e3, r4) {
              let n3 = 1 / 0;
              Mu(r4, e3) && (n3 = Eh(r4, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const s3 = e3[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s3.length - 1; t4++) {
                  const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                  ku(r4, i4) && (n3 = Math.min(n3, Eh(r4, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(x2, v2, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
          }
        }, line: class extends wo {
          constructor(t2) {
            super(t2, Uh), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new jh(t2);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getProgramConfiguration(t2) {
            return new po(this, t2);
          }
          queryRadius(t2) {
            const e2 = t2, r3 = qh(Fu("line-width", this, e2), Fu("line-gap-width", this, e2)), n2 = Fu("line-offset", this, e2);
            return r3 / 2 + Math.abs(n2) + Ru(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r3, n2, i2, s2) {
            if (t2.queryGeometry.isAboveHorizon) return false;
            const a2 = ju(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e2, r3), this.paint.get("line-gap-width").evaluate(e2, r3)), l2 = this.paint.get("line-offset").evaluate(e2, r3);
            return l2 && (n2 = function(t3, e3) {
              const r4 = [], n3 = new d(0, 0);
              for (let i3 = 0; i3 < t3.length; i3++) {
                const s3 = t3[i3], a3 = [];
                for (let t4 = 0; t4 < s3.length; t4++) {
                  const r5 = s3[t4 - 1], i4 = s3[t4], o3 = s3[t4 + 1], l3 = 0 === t4 ? n3 : i4.sub(r5)._unit()._perp(), u2 = t4 === s3.length - 1 ? n3 : o3.sub(i4)._unit()._perp(), c2 = l3._add(u2)._unit();
                  c2._mult(1 / (c2.x * u2.x + c2.y * u2.y)), a3.push(c2._mult(e3)._add(i4));
                }
                r4.push(a3);
              }
              return r4;
            }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r4) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++) if (Du(t3, i3[e4])) return true;
                }
                if (Tu(t3, i3, r4)) return true;
              }
              return false;
            }(a2, n2, o2);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: yd, background: class extends wo {
          constructor(t2) {
            super(t2, md);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
        }, raster: class extends wo {
          constructor(t2) {
            super(t2, gd);
          }
          getProgramIds() {
            return ["raster"];
          }
        }, sky: class extends wo {
          constructor(t2) {
            super(t2, vd), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = ec({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t2) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e2 = t2.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
            }
            return false;
          }
          getCenter(t2, e2) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r4 = this.paint.get("sky-atmosphere-sun"), n2 = !r4, i2 = t2.style.light, s2 = i2.properties.get("position");
              return n2 && "viewport" === i2.properties.get("anchor") && U("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? bd(s2.azimuthal, 90 - s2.polar, e2) : bd(r4[0], 90 - r4[1], e2);
            }
            const r3 = this.paint.get("sky-gradient-center");
            return bd(r3[0], 90 - r3[1], e2);
          }
          is3D() {
            return false;
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t2) {
            this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t2 = this.paint.get("sky-type");
            return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
          }
        } };
        class _d {
          constructor(t2, e2, r3, n2) {
            this.context = t2, this.format = r3, this.texture = t2.gl.createTexture(), this.update(e2, n2);
          }
          update(t2, r3, n2) {
            const { width: i2, height: s2 } = t2, { context: a2 } = this, { gl: o2 } = a2, { HTMLImageElement: l2, HTMLCanvasElement: u2, HTMLVideoElement: c2, ImageData: h2, ImageBitmap: p2 } = e;
            if (o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!r3 || false !== r3.premultiply)), n2 || this.size && this.size[0] === i2 && this.size[1] === s2) {
              const { x: e2, y: r4 } = n2 || { x: 0, y: 0 };
              t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r4, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r4, i2, s2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
            } else this.size = [i2, s2], t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, i2, s2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
            this.useMipmap = Boolean(r3 && r3.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o2.generateMipmap(o2.TEXTURE_2D);
          }
          bind(t2, e2) {
            const { context: r3 } = this, { gl: n2 } = r3;
            n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === n2.NEAREST ? n2.NEAREST_MIPMAP_NEAREST : n2.LINEAR_MIPMAP_NEAREST : t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Ad {
          constructor(t2) {
            this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class Sd {
          constructor() {
            this.tasks = {}, this.taskQueue = [], V(["process"], this), this.invoker = new Ad(this.process), this.nextId = 0;
          }
          add(t2, e2) {
            const r3 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r4 }) {
              return r4 = r4 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r4 : "maybePrepare" === t3 && e3 ? 400 - r4 : 500 : 200 - r4 : 100 - r4;
            }(e2);
            if (0 === n2) {
              N();
              try {
                t2();
              } finally {
              }
              return { cancel: () => {
              } };
            }
            return this.tasks[r3] = { fn: t2, metadata: e2, priority: n2, id: r3 }, this.taskQueue.push(r3), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r3];
            } };
          }
          process() {
            N();
            try {
              if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length) return;
              const t2 = this.pick();
              if (null === t2) return;
              const e2 = this.tasks[t2];
              if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2) return;
              e2.fn();
            } finally {
            }
          }
          pick() {
            let t2 = null, e2 = 1 / 0;
            for (let r4 = 0; r4 < this.taskQueue.length; r4++) {
              const n2 = this.tasks[this.taskQueue[r4]];
              n2.priority < e2 && (e2 = n2.priority, t2 = r4);
            }
            if (null === t2) return null;
            const r3 = this.taskQueue[t2];
            return this.taskQueue.splice(t2, 1), r3;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class kd {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r3 = t2[e2];
              this._stringToNumber[r3] = e2, this._numberToString[e2] = r3;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            return this._numberToString[t2];
          }
        }
        const Id = ["tile", "layer", "source", "sourceLayer", "state"];
        class Md {
          constructor(t2, e2, r3, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r3, this._y = n2, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            void 0 !== this.id && (t2.id = this.id);
            for (const e2 of Id) void 0 !== this[e2] && (t2[e2] = this[e2]);
            return t2;
          }
        }
        const Td = 32, zd = 33, Bd = new Uint16Array(8184);
        for (let t2 = 0; t2 < 2046; t2++) {
          let e2 = t2 + 2, r3 = 0, n2 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
          for (1 & e2 ? i2 = s2 = a2 = Td : r3 = n2 = o2 = Td; (e2 >>= 1) > 1; ) {
            const t3 = r3 + i2 >> 1, l3 = n2 + s2 >> 1;
            1 & e2 ? (i2 = r3, s2 = n2, r3 = a2, n2 = o2) : (r3 = i2, n2 = s2, i2 = a2, s2 = o2), a2 = t3, o2 = l3;
          }
          const l2 = 4 * t2;
          Bd[l2 + 0] = r3, Bd[l2 + 1] = n2, Bd[l2 + 2] = i2, Bd[l2 + 3] = s2;
        }
        const Ed = new Uint16Array(2178), Cd = new Uint8Array(1089), Pd = new Uint16Array(1089);
        function Dd(t2) {
          return 0 === t2 ? -0.03125 : 32 === t2 ? 0.03125 : 0;
        }
        var Vd = na([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        const Ld = { type: 2, extent: ko, loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]] };
        class Fd {
          constructor(t2, e2, r3, n2, i2) {
            this.tileID = t2, this.uid = E(), this.uses = 0, this.tileSize = e2, this.tileZoom = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, this.expiredRequestCount = 0, this.state = "loading", n2 && n2.transform && (this.projection = n2.transform.projection);
          }
          registerFadeDuration(t2) {
            const e2 = t2 + this.timeAdded;
            e2 < Nt.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t2, e2, r3) {
            if (this.unloadVectorData(), this.state = "loaded", t2) {
              t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
                const r4 = {};
                if (!e3) return r4;
                for (const n2 of t3) {
                  const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                  if (0 !== t4.length) {
                    n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                    for (const e4 of t4) r4[e4.id] = n2;
                  }
                }
                return r4;
              }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof hd) {
                  if (this.hasSymbolBuckets = true, !r3) break;
                  e3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof hd && e3.hasRTLText) {
                  this.hasRTLText = true, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const t3 in this.buckets) {
                const r4 = this.buckets[t3];
                this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r4));
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
            } else this.collisionBoxArray = new Ea();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t2 in this.buckets) this.buckets[t2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (const e3 in this.buckets) {
              const r3 = this.buckets[e3];
              r3.uploadPending() && r3.upload(t2);
            }
            const e2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e2, r3, n2, i2, s2, a2, o2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2, tileTransform: this.tileTransform }, t2, e2, r3) : {};
          }
          querySourceFeatures(t2, e2) {
            const r3 = this.latestFeatureIndex;
            if (!r3 || !r3.rawTileData) return;
            const n2 = r3.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
            if (!s2) return;
            const a2 = ai(e2 && e2.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
            for (let e3 = 0; e3 < s2.length; e3++) {
              const n3 = s2.feature(e3);
              if (a2.needGeometry) {
                const t3 = wu(n3, true);
                if (!a2.filter(new $s(this.tileID.overscaledZ), t3, this.tileID.canonical)) continue;
              } else if (!a2.filter(new $s(this.tileID.overscaledZ), n3)) continue;
              const h2 = r3.getId(n3, i2), p2 = new Md(n3, o2, l2, u2, h2);
              p2.tile = c2, t2.push(p2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t2) {
            const e2 = this.expirationTime;
            if (t2.cacheControl) {
              const e3 = G(t2.cacheControl);
              e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
            } else t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              const t3 = Date.now();
              let r3 = false;
              if (this.expirationTime > t3) r3 = false;
              else if (e2) if (this.expirationTime < e2) r3 = true;
              else {
                const n2 = this.expirationTime - e2;
                n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r3 = true;
              }
              else r3 = true;
              r3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length || !e2) return;
            const r3 = this.latestFeatureIndex.loadVTLayers(), n2 = e2.style.listImages();
            for (const i2 in this.buckets) {
              if (!e2.style.hasLayer(i2)) continue;
              const s2 = this.buckets[i2], a2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r3[a2], l2 = t2[a2];
              if (!o2 || !l2 || 0 === Object.keys(l2).length) continue;
              if (s2.update(l2, o2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}), s2 instanceof jh || s2 instanceof $c) {
                const t3 = e2.style._getSourceCache(s2.layers[0].source);
                e2._terrain && e2._terrain.enabled && t3 && s2.programConfigurations.needsUpload && e2._terrain._clearRenderCacheForTile(t3.id, this.tileID);
              }
              const u2 = e2 && e2.style && e2.style.getLayer(i2);
              u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(s2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t2) {
            this.symbolFadeHoldUntil = Nt.now() + t2;
          }
          setTexture(t2, e2) {
            const r3 = e2.context, n2 = r3.gl;
            this.texture = this.texture || e2.getTileTexture(t2.width), this.texture ? this.texture.update(t2, { useMipmap: true }) : (this.texture = new _d(r3, t2, n2.RGBA, { useMipmap: true }), this.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE));
          }
          setDependencies(t2, e2) {
            const r3 = {};
            for (const t3 of e2) r3[t3] = true;
            this.dependencies[t2] = r3;
          }
          hasDependency(t2, e2) {
            for (const r3 of t2) {
              const t3 = this.dependencies[r3];
              if (t3) {
                for (const r4 of e2) if (t3[r4]) return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t2, e2) {
            if (!e2 || "mercator" === e2.name || this._tileDebugBuffer) return;
            const r3 = bu(Ld, this.tileID.canonical, this.tileTransform)[0], n2 = new sa(), i2 = new Ta();
            for (let t3 = 0; t3 < r3.length; t3++) {
              const { x: e3, y: s2 } = r3[t3];
              n2.emplaceBack(e3, s2), i2.emplaceBack(t3);
            }
            i2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(i2), this._tileDebugBuffer = t2.createVertexBuffer(n2, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n2.length, i2.length);
          }
          _makeTileBoundsBuffers(t2, e2) {
            if (this._tileBoundsBuffer || !e2 || "mercator" === e2.name) return;
            const r3 = bu(Ld, this.tileID.canonical, this.tileTransform)[0];
            let n2, i2;
            if (this.isRaster) {
              const t3 = function(t4, e3) {
                const r4 = Vf(t4, e3), n3 = Math.pow(2, t4.z);
                for (let i4 = 0; i4 < zd; i4++) for (let s3 = 0; s3 < zd; s3++) {
                  const a3 = ou((t4.x + (s3 + Dd(s3)) / Td) / n3), o3 = lu((t4.y + (i4 + Dd(i4)) / Td) / n3), l3 = e3.project(a3, o3), u2 = i4 * zd + s3;
                  Ed[2 * u2 + 0] = Math.round((l3.x * r4.scale - r4.x) * ko), Ed[2 * u2 + 1] = Math.round((l3.y * r4.scale - r4.y) * ko);
                }
                Cd.fill(0), Pd.fill(0);
                for (let t5 = 2045; t5 >= 0; t5--) {
                  const e4 = 4 * t5, r5 = Bd[e4 + 0], n4 = Bd[e4 + 1], i4 = Bd[e4 + 2], s3 = Bd[e4 + 3], a3 = r5 + i4 >> 1, o3 = n4 + s3 >> 1, l3 = a3 + o3 - n4, u2 = o3 + r5 - a3, c2 = n4 * zd + r5, h2 = s3 * zd + i4, p2 = o3 * zd + a3, f2 = Math.hypot((Ed[2 * c2 + 0] + Ed[2 * h2 + 0]) / 2 - Ed[2 * p2 + 0], (Ed[2 * c2 + 1] + Ed[2 * h2 + 1]) / 2 - Ed[2 * p2 + 1]) >= 16;
                  if (Cd[p2] = Cd[p2] || (f2 ? 1 : 0), t5 < 1022) {
                    const t6 = (n4 + u2 >> 1) * zd + (r5 + l3 >> 1), e5 = (s3 + u2 >> 1) * zd + (i4 + l3 >> 1);
                    Cd[p2] = Cd[p2] || Cd[t6] || Cd[e5];
                  }
                }
                const i3 = new oa(), s2 = new wa();
                let a2 = 0;
                function o2(t5, e4) {
                  const r5 = e4 * zd + t5;
                  return 0 === Pd[r5] && (i3.emplaceBack(Ed[2 * r5 + 0], Ed[2 * r5 + 1], t5 * ko / Td, e4 * ko / Td), Pd[r5] = ++a2), Pd[r5] - 1;
                }
                function l2(t5, e4, r5, n4, i4, a3) {
                  const u2 = t5 + r5 >> 1, c2 = e4 + n4 >> 1;
                  if (Math.abs(t5 - i4) + Math.abs(e4 - a3) > 1 && Cd[c2 * zd + u2]) l2(i4, a3, t5, e4, u2, c2), l2(r5, n4, i4, a3, u2, c2);
                  else {
                    const l3 = o2(t5, e4), u3 = o2(r5, n4), c3 = o2(i4, a3);
                    s2.emplaceBack(l3, u3, c3);
                  }
                }
                return l2(0, 0, Td, Td, Td, 0), l2(Td, Td, 0, 0, 0, Td), { vertices: i3, indices: s2 };
              }(this.tileID.canonical, e2);
              n2 = t3.vertices, i2 = t3.indices;
            } else {
              n2 = new oa(), i2 = new wa();
              for (const { x: t4, y: e3 } of r3) n2.emplaceBack(t4, e3, 0, 0);
              const t3 = sc(n2.int16, void 0, 4);
              for (let e3 = 0; e3 < t3.length; e3 += 3) i2.emplaceBack(t3[e3], t3[e3 + 1], t3[e3 + 2]);
            }
            this._tileBoundsBuffer = t2.createVertexBuffer(n2, Vd.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(i2), this._tileBoundsSegments = So.simpleSegment(0, 0, n2.length, i2.length);
          }
          _makeGlobeTileDebugBuffers(t2, e2) {
            const r3 = e2.projection;
            if (!r3 || "globe" !== r3.name || e2.freezeTileCoverage) return;
            const n2 = this.tileID.canonical, i2 = Gl(Vl(n2, e2)), s2 = Kl(e2.zoom);
            let a2;
            s2 > 0 && (a2 = Co(new Float64Array(16), e2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, n2, e2, i2, a2, s2), this._makeGlobeTileDebugTextBuffer(t2, n2, e2, i2, a2, s2);
          }
          _globePoint(t2, e2, r3, n2, i2, s2, a2) {
            let o2 = Ol(t2, e2, r3);
            if (s2) {
              const i3 = 1 << r3.z, l2 = iu(n2.center.lng), u2 = su(n2.center.lat), c2 = (r3.x + 0.5) / i3 - l2;
              let h2 = 0;
              c2 > 0.5 ? h2 = -1 : c2 < -0.5 && (h2 = 1);
              let p2 = (t2 / ko + r3.x) / i3 + h2, f2 = (e2 / ko + r3.y) / i3;
              p2 = (p2 - l2) * n2._pixelsPerMercatorPixel + l2, f2 = (f2 - u2) * n2._pixelsPerMercatorPixel + u2;
              const d2 = [p2 * n2.worldSize, f2 * n2.worldSize, 0];
              el(d2, d2, s2), o2 = Dl(o2, d2, a2);
            }
            return el(o2, o2, i2);
          }
          _makeGlobeTileDebugBorderBuffer(t2, e2, r3, n2, i2, s2) {
            const a2 = new sa(), o2 = new Ta(), l2 = new aa(), u2 = (t3, u3, c3, h2, p2) => {
              const f2 = (c3 - t3) / (p2 - 1), d2 = (h2 - u3) / (p2 - 1), y2 = a2.length;
              for (let c4 = 0; c4 < p2; c4++) {
                const h3 = t3 + c4 * f2, p3 = u3 + c4 * d2;
                a2.emplaceBack(h3, p3);
                const m2 = this._globePoint(h3, p3, e2, r3, n2, i2, s2);
                l2.emplaceBack(m2[0], m2[1], m2[2]), o2.emplaceBack(y2 + c4);
              }
            }, c2 = ko;
            u2(0, 0, c2, 0, 16), u2(c2, 0, c2, c2, 16), u2(c2, c2, 0, c2, 16), u2(0, c2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a2.length, o2.length);
          }
          _makeGlobeTileDebugTextBuffer(t2, e2, r3, n2, i2, s2) {
            const a2 = new sa(), o2 = new wa(), l2 = new aa(), u2 = 25;
            o2.reserve(32), a2.reserve(u2), l2.reserve(u2);
            const c2 = (t3, e3) => u2 * t3 + e3;
            for (let t3 = 0; t3 < u2; t3++) {
              const o3 = 2048 * t3;
              for (let t4 = 0; t4 < u2; t4++) {
                const u3 = 2048 * t4;
                a2.emplaceBack(u3, o3);
                const c3 = this._globePoint(u3, o3, e2, r3, n2, i2, s2);
                l2.emplaceBack(c3[0], c3[1], c3[2]);
              }
            }
            for (let t3 = 0; t3 < 4; t3++) for (let e3 = 0; e3 < 4; e3++) {
              const r4 = c2(t3, e3), n3 = c2(t3, e3 + 1), i3 = c2(t3 + 1, e3), s3 = c2(t3 + 1, e3 + 1);
              o2.emplaceBack(r4, n3, i3), o2.emplaceBack(i3, n3, s3);
            }
            this._tileDebugTextIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugTextBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u2, 32);
          }
        }
        class Rd {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t2, e2, r3) {
            const n2 = String(e2);
            if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, z(this.stateChanges[t2][n2], r3), null === this.deletedStates[t2]) {
              this.deletedStates[t2] = {};
              for (const e3 in this.state[t2]) e3 !== n2 && (this.deletedStates[t2][e3] = null);
            } else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2]) {
              this.deletedStates[t2][n2] = {};
              for (const e3 in this.state[t2][n2]) r3[e3] || (this.deletedStates[t2][n2][e3] = null);
            } else for (const e3 in r3) this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][e3] && delete this.deletedStates[t2][n2][e3];
          }
          removeFeatureState(t2, e2, r3) {
            if (null === this.deletedStates[t2]) return;
            const n2 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r3 && void 0 !== e2) null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r3] = null);
            else if (void 0 !== e2) if (this.stateChanges[t2] && this.stateChanges[t2][n2]) for (r3 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2]) this.deletedStates[t2][n2][r3] = null;
            else this.deletedStates[t2][n2] = null;
            else this.deletedStates[t2] = null;
          }
          getState(t2, e2) {
            const r3 = String(e2), n2 = z({}, (this.state[t2] || {})[r3], (this.stateChanges[t2] || {})[r3]);
            if (null === this.deletedStates[t2]) return {};
            if (this.deletedStates[t2]) {
              const r4 = this.deletedStates[t2][e2];
              if (null === r4) return {};
              for (const t3 in r4) delete n2[t3];
            }
            return n2;
          }
          initializeTileState(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }
          coalesceChanges(t2, e2) {
            const r3 = {};
            for (const t3 in this.stateChanges) {
              this.state[t3] = this.state[t3] || {};
              const e3 = {};
              for (const r4 in this.stateChanges[t3]) this.state[t3][r4] || (this.state[t3][r4] = {}), z(this.state[t3][r4], this.stateChanges[t3][r4]), e3[r4] = this.state[t3][r4];
              r3[t3] = e3;
            }
            for (const t3 in this.deletedStates) {
              this.state[t3] = this.state[t3] || {};
              const e3 = {};
              if (null === this.deletedStates[t3]) for (const r4 in this.state[t3]) e3[r4] = {}, this.state[t3][r4] = {};
              else for (const r4 in this.deletedStates[t3]) {
                if (null === this.deletedStates[t3][r4]) this.state[t3][r4] = {};
                else if (this.state[t3][r4]) for (const e4 of Object.keys(this.deletedStates[t3][r4])) delete this.state[t3][r4][e4];
                e3[r4] = this.state[t3][r4];
              }
              r3[t3] = r3[t3] || {}, z(r3[t3], e3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r3).length) for (const n2 in t2) t2[n2].setFeatureState(r3, e2);
          }
        }
        class jd {
          constructor(t2) {
            this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t2, e2) {
            const r3 = this.toIdx(t2, e2);
            return { min: this.minimums[r3], max: this.maximums[r3] };
          }
          isLeaf(t2, e2) {
            return this.leaves[this.toIdx(t2, e2)];
          }
          toIdx(t2, e2) {
            return e2 * this.size + t2;
          }
        }
        function $d(t2, e2, r3, n2) {
          let i2 = 0, s2 = Number.MAX_VALUE;
          for (let a2 = 0; a2 < 3; a2++) if (Math.abs(n2[a2]) < 1e-15) {
            if (r3[a2] < t2[a2] || r3[a2] > e2[a2]) return null;
          } else {
            const o2 = 1 / n2[a2];
            let l2 = (t2[a2] - r3[a2]) * o2, u2 = (e2[a2] - r3[a2]) * o2;
            if (l2 > u2) {
              const t3 = l2;
              l2 = u2, u2 = t3;
            }
            if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2) return null;
          }
          return i2;
        }
        function Ud(t2, e2, r3, n2, i2, s2, a2, o2, l2, u2, c2) {
          const h2 = n2 - t2, p2 = i2 - e2, f2 = s2 - r3, d2 = a2 - t2, y2 = o2 - e2, m2 = l2 - r3, g2 = c2[1] * m2 - c2[2] * y2, x2 = c2[2] * d2 - c2[0] * m2, v2 = c2[0] * y2 - c2[1] * d2, b2 = h2 * g2 + p2 * x2 + f2 * v2;
          if (Math.abs(b2) < 1e-15) return null;
          const w2 = 1 / b2, _2 = u2[0] - t2, A2 = u2[1] - e2, S2 = u2[2] - r3, k2 = (_2 * g2 + A2 * x2 + S2 * v2) * w2;
          if (k2 < 0 || k2 > 1) return null;
          const I2 = A2 * f2 - S2 * p2, M2 = S2 * h2 - _2 * f2, T2 = _2 * p2 - A2 * h2, z2 = (c2[0] * I2 + c2[1] * M2 + c2[2] * T2) * w2;
          return z2 < 0 || k2 + z2 > 1 ? null : (d2 * I2 + y2 * M2 + m2 * T2) * w2;
        }
        function Od(t2, e2, r3) {
          return (t2 - e2) / (r3 - e2);
        }
        function qd(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          const u2 = 1 << r3, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, f2 = (e2 + 0) / u2 * h2 + i2, d2 = (e2 + 1) / u2 * h2 + i2;
          o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = f2, l2[0] = p2, l2[1] = d2;
        }
        class Nd {
          constructor(t2) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
            const e2 = function(t3) {
              const e3 = Math.ceil(Math.log2(t3.dim / 8)), r4 = [];
              let n3 = Math.ceil(Math.pow(2, e3));
              const i2 = 1 / n3, s2 = (t4, e4, r5, n4, i3) => {
                const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r5 - s3, o3 = e4 * r5, l2 = (e4 + 1) * r5 - s3;
                i3[0] = t4 * r5, i3[1] = o3, i3[2] = a3, i3[3] = l2;
              };
              let a2 = new jd(n3);
              const o2 = [];
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
                const r5 = Zd(o2[0], o2[1], t3), l2 = Zd(o2[2], o2[1], t3), u2 = Zd(o2[2], o2[3], t3), c2 = Zd(o2[0], o2[3], t3);
                a2.minimums.push(Math.min(r5, l2, u2, c2)), a2.maximums.push(Math.max(r5, l2, u2, c2)), a2.leaves.push(1);
              }
              for (r4.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                const t4 = r4[r4.length - 1];
                a2 = new jd(n3);
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                  const r5 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), f2 = t4.isLeaf(o2[0], o2[3]), d2 = Math.min(r5.min, i3.min, l2.min, u2.min), y2 = Math.max(r5.max, i3.max, l2.max, u2.max), m2 = c2 && h2 && p2 && f2;
                  a2.maximums.push(y2), a2.minimums.push(d2), a2.leaves.push(y2 - d2 <= 5 && m2 ? 1 : 0);
                }
                r4.push(a2);
              }
              return r4;
            }(this.dem), r3 = e2.length - 1, n2 = e2[r3];
            this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r3, 0);
          }
          raycastRoot(t2, e2, r3, n2, i2, s2, a2 = 1) {
            return $d([t2, e2, -100], [r3, n2, this.maximums[0] * a2], i2, s2);
          }
          raycast(t2, e2, r3, n2, i2, s2, a2 = 1) {
            if (!this.nodeCount) return null;
            const o2 = this.raycastRoot(t2, e2, r3, n2, i2, s2, a2);
            if (null == o2) return null;
            const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
            for (; p2.length > 0; ) {
              const { idx: o3, t: f2, nodex: d2, nodey: y2, depth: m2 } = p2.pop();
              if (this.leaves[o3]) {
                qd(d2, y2, m2, t2, e2, r3, n2, c2, h2);
                const o4 = 1 << m2, l3 = (d2 + 0) / o4, u3 = (d2 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x2 = Zd(l3, p3, this.dem) * a2, v2 = Zd(u3, p3, this.dem) * a2, b2 = Zd(u3, g3, this.dem) * a2, w2 = Zd(l3, g3, this.dem) * a2, _2 = Ud(c2[0], c2[1], x2, h2[0], c2[1], v2, h2[0], h2[1], b2, i2, s2), A2 = Ud(h2[0], h2[1], b2, c2[0], h2[1], w2, c2[0], c2[1], x2, i2, s2), S2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                if (S2 !== Number.MAX_VALUE) return S2;
                {
                  const t3 = Wo([], i2, s2, f2);
                  if (Gd(x2, v2, w2, b2, Od(t3[0], c2[0], h2[0]), Od(t3[1], c2[1], h2[1])) >= t3[2]) return f2;
                }
                continue;
              }
              let g2 = 0;
              for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                qd((d2 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m2 + 1, t2, e2, r3, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                const f3 = $d(c2, h2, i2, s2);
                if (null != f3) {
                  const t3 = f3;
                  l2[p3] = t3;
                  let e3 = false;
                  for (let r4 = 0; r4 < g2 && !e3; r4++) t3 >= l2[u2[r4]] && (u2.splice(r4, 0, p3), e3 = true);
                  e3 || (u2[g2] = p3), g2++;
                }
              }
              for (let t3 = 0; t3 < g2; t3++) {
                const e3 = u2[t3];
                p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m2 + 1 });
              }
            }
            return null;
          }
          _addNode(t2, e2, r3) {
            return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r3), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t2, e2, r3, n2, i2) {
            if (1 === t2[n2].isLeaf(e2, r3)) return;
            this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
            const s2 = n2 - 1, a2 = t2[s2];
            let o2 = 0, l2 = 0;
            for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
              const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r3 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
              u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
            }
            for (let n3 = 0; n3 < this._siblingOffset.length; n3++) o2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r3 + this._siblingOffset[n3][1], s2, l2 + n3);
          }
        }
        function Gd(t2, e2, r3, n2, i2, s2) {
          return Mr(Mr(t2, r3, s2), Mr(e2, n2, s2), i2);
        }
        function Zd(t2, e2, r3) {
          const n2 = r3.dim, i2 = S(t2 * n2 - 0.5, 0, n2 - 1), s2 = S(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
          return Gd(r3.get(a2, o2), r3.get(l2, o2), r3.get(a2, u2), r3.get(l2, u2), i2 - a2, s2 - o2);
        }
        const Xd = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function Kd(t2, e2, r3) {
          return (256 * t2 * 256 + 256 * e2 + r3) / 10 - 1e4;
        }
        function Yd(t2, e2, r3) {
          return 256 * t2 + e2 + r3 / 256 - 32768;
        }
        class Hd {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t2, e2, r3, n2 = false, i2 = false) {
            if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
            if (r3 && "mapbox" !== r3 && "terrarium" !== r3) return U(`"${r3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e2.height;
            const s2 = this.dim = e2.height - 2, a2 = new Uint32Array(e2.data.buffer);
            if (this.pixels = new Uint8Array(e2.data.buffer), this.encoding = r3 || "mapbox", this.borderReady = n2, !n2) {
              for (let t3 = 0; t3 < s2; t3++) a2[this._idx(-1, t3)] = a2[this._idx(0, t3)], a2[this._idx(s2, t3)] = a2[this._idx(s2 - 1, t3)], a2[this._idx(t3, -1)] = a2[this._idx(t3, 0)], a2[this._idx(t3, s2)] = a2[this._idx(t3, s2 - 1)];
              a2[this._idx(-1, -1)] = a2[this._idx(0, 0)], a2[this._idx(s2, -1)] = a2[this._idx(s2 - 1, 0)], a2[this._idx(-1, s2)] = a2[this._idx(0, s2 - 1)], a2[this._idx(s2, s2)] = a2[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
            }
          }
          _buildQuadTree() {
            this._tree = new Nd(this);
          }
          get(t2, e2, r3 = false) {
            r3 && (t2 = S(t2, -1, this.dim), e2 = S(e2, -1, this.dim));
            const n2 = 4 * this._idx(t2, e2);
            return ("terrarium" === this.encoding ? Yd : Kd)(this.pixels[n2], this.pixels[n2 + 1], this.pixels[n2 + 2]);
          }
          static getUnpackVector(t2) {
            return Xd[t2];
          }
          get unpackVector() {
            return Xd[this.encoding];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          static pack(t2, e2) {
            const r3 = [0, 0, 0, 0], n2 = Hd.getUnpackVector(e2);
            let i2 = Math.floor((t2 + n2[3]) / n2[2]);
            return r3[2] = i2 % 256, i2 = Math.floor(i2 / 256), r3[1] = i2 % 256, i2 = Math.floor(i2 / 256), r3[0] = i2, r3;
          }
          getPixels() {
            return new Qu({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t2, e2, r3) {
            if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r3 * this.dim, a2 = r3 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r3) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e2 * this.dim, l2 = -r3 * this.dim;
            for (let e3 = s2; e3 < a2; e3++) for (let r4 = n2; r4 < i2; r4++) {
              const n3 = 4 * this._idx(r4, e3), i3 = 4 * this._idx(r4 + o2, e3 + l2);
              this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
            }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        Oi(Hd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", { omit: ["dem"] });
        class Wd {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t2 in this.data) for (const e2 of this.data[t2]) e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, r3) {
            const n2 = t2.wrapped().key;
            void 0 === this.data[n2] && (this.data[n2] = []);
            const i2 = { value: e2, timeout: void 0 };
            if (void 0 !== r3 && (i2.timeout = setTimeout(() => {
              this.remove(t2, i2);
            }, r3)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            const e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2)) return this;
            const r3 = t2.wrapped().key, n2 = void 0 === e2 ? 0 : this.data[r3].indexOf(e2), i2 = this.data[r3][n2];
            return this.data[r3].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r3].length && delete this.data[r3], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r3), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e2 = [];
            for (const r3 in this.data) for (const n2 of this.data[r3]) t2(n2.value) || e2.push(n2);
            for (const t3 of e2) this.remove(t3.value.tileID, t3);
          }
        }
        class Jd {
          constructor(t2, e2, r3) {
            this.func = t2, this.mask = e2, this.range = r3;
          }
        }
        Jd.ReadOnly = false, Jd.ReadWrite = true, Jd.disabled = new Jd(519, Jd.ReadOnly, [0, 1]);
        const Qd = 7680;
        class ty {
          constructor(t2, e2, r3, n2, i2, s2) {
            this.test = t2, this.ref = e2, this.mask = r3, this.fail = n2, this.depthFail = i2, this.pass = s2;
          }
        }
        ty.disabled = new ty({ func: 519, mask: 0 }, 0, 0, Qd, Qd, Qd);
        class ey {
          constructor(t2, e2, r3) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = r3;
          }
        }
        ey.Replace = [1, 0], ey.disabled = new ey(ey.Replace, Me.transparent, [false, false, false, false]), ey.unblended = new ey(ey.Replace, Me.transparent, [true, true, true, true]), ey.alphaBlended = new ey([1, 771], Me.transparent, [true, true, true, true]);
        const ry = 1029, ny = 2305;
        class iy {
          constructor(t2, e2, r3) {
            this.enable = t2, this.mode = e2, this.frontFace = r3;
          }
        }
        iy.disabled = new iy(false, ry, ny), iy.backCCW = new iy(true, ry, ny), iy.backCW = new iy(true, ry, 2304), iy.frontCW = new iy(true, 1028, 2304), iy.frontCCW = new iy(true, 1028, ny);
        class sy extends Yt {
          constructor(t2, e2, r3) {
            super(), this.id = t2, this._onlySymbols = r3, e2.on("data", (t3) => {
              "source" === t3.dataType && "metadata" === t3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t3.dataType && "content" === t3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), e2.on("error", () => {
              this._sourceErrored = true;
            }), this._source = e2, this._tiles = {}, this._cache = new Wd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e2.minTileCacheSize, this._maxTileCacheSize = e2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(t2) {
            this.map = t2, this._minTileCacheSize = void 0 === this._minTileCacheSize && t2 ? t2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t2 ? t2._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if ("loaded" !== e2.state && "errored" !== e2.state) return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t2, e2) {
            return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
          }
          _unloadTile(t2) {
            if (this._source.unloadTile) return this._source.unloadTile(t2, () => {
            });
          }
          _abortTile(t2) {
            if (this._source.abortTile) return this._source.abortTile(t2, () => {
            });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const r3 = this._tiles[e2];
              r3.upload(t2), r3.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return T(this._tiles).map((t2) => t2.tileID).sort(ay).map((t2) => t2.key);
          }
          getRenderableIds(t2) {
            const e2 = [];
            for (const r3 in this._tiles) this._isIdRenderable(+r3, t2) && e2.push(this._tiles[r3]);
            return t2 ? e2.sort((t3, e3) => {
              const r3 = t3.tileID, n2 = e3.tileID, i2 = new d(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), s2 = new d(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
              return r3.overscaledZ - n2.overscaledZ || s2.y - i2.y || s2.x - i2.x;
            }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(ay).map((t3) => t3.key);
          }
          hasRenderableParent(t2) {
            const e2 = this.findLoadedParent(t2, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t2, e2) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t2 in this._tiles) "errored" !== this._tiles[t2].state && this._reloadTile(+t2, "reloading");
            }
          }
          _reloadTile(t2, e2) {
            const r3 = this._tiles[t2];
            r3 && ("loading" !== r3.state && (r3.state = e2), this._loadTile(r3, this._tileLoaded.bind(this, r3, t2, e2)));
          }
          _tileLoaded(t2, e2, r3, n2) {
            if (n2) if (t2.state = "errored", 404 !== n2.status) this._source.fire(new Kt(n2, { tile: t2 }));
            else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
              const t3 = this.map.painter.terrain;
              this.update(this.transform, t3.getScaledDemTileSize(), true), t3.resetTileLookupCache(this.id);
            } else this.update(this.transform);
            else t2.timeAdded = Nt.now(), "expired" === r3 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Xt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t2) {
            const e2 = this.getRenderableIds();
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
                const e3 = this.getTileByID(i2);
                r3(t2, e3), r3(e3, t2);
              }
            }
            function r3(t3, e3) {
              if (!t3.dem || t3.dem.borderReady) return;
              t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
              let r4 = e3.tileID.canonical.x - t3.tileID.canonical.x;
              const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
              0 === r4 && 0 === n2 || Math.abs(n2) > 1 || (Math.abs(r4) > 1 && (1 === Math.abs(r4 + i2) ? r4 += i2 : 1 === Math.abs(r4 - i2) && (r4 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r4, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e2, r3, n2) {
            for (const i2 in this._tiles) {
              let s2 = this._tiles[i2];
              if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r3) continue;
              let a2 = s2.tileID;
              for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
                const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
              }
              let o2 = a2;
              for (; o2.overscaledZ > e2; ) if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                n2[a2.key] = a2;
                break;
              }
            }
          }
          findLoadedParent(t2, e2) {
            if (t2.key in this._loadedParentTiles) {
              const r3 = this._loadedParentTiles[t2.key];
              return r3 && r3.tileID.overscaledZ >= e2 ? r3 : null;
            }
            for (let r3 = t2.overscaledZ - 1; r3 >= e2; r3--) {
              const e3 = t2.scaledTo(r3), n2 = this._getLoadedTile(e3);
              if (n2) return n2;
            }
          }
          _getLoadedTile(t2) {
            const e2 = this._tiles[t2.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
          }
          updateCacheSize(t2, e2) {
            e2 = e2 || this._source.tileSize;
            const r3 = Math.ceil(t2.width / e2) + 1, n2 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r3 * n2 * 5), s2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i2) : i2, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
            this._cache.setMaxSize(a2);
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e2) {
              const t3 = {};
              for (const r3 in this._tiles) {
                const n2 = this._tiles[r3];
                n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), t3[n2.tileID.key] = n2;
              }
              this._tiles = t3;
              for (const t4 in this._timers) clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (const t4 in this._tiles) this._setTileReloadTimer(+t4, this._tiles[t4]);
            }
          }
          update(t2, e2, r3) {
            if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
            if (this.usedForTerrain && !r3) return;
            let n2;
            this.updateCacheSize(t2, e2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Mh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n2 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t3) => this._source.hasTile(t3)))) : n2 = [];
            const i2 = this._updateRetainedTiles(n2);
            if (oy(this._source.type) && 0 !== n2.length) {
              const t3 = {}, e3 = {}, r4 = Object.keys(i2);
              for (const n3 of r4) {
                const r5 = i2[n3], s4 = this._tiles[n3];
                if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= Nt.now()) continue;
                const a2 = this.findLoadedParent(r5, Math.max(r5.overscaledZ - sy.maxOverzooming, this._source.minzoom));
                a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n3] = r5;
              }
              const s3 = n2[n2.length - 1].overscaledZ;
              for (const t4 in this._tiles) {
                const r5 = this._tiles[t4];
                if (i2[t4] || !r5.hasData()) continue;
                let n3 = r5.tileID;
                for (; n3.overscaledZ > s3; ) {
                  n3 = n3.scaledTo(n3.overscaledZ - 1);
                  const s4 = this._tiles[n3.key];
                  if (s4 && s4.hasData() && e3[n3.key]) {
                    i2[t4] = r5.tileID;
                    break;
                  }
                }
              }
              for (const e4 in t3) i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
            }
            for (const t3 in i2) this._tiles[t3].clearFadeHold();
            const s2 = function(t3, e3) {
              const r4 = [];
              for (const n3 in t3) n3 in e3 || r4.push(n3);
              return r4;
            }(this._tiles, i2);
            for (const t3 of s2) {
              const e3 = this._tiles[t3];
              e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t2 in this._tiles) this._tiles[t2].holdingForFade() && this._removeTile(+t2);
          }
          _updateRetainedTiles(t2) {
            const e2 = {};
            if (0 === t2.length) return e2;
            const r3 = {}, n2 = t2.reduce((t3, e3) => Math.min(t3, e3.overscaledZ), 1 / 0), i2 = t2[0].overscaledZ, s2 = Math.max(i2 - sy.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + sy.maxUnderzooming, this._source.minzoom), o2 = {};
            for (const r4 of t2) {
              const t3 = this._addTile(r4);
              e2[r4.key] = r4, t3.hasData() || n2 < this._source.maxzoom && (o2[r4.key] = r4);
            }
            this._retainLoadedChildren(o2, n2, a2, e2);
            for (const n3 of t2) {
              let t3 = this._tiles[n3.key];
              if (t3.hasData()) continue;
              if (n3.canonical.z >= this._source.maxzoom) {
                const t4 = n3.children(this._source.maxzoom)[0], r4 = this.getTile(t4);
                if (r4 && r4.hasData()) {
                  e2[t4.key] = t4;
                  continue;
                }
              } else {
                const t4 = n3.children(this._source.maxzoom);
                if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key]) continue;
              }
              let i3 = t3.wasRequested();
              for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
                const s3 = n3.scaledTo(a3);
                if (r3[s3.key]) break;
                if (r3[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e2[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData())) break;
              }
            }
            return e2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t2 in this._tiles) {
              const e2 = [];
              let r3, n2 = this._tiles[t2].tileID;
              for (; n2.overscaledZ > 0; ) {
                if (n2.key in this._loadedParentTiles) {
                  r3 = this._loadedParentTiles[n2.key];
                  break;
                }
                e2.push(n2.key);
                const t3 = n2.scaledTo(n2.overscaledZ - 1);
                if (r3 = this._getLoadedTile(t3), r3) break;
                n2 = t3;
              }
              for (const t3 of e2) this._loadedParentTiles[t3] = r3;
            }
          }
          _addTile(t2) {
            let e2 = this._tiles[t2.key];
            if (e2) return e2;
            e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
            const r3 = Boolean(e2);
            if (!r3) {
              const r4 = this.map ? this.map.painter : null;
              e2 = new Fd(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom, r4, this._isRaster), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state));
            }
            return e2 ? (e2.uses++, this._tiles[t2.key] = e2, r3 || this._source.fire(new Xt("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
          }
          _setTileReloadTimer(t2, e2) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            const r3 = e2.getExpiryTimeout();
            r3 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, r3));
          }
          _removeTile(t2) {
            const e2 = this._tiles[t2];
            e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t2 in this._tiles) this._removeTile(+t2);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t2, e2, r3) {
            const n2 = [], i2 = this.transform;
            if (!i2) return n2;
            const s2 = "globe" === i2.projection.name, a2 = iu(i2.center.lng);
            for (const o2 in this._tiles) {
              const l2 = this._tiles[o2];
              if (r3 && l2.clearQueryDebugViz(), l2.holdingForFade()) continue;
              let u2;
              if (s2) {
                const t3 = l2.tileID.canonical;
                if (0 === t3.z) {
                  const e3 = [Math.abs(S(a2, ...ly(t3, -1)) - a2), Math.abs(S(a2, ...ly(t3, 1)) - a2)];
                  u2 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
                } else {
                  const e3 = [Math.abs(S(a2, ...ly(t3, -1)) - a2), Math.abs(S(a2, ...ly(t3, 0)) - a2), Math.abs(S(a2, ...ly(t3, 1)) - a2)];
                  u2 = [e3.indexOf(Math.min(...e3)) - 1];
                }
              } else u2 = [0];
              for (const r4 of u2) {
                const s3 = t2.containsTile(l2, i2, e2, r4);
                s3 && n2.push(s3);
              }
            }
            return n2;
          }
          getVisibleCoordinates(t2) {
            const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (const t3 of e2) t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (oy(this._source.type)) for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if (void 0 !== e2.fadeEndTime && e2.fadeEndTime >= Nt.now()) return true;
            }
            return false;
          }
          setFeatureState(t2, e2, r3) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r3);
          }
          removeFeatureState(t2, e2, r3) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r3);
          }
          getFeatureState(t2, e2) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
          }
          setDependencies(t2, e2, r3) {
            const n2 = this._tiles[t2];
            n2 && n2.setDependencies(e2, r3);
          }
          reloadTilesForDependencies(t2, e2) {
            for (const r3 in this._tiles) this._tiles[r3].hasDependency(t2, e2) && this._reloadTile(+r3, "reloading");
            this._cache.filter((r3) => !r3.hasDependency(t2, e2));
          }
          _preloadTiles(t2, e2) {
            const r3 = /* @__PURE__ */ new Map(), n2 = Array.isArray(t2) ? t2 : [t2], i2 = this.map.painter.terrain, s2 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
            for (const t3 of n2) {
              const e3 = t3.coveringTiles({ tileSize: s2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const t4 of e3) r3.set(t4.key, t4);
              this.usedForTerrain && t3.updateElevation(false);
            }
            M(Array.from(r3.values()), (t3, e3) => {
              const r4 = new Fd(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(r4, (t4) => {
                "raster-dem" === this._source.type && r4.dem && this._backfillDEM(r4), e3(t4, r4);
              });
            }, e2);
          }
        }
        function ay(t2, e2) {
          const r3 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || n2 - r3 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function oy(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2 || "custom" === t2;
        }
        function ly(t2, e2) {
          const r3 = 1 << t2.z;
          return [t2.x / r3 + e2, (t2.x + 1) / r3 + e2];
        }
        sy.maxOverzooming = 10, sy.maxUnderzooming = 3;
        class uy {
          constructor(t2, e2, r3) {
            this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r3;
          }
          static create(t2, e2, r3) {
            const n2 = r3 || t2.findDEMTileFor(e2);
            if (!n2 || !n2.dem) return;
            const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
            return new uy(n2, n2.tileSize / ko / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
          }
          tileCoordToPixel(t2, e2) {
            const r3 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r3);
            return new d(n2, i2);
          }
          getElevationAt(t2, e2, r3, n2) {
            const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
            return n2 = !!n2, r3 ? Mr(Mr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), Mr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
          }
          getElevationAtPixel(t2, e2, r3) {
            return this._dem.get(t2, e2, !!r3);
          }
          getMeterToDEM(t2) {
            return (1 << this._demTile.tileID.canonical.z) * au(1, t2) * this._dem.stride;
          }
        }
        class cy {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja(), this.promoteId = e2;
          }
          insert(t2, e2, r3, n2, i2, s2 = 0) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r3, n2, i2, s2);
            const o2 = this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r4 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r4.length; t4++) {
                const e3 = r4[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < ko && n3[1] < ko && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t2 in this.vtLayers) this.vtFeatures[t2] = [];
            }
            return this.vtLayers;
          }
          query(t2, e2, r3, n2) {
            this.loadVTLayers();
            const i2 = t2.params || {}, s2 = ai(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r4, n3) => Vu(a2.bufferedTilespaceGeometry, t3, e3, r4, n3));
            u2.sort(py);
            let c2 = null;
            o2.elevation && u2.length > 0 && (c2 = uy.create(o2.elevation, this.tileID));
            const h2 = {};
            let p2;
            for (let o3 = 0; o3 < u2.length; o3++) {
              const l3 = u2[o3];
              if (l3 === p2) continue;
              p2 = l3;
              const f2 = this.featureIndexArray.get(l3);
              let d2 = null;
              this.loadMatchingFeature(h2, f2, s2, i2.layers, i2.availableImages, e2, r3, n2, (e3, r4, n3, i3 = 0) => (d2 || (d2 = bu(e3, this.tileID.canonical, t2.tileTransform)), r4.queryIntersectsFeature(a2, e3, n3, d2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
            }
            return h2;
          }
          loadMatchingFeature(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
            const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = e2, f2 = this.bucketLayerIDs[c2];
            if (n2 && !function(t3, e3) {
              for (let r4 = 0; r4 < t3.length; r4++) if (e3.indexOf(t3[r4]) >= 0) return true;
              return false;
            }(n2, f2)) return;
            const d2 = this.sourceLayerCoder.decode(h2), y2 = this.vtLayers[d2].feature(u2);
            if (r3.needGeometry) {
              const t3 = wu(y2, true);
              if (!r3.filter(new $s(this.tileID.overscaledZ), t3, this.tileID.canonical)) return;
            } else if (!r3.filter(new $s(this.tileID.overscaledZ), y2)) return;
            const m2 = this.getId(y2, d2);
            for (let e3 = 0; e3 < f2.length; e3++) {
              const r4 = f2[e3];
              if (n2 && n2.indexOf(r4) < 0) continue;
              const c3 = s2[r4];
              if (!c3) continue;
              let h3 = {};
              void 0 !== m2 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m2));
              const d3 = z({}, a2[r4]);
              d3.paint = hy(d3.paint, c3.paint, y2, h3, i2), d3.layout = hy(d3.layout, c3.layout, y2, h3, i2);
              const g2 = !l2 || l2(y2, c3, h3, p2);
              if (!g2) continue;
              const x2 = new Md(y2, this.z, this.x, this.y, m2);
              x2.layer = d3;
              let v2 = t2[r4];
              void 0 === v2 && (v2 = t2[r4] = []), v2.push({ featureIndex: u2, feature: x2, intersectionZ: g2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r3, n2, i2, s2, a2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = ai(i2);
            for (const i3 of t2) this.loadMatchingFeature(l2, { bucketIndex: r3, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
            return l2;
          }
          loadFeature(t2) {
            const { featureIndex: e2, sourceLayerIndex: r3 } = t2;
            this.loadVTLayers();
            const n2 = this.sourceLayerCoder.decode(r3), i2 = this.vtFeatures[n2];
            if (i2[e2]) return i2[e2];
            const s2 = this.vtLayers[n2].feature(e2);
            return i2[e2] = s2, s2;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs) for (const r3 of e2) if (t2 === r3) return true;
            return false;
          }
          getId(t2, e2) {
            let r3 = t2.id;
            if (this.promoteId) {
              const n2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2];
              null != n2 && (r3 = t2.properties[n2]), "boolean" == typeof r3 && (r3 = Number(r3));
            }
            return r3;
          }
        }
        function hy(t2, e2, r3, n2, i2) {
          return F(t2, (t3, s2) => {
            const a2 = e2 instanceof Ks ? e2.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r3, n2, i2) : a2;
          });
        }
        function py(t2, e2) {
          return e2 - t2;
        }
        Oi(cy, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        class fy {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.image = new Ju({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t2, e2) {
            const r3 = this.getKey(t2, e2);
            return this.positions[r3];
          }
          trim() {
            const t2 = this.width, e2 = this.height = P(this.nextRow);
            this.image.resize({ width: t2, height: e2 });
          }
          getKey(t2, e2) {
            return t2.join(",") + e2;
          }
          getDashRanges(t2, e2, r3) {
            const n2 = [];
            let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r3 : 0, s2 = t2[0] * r3, a2 = true;
            n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
            let o2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              a2 = !a2;
              const l2 = t2[e3];
              i2 = o2 * r3, o2 += l2, s2 = o2 * r3, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
            }
            return n2;
          }
          addRoundDash(t2, e2, r3) {
            const n2 = e2 / 2;
            for (let e3 = -r3; e3 <= r3; e3++) {
              const i2 = this.width * (this.nextRow + r3 + e3);
              let s2 = 0, a2 = t2[s2];
              for (let o2 = 0; o2 < this.width; o2++) {
                o2 / a2.right > 1 && (a2 = t2[++s2]);
                const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                let h2;
                const p2 = e3 / r3 * (n2 + 1);
                if (a2.isDash) {
                  const t3 = n2 - Math.abs(p2);
                  h2 = Math.sqrt(c2 * c2 + t3 * t3);
                } else h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
              }
            }
          }
          addRegularDash(t2, e2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              const r4 = t2[e3], n3 = t2[e3 + 1];
              r4.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r4.isDash && (n3.left = r4.left, t2.splice(e3, 1));
            }
            const r3 = t2[0], n2 = t2[t2.length - 1];
            r3.isDash === n2.isDash && (r3.left = n2.left - this.width, n2.right = r3.right + this.width);
            const i2 = this.width * this.nextRow;
            let s2 = 0, a2 = t2[s2];
            for (let r4 = 0; r4 < this.width; r4++) {
              r4 / a2.right > 1 && (a2 = t2[++s2]);
              const n3 = Math.abs(r4 - a2.left), o2 = Math.abs(r4 - a2.right), l2 = Math.min(n3, o2);
              this.image.data[i2 + r4] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
            }
          }
          addDash(t2, e2) {
            const r3 = this.getKey(t2, e2);
            if (this.positions[r3]) return this.positions[r3];
            const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
            if (this.nextRow + s2 > this.height) return U("LineAtlas out of space"), null;
            0 === t2.length && t2.push(1);
            let a2 = 0;
            for (let e3 = 0; e3 < t2.length; e3++) t2[e3] < 0 && (U("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
            if (0 !== a2) {
              const r4 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r4);
              n2 ? this.addRoundDash(s3, r4, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r4 : 0);
            }
            const o2 = this.nextRow + i2;
            this.nextRow += s2;
            const l2 = { tl: [o2, i2], br: [a2, 0] };
            return this.positions[r3] = l2, l2;
          }
        }
        Oi(fy, "LineAtlas");
        class dy {
          constructor(t2) {
            const e2 = {}, r3 = [];
            for (const n3 in t2) {
              const i3 = t2[n3], s3 = e2[n3] = {};
              for (const t3 in i3.glyphs) {
                const e3 = i3.glyphs[+t3];
                if (!e3 || 0 === e3.bitmap.width || 0 === e3.bitmap.height) continue;
                const n4 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
                r3.push(a2), s3[t3] = a2;
              }
            }
            const { w: n2, h: i2 } = Cp(r3), s2 = new Ju({ width: n2 || 1, height: i2 || 1 });
            for (const r4 in t2) {
              const n3 = t2[r4];
              for (const t3 in n3.glyphs) {
                const i3 = n3.glyphs[+t3];
                if (!i3 || 0 === i3.bitmap.width || 0 === i3.bitmap.height) continue;
                const a2 = e2[r4][t3], o2 = i3.metrics.localGlyph ? 2 : 1;
                Ju.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
              }
            }
            this.image = s2, this.positions = e2;
          }
        }
        Oi(dy, "GlyphAtlas");
        class yy {
          constructor(t2) {
            this.tileID = new Mh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = Vf(t2.tileID.canonical, t2.projection), this.projection = t2.projection;
          }
          parse(t2, e2, r3, n2, i2) {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new Ea();
            const s2 = new kd(Object.keys(t2.layers).sort()), a2 = new cy(this.tileID, this.promoteId);
            a2.bucketLayerIDs = [];
            const o2 = {}, l2 = new fy(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r3 }, c2 = e2.familiesBySource[this.source];
            for (const e3 in c2) {
              const n3 = t2.layers[e3];
              if (!n3) continue;
              let i3 = false, l3 = false;
              for (const t3 of c2[e3]) "symbol" === t3[0].type ? i3 = true : l3 = true;
              if (true === this.isSymbolTile && !i3) continue;
              if (false === this.isSymbolTile && !l3) continue;
              1 === n3.version && U(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const h3 = s2.encode(e3), p3 = [];
              for (let t3 = 0; t3 < n3.length; t3++) {
                const r4 = n3.feature(t3), i4 = a2.getId(r4, e3);
                p3.push({ feature: r4, id: i4, index: t3, sourceLayerIndex: h3 });
              }
              for (const t3 of c2[e3]) {
                const e4 = t3[0];
                void 0 !== this.isSymbolTile && "symbol" === e4.type !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || "none" !== e4.visibility && (my(t3, this.zoom, r3), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h3, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r3 })).populate(p3, u2, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
              }
            }
            let h2, p2, f2, d2;
            l2.trim();
            const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m2 = F(u2.glyphDependencies, (t3) => Object.keys(t3).map(Number));
            Object.keys(m2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m2 }, (t3, e3) => {
              h2 || (h2 = t3, p2 = e3, v2.call(this));
            }, void 0, false, y2) : p2 = {};
            const g2 = Object.keys(u2.iconDependencies);
            g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
              h2 || (h2 = t3, f2 = e3, v2.call(this));
            }, void 0, false, y2) : f2 = {};
            const x2 = Object.keys(u2.patternDependencies);
            function v2() {
              if (h2) return i2(h2);
              if (p2 && f2 && d2) {
                const t3 = new dy(p2), e3 = new Dp(f2, d2);
                for (const n3 in o2) {
                  const i3 = o2[n3];
                  i3 instanceof hd ? (my(i3.layers, this.zoom, r3), kf(i3, p2, t3.positions, f2, e3.iconPositions, this.showCollisionBoxes, r3, this.tileID.canonical, this.tileZoom, this.projection)) : i3.hasPattern && (i3 instanceof jh || i3 instanceof $c || i3 instanceof fh) && (my(i3.layers, this.zoom, r3), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions, r3, this.tileTransform));
                }
                this.status = "done", i2(null, { buckets: T(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
              }
            }
            x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
              h2 || (h2 = t3, d2 = e3, v2.call(this));
            }, void 0, false, y2) : d2 = {}, v2.call(this);
          }
        }
        function my(t2, e2, r3) {
          const n2 = new $s(e2);
          for (const e3 of t2) e3.recalculate(n2, r3);
        }
        class gy {
          constructor(t2) {
            this.entries = {}, this.scheduler = t2;
          }
          request(t2, e2, r3, n2) {
            const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
            if (i2.result) {
              const [t3, r4] = i2.result;
              return this.scheduler ? this.scheduler.add(() => {
                n2(t3, r4);
              }, e2) : n2(t3, r4), () => {
              };
            }
            return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r3((r4, n3) => {
              i2.result = [r4, n3];
              for (const t3 of i2.callbacks) this.scheduler ? this.scheduler.add(() => {
                t3(r4, n3);
              }, e2) : t3(r4, n3);
              setTimeout(() => delete this.entries[t2], 3e3);
            })), () => {
              i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
            };
          }
        }
        function xy(t2, e2, r3) {
          const n2 = JSON.stringify(t2.request);
          return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
            const n3 = ut(t2.request, (t3, n4, i2, s2) => {
              t3 ? e3(t3) : n4 && e3(null, { vectorTile: r3 ? void 0 : new sh(new op(n4)), rawData: n4, cacheControl: i2, expires: s2 });
            });
            return () => {
              n3.cancel(), e3();
            };
          }, e2);
        }
        t.ARRAY_TYPE = To, t.AUTH_ERR_MSG = yt, t.Aabb = _l, t.Actor = class {
          constructor(t2, r3, n2) {
            this.target = t2, this.parent = r3, this.mapId = n2, this.callbacks = {}, this.cancelCallbacks = {}, V(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = N() ? t2 : e, this.scheduler = new Sd();
          }
          send(t2, e2, r3, n2, i2 = false, s2) {
            const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r3 && (r3.metadata = s2, this.callbacks[a2] = r3);
            const o2 = X(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r3, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Gi(e2, o2) }, o2), { cancel: () => {
              r3 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          receive(t2) {
            const e2 = t2.data, r3 = e2.id;
            if (r3 && (!e2.targetMapId || this.mapId === e2.targetMapId)) if ("<cancel>" === e2.type) {
              const t3 = this.cancelCallbacks[r3];
              delete this.cancelCallbacks[r3], t3 && t3.cancel();
            } else if (e2.mustQueue || N()) {
              const t3 = this.callbacks[r3];
              this.cancelCallbacks[r3] = this.scheduler.add(() => this.processTask(r3, e2), t3 && t3.metadata || { type: "message" });
            } else this.processTask(r3, e2);
          }
          processTask(t2, e2) {
            if ("<response>" === e2.type) {
              const r3 = this.callbacks[t2];
              delete this.callbacks[t2], r3 && (e2.error ? r3(Zi(e2.error)) : r3(null, Zi(e2.data)));
            } else {
              const r3 = X(this.globalScope) ? void 0 : [], n2 = e2.hasCallback ? (e3, n3) => {
                delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Gi(e3) : null, data: Gi(n3, r3) }, r3);
              } : (t3) => {
              }, i2 = Zi(e2.data);
              if (this.parent[e2.type]) this.parent[e2.type](e2.sourceMapId, i2, n2);
              else if (this.parent.getWorkerSource) {
                const t3 = e2.type.split(".");
                this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n2);
              } else n2(new Error(`Could not find function ${e2.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t.CanonicalTileID = kh, t.Color = Me, t.ColorMode = ey, t.CullFaceMode = iy, t.DEMData = Hd, t.DataConstantProperty = Ys, t.DedupedRequest = gy, t.DepthMode = Jd, t.EXTENT = ko, t.Elevation = class {
          isDataAvailableAtPoint(t2) {
            const e2 = this._source();
            if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1) return false;
            const r3 = e2.getSource().maxzoom, n2 = 1 << r3, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new Mh(r3, i2, r3, s2, a2));
            return !(!o2 || !o2.dem);
          }
          getAtPointOrZero(t2, e2 = 0) {
            return this.getAtPoint(t2, e2) || 0;
          }
          getAtPoint(t2, e2, r3 = true) {
            if (this.isUsingMockSource()) return null;
            null == e2 && (e2 = null);
            const n2 = this._source();
            if (!n2) return e2;
            if (t2.y < 0 || t2.y > 1) return e2;
            const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Mh(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
            if (!u2 || !u2.dem) return e2;
            const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, f2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), y2 = Math.floor(f2);
            return (r3 ? this.exaggeration() : 1) * Mr(Mr(c2.get(d2, y2), c2.get(d2, y2 + 1), f2 - y2), Mr(c2.get(d2 + 1, y2), c2.get(d2 + 1, y2 + 1), f2 - y2), p2 - d2);
          }
          getAtTileOffset(t2, e2, r3) {
            const n2 = 1 << t2.canonical.z;
            return this.getAtPointOrZero(new pu(t2.wrap + (t2.canonical.x + e2 / ko) / n2, (t2.canonical.y + r3 / ko) / n2));
          }
          getAtTileOffsetFunc(t2, e2, r3, n2) {
            return (i2) => {
              const s2 = this.getAtTileOffset(t2, i2.x, i2.y), a2 = n2.upVector(t2.canonical, i2.x, i2.y);
              return Ho(a2, a2, s2 * n2.upVectorScale(t2.canonical, e2, r3).metersToTile), a2;
            };
          }
          getForTilePoints(t2, e2, r3, n2) {
            if (this.isUsingMockSource()) return false;
            const i2 = uy.create(this, t2, n2);
            return !!i2 && (e2.forEach((t3) => {
              t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r3);
            }), true);
          }
          getMinMaxForTile(t2) {
            if (this.isUsingMockSource()) return null;
            const e2 = this.findDEMTileFor(t2);
            if (!e2 || !e2.dem) return null;
            const r3 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
            let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
            for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r3.leaves[o2]; e3++) {
              s2 *= 2, a2 *= 2;
              const t3 = 2 * Math.floor(a2) + Math.floor(s2);
              o2 = r3.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
            }
            return { min: this.exaggeration() * r3.minimums[o2], max: this.exaggeration() * r3.maximums[o2] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t2, e2, r3) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t2) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t2) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
        }, t.ErrorEvent = Kt, t.EvaluationParameters = $s, t.Event = Xt, t.Evented = Yt, t.FillExtrusionBucket = fh, t.Frustum = wl, t.FrustumCorners = bl, t.GLOBE_RADIUS = Al, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = 6, t.GLOBE_ZOOM_THRESHOLD_MIN = 5, t.GlobeSharedBuffers = class {
          constructor(t2) {
            this._createGrid(t2), this._createPoles(t2);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t2 of this._poleSegments) t2.destroy();
            for (const t2 of this._gridSegments) t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
            if (this._wireframeIndexBuffer) {
              this._wireframeIndexBuffer.destroy();
              for (const t2 of this._wireframeSegments) t2.destroy();
            }
          }
          _fillGridMeshWithLods(t2, e2) {
            const r3 = new sa(), n2 = new wa(), i2 = [], s2 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r4) => {
              let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
              return n3 += r4 ? 24575 : 0, [n3, e3];
            };
            for (let t3 = 0; t3 < s2; ++t3) r3.emplaceBack(...l2(t3, 0, true));
            for (let t3 = 0; t3 < a2; ++t3) for (let e3 = 0; e3 < s2; ++e3) r3.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const n3 = e2[t3];
              for (let t4 = 0; t4 < s2; ++t4) r3.emplaceBack(...l2(t4, n3, true));
            }
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const a3 = n2.length, l3 = e2[t3] + 1 + 2, u2 = new wa();
              for (let r4 = 0; r4 < l3 - 1; r4++) {
                const i3 = r4 === l3 - 2, a4 = i3 ? s2 * (o2 - e2.length + t3 - r4) : s2;
                for (let t4 = 0; t4 < s2 - 1; t4++) {
                  const e3 = r4 * s2 + t4;
                  0 === r4 || i3 || 0 === t4 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
                }
              }
              const c2 = So.simpleSegment(0, a3, r3.length, n2.length - a3);
              for (let t4 = 0; t4 < u2.uint16.length; t4 += 3) n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
              const h2 = So.simpleSegment(0, a3, r3.length, n2.length - a3);
              i2.push({ withoutSkirts: c2, withSkirts: h2 });
            }
            return { vertices: r3, indices: n2, segments: i2 };
          }
          _createGrid(t2) {
            const e2 = this._fillGridMeshWithLods(Sl, kl);
            this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, xl.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
          }
          _createPoles(t2) {
            const e2 = new wa();
            for (let t3 = 0; t3 <= Sl; t3++) e2.emplaceBack(0, t3 + 1, t3 + 2);
            this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
            const r3 = new ka(), n2 = new ka();
            this._poleSegments = [];
            for (let t3 = 0, e3 = 0; t3 < 5; t3++) {
              const i2 = 360 / (1 << t3);
              r3.emplaceBack(0, -Al, 0, 0.5, 0), n2.emplaceBack(0, -Al, 0, 0.5, 1);
              for (let t4 = 0; t4 <= Sl; t4++) {
                const e4 = t4 / Sl, s2 = Mr(0, i2, e4), [a2, o2, l2] = $l(Jl, Ql, s2, Al);
                r3.emplaceBack(a2, o2, l2, e4, 0), n2.emplaceBack(a2, o2, l2, e4, 1);
              }
              this._poleSegments.push(So.simpleSegment(e3, 0, 66, 64)), e3 += 66;
            }
            this._poleNorthVertexBuffer = t2.createVertexBuffer(r3, ml, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, ml, false);
          }
          getGridBuffers(t2, e2) {
            return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
          }
          getPoleBuffers(t2) {
            return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
          }
          getWirefameBuffers(t2, e2) {
            if (!this._wireframeSegments) {
              const e3 = new Ma(), r3 = Sl, n2 = r3 + 1 + 2, i2 = 1;
              this._wireframeSegments = [];
              for (let t3 = 0, s2 = 0; t3 < kl.length; t3++) {
                const a2 = kl[t3];
                for (let t4 = i2; t4 < a2 + i2; t4++) for (let s3 = i2; s3 < r3 + i2; s3++) {
                  const r4 = t4 * n2 + s3;
                  e3.emplaceBack(r4, r4 + 1), e3.emplaceBack(r4, r4 + n2), e3.emplaceBack(r4, r4 + n2 + 1);
                }
                const o2 = a2 * r3 * 3;
                this._wireframeSegments.push(So.simpleSegment(0, s2, (a2 + 1) * n2, o2)), s2 += o2;
              }
              this._wireframeIndexBuffer = t2.createIndexBuffer(e3);
            }
            return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e2]];
          }
        }, t.GlyphManager = cf, t.ImagePosition = Pp, t.LivePerformanceUtils = Lt, t.LngLat = ru, t.LngLatBounds = Io, t.LocalGlyphMode = uf, t.MAX_MERCATOR_LATITUDE = cu, t.MercatorCoordinate = pu, t.ONE_EM = Wh, t.OverscaledTileID = Mh, t.PerformanceMarkers = Vt, t.Properties = Js, t.RGBAImage = Qu, t.Ray = vl, t.RequestManager = class {
          constructor(t2, e2, r3) {
            this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r3, this._createSkuToken();
          }
          _createSkuToken() {
            const t2 = function() {
              let t3 = "";
              for (let e2 = 0; e2 < 10; e2++) t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", h, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }
          normalizeStyleURL(t2, e2) {
            if (!mt(t2)) return t2;
            const r3 = _t(t2);
            return r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
          }
          normalizeGlyphsURL(t2, e2) {
            if (!mt(t2)) return t2;
            const r3 = _t(t2);
            return r3.path = `/fonts/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e2);
          }
          normalizeSourceURL(t2, e2, r3, n2) {
            if (!mt(t2)) return t2;
            const i2 = _t(t2);
            return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r3 && i2.params.push(`language=${r3}`), n2 && i2.params.push(`worldview=${n2}`), this._makeAPIURL(i2, this._customAccessToken || e2);
          }
          normalizeSpriteURL(t2, e2, r3, n2) {
            const i2 = _t(t2);
            return mt(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r3}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e2}${r3}`, At(i2));
          }
          normalizeTileURL(t2, e2, r3) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !mt(t2)) return t2;
            const n2 = _t(t2);
            n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r3 && "raster" !== n2.authority && 512 === r3 ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n2.authority ? n2.path = `/${i.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${i.TILE_URL_VERSION}${n2.path}`);
            const a2 = this._customAccessToken || function(t3) {
              for (const e3 of t3) {
                const t4 = e3.match(/^access_token=(.*)$/);
                if (t4) return t4[1];
              }
              return null;
            }(n2.params) || i.ACCESS_TOKEN;
            return i.REQUIRE_ACCESS_TOKEN && a2 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, a2);
          }
          canonicalizeTileURL(t2, e2) {
            const r3 = _t(t2);
            if (!r3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r3.path.match(/\.[\w]+$/)) return t2;
            let n2 = "mapbox://";
            r3.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r3.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r3.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
            let s2 = r3.params;
            return e2 && (s2 = s2.filter((t3) => !t3.match(/^access_token=/))), s2.length && (n2 += `?${s2.join("&")}`), n2;
          }
          canonicalizeTileset(t2, e2) {
            const r3 = !!e2 && mt(e2), n2 = [];
            for (const e3 of t2.tiles || []) gt(e3) ? n2.push(this.canonicalizeTileURL(e3, r3)) : n2.push(e3);
            return n2;
          }
          _makeAPIURL(t2, e2) {
            const r3 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n2 = _t(i.API_URL);
            if (t2.protocol = n2.protocol, t2.authority = n2.authority, "http" === t2.protocol) {
              const e3 = t2.params.indexOf("secure");
              e3 >= 0 && t2.params.splice(e3, 1);
            }
            if ("/" !== n2.path && (t2.path = `${n2.path}${t2.path}`), !i.REQUIRE_ACCESS_TOKEN) return At(t2);
            if (e2 = e2 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e2) throw new Error(`An API access token is required to use Mapbox GL. ${r3}`);
              if ("s" === e2[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r3}`);
            }
            return t2.params = t2.params.filter((t3) => -1 === t3.indexOf("access_token")), t2.params.push(`access_token=${e2 || ""}`), At(t2);
          }
        }, t.ResourceType = st, t.SegmentVector = So, t.SourceCache = sy, t.StencilMode = ty, t.StructArrayLayout1ui2 = Ta, t.StructArrayLayout2f1f2i16 = xa, t.StructArrayLayout2i4 = sa, t.StructArrayLayout2ui4 = Ma, t.StructArrayLayout3f12 = ba, t.StructArrayLayout3ui6 = wa, t.StructArrayLayout4i8 = oa, t.StructArrayLayout5f20 = ka, t.Texture = _d, t.Tile = Fd, t.Transitionable = qs, t.Uniform1f = to, t.Uniform1i = class extends Qa {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && this.current !== r3 && (this.current = r3, this.gl.uniform1i(this.location, r3));
          }
        }, t.Uniform2f = class extends Qa {
          constructor(t2) {
            super(t2), this.current = [0, 0];
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] || (this.current = r3, this.gl.uniform2f(this.location, r3[0], r3[1])));
          }
        }, t.Uniform3f = class extends Qa {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0];
          }
          set(t2, e2, r3) {
            this.fetchUniformLocation(t2, e2) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] || (this.current = r3, this.gl.uniform3f(this.location, r3[0], r3[1], r3[2])));
          }
        }, t.Uniform4f = eo, t.UniformColor = ro, t.UniformMatrix2f = class extends Qa {
          constructor(t2) {
            super(t2), this.current = so;
          }
          set(t2, e2, r3) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 4; t3++) if (r3[t3] !== this.current[t3]) {
                this.current = r3, this.gl.uniformMatrix2fv(this.location, false, r3);
                break;
              }
            }
          }
        }, t.UniformMatrix3f = class extends Qa {
          constructor(t2) {
            super(t2), this.current = io;
          }
          set(t2, e2, r3) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 9; t3++) if (r3[t3] !== this.current[t3]) {
                this.current = r3, this.gl.uniformMatrix3fv(this.location, false, r3);
                break;
              }
            }
          }
        }, t.UniformMatrix4f = class extends Qa {
          constructor(t2) {
            super(t2), this.current = no;
          }
          set(t2, e2, r3) {
            if (this.fetchUniformLocation(t2, e2)) {
              if (r3[12] !== this.current[12] || r3[0] !== this.current[0]) return this.current = r3, void this.gl.uniformMatrix4fv(this.location, false, r3);
              for (let t3 = 1; t3 < 16; t3++) if (r3[t3] !== this.current[t3]) {
                this.current = r3, this.gl.uniformMatrix4fv(this.location, false, r3);
                break;
              }
            }
          }
        }, t.UnwrappedTileID = Ih, t.ValidationError = Wn, t.VectorTileFeature = ah, t.VectorTileWorkerSource = class extends Yt {
          constructor(t2, e2, r3, n2, i2) {
            super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r3, this.loadVectorData = i2 || xy, this.loading = {}, this.loaded = {}, this.deduped = new gy(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler;
          }
          loadTile(t2, e2) {
            const r3 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r3] = new yy(t2);
            s2.abort = this.loadVectorData(t2, (a2, o2) => {
              const l2 = !this.loading[r3];
              if (delete this.loading[r3], l2 || a2 || !o2) return s2.status = "done", l2 || (this.loaded[r3] = s2), e2(a2);
              const u2 = o2.rawData, c2 = {};
              o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new sh(new op(u2));
              const h2 = () => {
                s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r4) => {
                  if (t3 || !r4) return e2(t3);
                  const s3 = {};
                  if (i2) {
                    const t4 = jt(n2);
                    t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                  }
                  e2(null, z({ rawTileData: u2.slice(0) }, r4, c2, s3));
                });
              };
              this.isSpriteLoaded ? h2() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(h2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h2();
              }), this.loaded = this.loaded || {}, this.loaded[r3] = s2;
            });
          }
          reloadTile(t2, e2) {
            const r3 = this.loaded, n2 = t2.uid, i2 = this;
            if (r3 && r3[n2]) {
              const s2 = r3[n2];
              s2.showCollisionBoxes = t2.showCollisionBoxes, s2.enableTerrain = !!t2.enableTerrain, s2.projection = t2.projection, s2.tileTransform = Vf(t2.tileID.canonical, t2.projection);
              const a2 = (t3, r4) => {
                const n3 = s2.reloadCallback;
                n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e2(t3, r4);
              };
              "parsing" === s2.status ? s2.reloadCallback = a2 : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
            }
          }
          abortTile(t2, e2) {
            const r3 = t2.uid, n2 = this.loading[r3];
            n2 && (n2.abort && n2.abort(), delete this.loading[r3]), e2();
          }
          removeTile(t2, e2) {
            const r3 = this.loaded, n2 = t2.uid;
            r3 && r3[n2] && delete r3[n2], e2();
          }
        }, t.WritingMode = Vp, t.ZoomDependentExpression = Xn, t.add = Go, t.addDynamicAttributes = od, t.adjoint = function(t2, e2) {
          var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8];
          return t2[0] = a2 * c2 - o2 * u2, t2[1] = i2 * u2 - n2 * c2, t2[2] = n2 * o2 - i2 * a2, t2[3] = o2 * l2 - s2 * c2, t2[4] = r3 * c2 - i2 * l2, t2[5] = i2 * s2 - r3 * o2, t2[6] = s2 * u2 - a2 * l2, t2[7] = n2 * l2 - r3 * u2, t2[8] = r3 * a2 - n2 * s2, t2;
        }, t.asyncAll = M, t.bezier = _, t.bindAll = V, t.boundsAttributes = Vd, t.bufferConvexPolygon = function(t2, e2) {
          const r3 = [];
          for (let n2 = 0; n2 < t2.length; n2++) {
            const i2 = I(n2 - 1, -1, t2.length - 1), s2 = I(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
            r3.push(a2.add(h2));
          }
          return r3;
        }, t.cacheEntryPossiblyAdded = function(t2) {
          it++, it > tt && (t2.getActor().send("enforceCacheSizeLimit", Q), it = 0);
        }, t.calculateGlobeLabelMatrix = function(t2, e2) {
          const { x: r3, y: n2 } = t2.point, i2 = Xl(r3, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
          return Po(i2, i2, Zl(Pl(e2)));
        }, t.calculateGlobeMatrix = function(t2) {
          const { x: e2, y: r3 } = t2.point, { lng: n2, lat: i2 } = t2._center;
          return Xl(e2, r3, t2.worldSize, n2, i2);
        }, t.calculateGlobeMercatorMatrix = function(t2) {
          const e2 = t2.pixelsPerMeter, r3 = e2 / au(1, t2.center.lat), n2 = Eo(new Float64Array(16));
          return Do(n2, n2, [t2.point.x, t2.point.y, 0]), Vo(n2, n2, [r3, r3, e2]), Float32Array.from(n2);
        }, t.circumferenceAtLatitude = nu, t.clamp = S, t.clearTileCache = function(t2) {
          if (!et()) return;
          const r3 = e.caches.delete(H);
          t2 && r3.catch(t2).then(() => t2());
        }, t.clipLine = sf, t.clone = function(t2) {
          var e2 = new To(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.clone$1 = j, t.collisionCircleLayout = Hh, t.config = i, t.conjugate = function(t2, e2) {
          return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
        }, t.create = function() {
          var t2 = new To(16);
          return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.create$1 = zo, t.createExpression = Gn, t.createLayout = na, t.createStyleLayer = function(t2) {
          return "custom" === t2.type ? new xd(t2) : new wd[t2.type](t2);
        }, t.cross = tl, t.degToRad = x, t.distance = function(t2, e2) {
          return Math.hypot(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
        }, t.div = function(t2, e2, r3) {
          return t2[0] = e2[0] / r3[0], t2[1] = e2[1] / r3[1], t2[2] = e2[2] / r3[2], t2;
        }, t.dot = Qo, t.earthRadius = tu, t.ease = A, t.easeCubicInOut = w, t.ecefToLatLng = function([t2, e2, r3]) {
          const n2 = Math.hypot(t2, e2, r3), i2 = Math.atan2(t2, r3), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
          return new ru(v(i2), v(s2));
        }, t.emitValidationErrors = Ri, t.endsWith = L, t.enforceCacheSizeLimit = function(t2) {
          rt(), W && W.then((e2) => {
            e2.keys().then((r3) => {
              for (let n2 = 0; n2 < r3.length - t2; n2++) e2.delete(r3[n2]);
            });
          });
        }, t.evaluateSizeForFeature = tp, t.evaluateSizeForZoom = ep, t.evaluateVariableOffset = Sf, t.evented = Ls, t.exactEquals = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
        }, t.exactEquals$1 = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
        }, t.exported = Nt, t.exported$1 = s, t.extend = z, t.extend$1 = Wt, t.fillExtrusionHeightLift = bh, t.filterObject = R, t.fromMat4 = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
        }, t.fromQuat = function(t2, e2) {
          var r3 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r3 + r3, o2 = n2 + n2, l2 = i2 + i2, u2 = r3 * a2, c2 = n2 * a2, h2 = n2 * o2, p2 = i2 * a2, f2 = i2 * o2, d2 = i2 * l2, y2 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
          return t2[0] = 1 - h2 - d2, t2[1] = c2 + g2, t2[2] = p2 - m2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - d2, t2[6] = f2 + y2, t2[7] = 0, t2[8] = p2 + m2, t2[9] = f2 - y2, t2[10] = 1 - u2 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.fromRotation = function(t2, e2) {
          var r3 = Math.sin(e2), n2 = Math.cos(e2);
          return t2[0] = n2, t2[1] = r3, t2[2] = 0, t2[3] = -r3, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.fromScaling = Ro, t.furthestTileCorner = function(t2) {
          const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
          return b[e2];
        }, t.getAABBPointSquareDist = function(t2, e2, r3) {
          let n2 = 0;
          for (let i2 = 0; i2 < 2; ++i2) {
            const s2 = r3 ? r3[i2] : 0;
            t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e2[i2] < s2 && (n2 += (s2 - e2[i2]) * (s2 - e2[i2]));
          }
          return n2;
        }, t.getAnchorAlignment = Zp, t.getAnchorJustification = If, t.getBounds = function(t2) {
          let e2 = 1 / 0, r3 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2) e2 = Math.min(e2, s2.x), r3 = Math.min(r3, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return { min: new d(e2, r3), max: new d(n2, i2) };
        }, t.getColumn = Y, t.getGridMatrix = function(t2, e2, r3, n2) {
          const i2 = e2.getNorth(), s2 = e2.getSouth(), a2 = e2.getWest(), o2 = e2.getEast(), l2 = 1 << t2.z, u2 = o2 - a2, c2 = i2 - s2, h2 = u2 / Sl, p2 = -c2 / kl[r3], f2 = [0, h2, 0, p2, 0, 0, i2, a2, 0];
          if (t2.z > 0) {
            const t3 = 180 / n2;
            Bo(f2, f2, [t3 / u2 + 1, 0, 0, 0, t3 / c2 + 1, 0, -0.5 * t3 / h2, 0.5 * t3 / p2, 1]);
          }
          return f2[2] = l2, f2[5] = t2.x, f2[8] = t2.y, f2;
        }, t.getImage = dt, t.getJSON = function(t2, e2) {
          return lt(z(t2, { type: "json" }), e2);
        }, t.getLatitudinalLod = function(t2) {
          const e2 = cu - 5;
          t2 = S(t2, -e2, e2) / e2 * 90;
          const r3 = Math.pow(Math.abs(Math.sin(x(t2))), 3);
          return Math.round(r3 * (kl.length - 1));
        }, t.getMapSessionAPI = Pt, t.getPerformanceMeasurement = jt, t.getProjection = rd, t.getRTLTextPluginStatus = Fs, t.getReferrer = ot, t.getTilePoint = function(t2, { x: e2, y: r3 }, n2 = 0) {
          return new d(((e2 - n2) * t2.scale - t2.x) * ko, (r3 * t2.scale - t2.y) * ko);
        }, t.getTileVec3 = function(t2, e2, r3 = 0) {
          return No(((e2.x - r3) * t2.scale - t2.x) * ko, (e2.y * t2.scale - t2.y) * ko, uu(e2.z, e2.y));
        }, t.getVideo = function(t2, r3) {
          const n2 = e.document.createElement("video");
          n2.muted = true, n2.onloadstart = function() {
            r3(null, n2);
          };
          for (let r4 = 0; r4 < t2.length; r4++) {
            const i2 = e.document.createElement("source");
            ct(t2[r4]) || (n2.crossOrigin = "Anonymous"), i2.src = t2[r4], n2.appendChild(i2);
          }
          return { cancel: () => {
          } };
        }, t.globeCenterToScreenPoint = function(t2) {
          const e2 = [0, 0, 0], r3 = Eo(new Float64Array(16));
          return Po(r3, t2.pixelMatrix, t2.globeMatrix), el(e2, e2, r3), new d(e2[0], e2[1]);
        }, t.globeDenormalizeECEF = Zl, t.globeECEFOrigin = function(t2, e2) {
          const r3 = [0, 0, 0];
          return el(r3, r3, Gl(Pl(e2.canonical))), el(r3, r3, t2), r3;
        }, t.globeMetersToEcef = zl, t.globeNormalizeECEF = Gl, t.globePixelsToTileUnits = function(t2, e2) {
          return ko / (512 * Math.pow(2, t2)) * ql(Pl(e2));
        }, t.globePoleMatrixForTile = function(t2, e2, r3) {
          const n2 = Eo(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
          return Fo(n2, r3.globeMatrix, i2), Float32Array.from(n2);
        }, t.globeTileBounds = Pl, t.globeTiltAtLngLat = Yl, t.globeToMercatorTransition = Kl, t.globeUseCustomAntiAliasing = function(t2, e2, r3) {
          const n2 = Kl(r3.zoom), i2 = t2.style.map._antialias, s2 = !!e2.extStandardDerivatives, a2 = e2.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
          return 0 === n2 && !i2 && !a2 && s2;
        }, t.identity = Eo, t.identity$1 = hl, t.invert = Co, t.isFullscreen = function() {
          return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
        }, t.isLngLatBehindGlobe = Hl, t.isMapAuthenticated = function(t2) {
          return Dt.has(t2);
        }, t.isMapboxURL = mt, t.isSafariWithAntialiasingBug = function(t2) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          return !!X(t2) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t.latFromMercatorY = lu, t.latLngToECEF = Ul, t.len = al, t.length = qo, t.length$1 = function(t2) {
          return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
        }, t.lngFromMercatorX = ou, t.loadVectorTile = xy, t.makeRequest = lt, t.mapValue = function(t2, e2, r3, n2, i2) {
          return S((t2 - e2) / (r3 - e2) * (i2 - n2) + n2, n2, i2);
        }, t.mercatorScale = hu, t.mercatorXfromLng = iu, t.mercatorYfromLat = su, t.mercatorZfromAltitude = au, t.mul = $o, t.mul$1 = sl, t.multiply = Po, t.multiply$1 = Bo, t.multiply$2 = Xo, t.nextPowerOfTwo = P, t.normalize = Jo, t.normalize$1 = dl, t.normalize$2 = ll, t.number = Mr, t.ortho = function(t2, e2, r3, n2, i2, s2, a2) {
          var o2 = 1 / (e2 - r3), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r3) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.pbf = op, t.perspective = function(t2, e2, r3, n2, i2) {
          var s2, a2 = 1 / Math.tan(e2 / 2);
          return t2[0] = a2 / r3, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.pick = function(t2, e2) {
          const r3 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            i2 in t2 && (r3[i2] = t2[i2]);
          }
          return r3;
        }, t.plugin = js, t.pointGeometry = d, t.polesInViewport = function(t2) {
          const e2 = Eo(new Float64Array(16));
          Po(e2, t2.pixelMatrix, t2.globeMatrix);
          const r3 = [0, Il, 0], n2 = [0, Ml, 0];
          return el(r3, r3, e2), el(n2, n2, e2), [r3[0] > 0 && r3[0] <= t2.width && r3[1] > 0 && r3[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, -90))];
        }, t.polygonContainsPoint = Du, t.polygonIntersectsBox = Vu, t.polygonIntersectsPolygon = ku, t.polygonizeBounds = function(t2, e2, r3 = 0, n2 = true) {
          const i2 = new d(r3, r3), s2 = t2.sub(i2), a2 = e2.add(i2), o2 = [s2, new d(a2.x, s2.y), a2, new d(s2.x, a2.y)];
          return n2 && o2.push(s2.clone()), o2;
        }, t.posAttributes = xl, t.postMapLoadEvent = zt, t.postPerformanceEvent = Et, t.postTurnstileEvent = Mt, t.potpack = Cp, t.prevPowerOfTwo = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
        }, t.radToDeg = v, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
          return t2({ pluginStatus: Cs, pluginURL: Ps }), Ls.on("pluginStateChange", t2), t2;
        }, t.removeAuthState = function(t2) {
          Dt.delete(t2);
        }, t.renderColorRamp = ec, t.resample = du, t.rotateX = Lo, t.rotateX$1 = pl, t.rotateY = Fo, t.rotateY$1 = fl, t.rotateZ = function(t2, e2, r3) {
          var n2 = Math.sin(r3), i2 = Math.cos(r3), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }, t.rotateZ$1 = function(t2, e2, r3) {
          r3 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
        }, t.scale = Vo, t.scale$1 = ol, t.scale$2 = Ho, t.scaleAndAdd = Wo, t.set = function(t2, e2, r3, n2) {
          return t2[0] = e2, t2[1] = r3, t2[2] = n2, t2;
        }, t.setCacheLimits = function(t2, e2) {
          Q = t2, tt = e2;
        }, t.setColumn = function(t2, e2, r3) {
          t2[4 * e2 + 0] = r3[0], t2[4 * e2 + 1] = r3[1], t2[4 * e2 + 2] = r3[2], t2[4 * e2 + 3] = r3[3];
        }, t.setRTLTextPlugin = function(t2, e2, r3 = false) {
          if (Cs === Ts || Cs === zs || Cs === Bs) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          Ps = Nt.resolveURL(t2), Cs = Ts, Es = e2, Vs(), r3 || Rs();
        }, t.smoothstep = k, t.spec = Ht, t.squaredLength = function(t2) {
          var e2 = t2[0], r3 = t2[1], n2 = t2[2];
          return e2 * e2 + r3 * r3 + n2 * n2;
        }, t.storeAuthState = function(t2, e2) {
          e2 ? Dt.add(t2) : Dt.delete(t2);
        }, t.sub = il, t.subtract = Zo, t.symbolSize = rp, t.tileAABB = function(t2, e2, r3, n2, i2, s2, a2, o2, l2) {
          if ("globe" === l2.name) return Fl(t2, e2, new kh(r3, n2, i2));
          const u2 = Vf({ z: r3, x: n2, y: i2 }, l2);
          return new _l([(s2 + u2.x / u2.scale) * e2, e2 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e2, e2 * (u2.y2 / u2.scale), o2]);
        }, t.tileCornersToBounds = Rl, t.tileTransform = Vf, t.transformMat3 = function(t2, e2, r3) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2];
          return t2[0] = n2 * r3[0] + i2 * r3[3] + s2 * r3[6], t2[1] = n2 * r3[1] + i2 * r3[4] + s2 * r3[7], t2[2] = n2 * r3[2] + i2 * r3[5] + s2 * r3[8], t2;
        }, t.transformMat4 = el, t.transformMat4$1 = ul, t.transformQuat = rl, t.transitionTileAABBinECEF = Vl, t.translate = Do, t.transpose = function(t2, e2) {
          if (t2 === e2) {
            var r3 = e2[1], n2 = e2[2], i2 = e2[5];
            t2[1] = e2[3], t2[2] = e2[6], t2[3] = r3, t2[5] = e2[7], t2[6] = n2, t2[7] = i2;
          } else t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8];
          return t2;
        }, t.triggerPluginCompletionEvent = Ds, t.uniqueId = E, t.updateGlobeVertexNormal = function(t2, e2, r3, n2, i2) {
          const s2 = 5 * e2 + 2;
          t2.float32[s2 + 0] = r3, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
        }, t.validateCustomStyleLayer = function(t2) {
          const e2 = [], r3 = t2.id;
          return void 0 === r3 && e2.push({ message: `layers.${r3}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r3}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.validateFilter = (t2) => Fi(xi(t2)), t.validateFog = (t2) => Fi(Bi(t2)), t.validateLayer = (t2) => Fi(Ai(t2)), t.validateLight = (t2) => Fi(Ti(t2)), t.validateSource = (t2) => Fi(Ii(t2)), t.validateStyle = Di, t.validateTerrain = (t2) => Fi(zi(t2)), t.values = T, t.vectorTile = Xc, t.version = r2, t.warnOnce = U, t.window = e, t.wrap = I;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2) {
          if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2) return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            let r4 = "[";
            for (const o2 of e2) r4 += `${t(o2)},`;
            return `${r4}]`;
          }
          let r3 = "{";
          for (const o2 of Object.keys(e2).sort()) r3 += `${o2}:${t(e2[o2])},`;
          return `${r3}}`;
        }
        function r2(r3) {
          let o2 = "";
          for (const n2 of e.refProperties) o2 += `/${t(r3[n2])}`;
          return o2;
        }
        class o {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t2, o2) {
            for (const r3 of t2) this._layerConfigs[r3.id] = r3, (this._layers[r3.id] = e.createStyleLayer(r3)).compileFilter(), this.keyCache[r3.id] && delete this.keyCache[r3.id];
            for (const e2 of o2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const n2 = function(e2, t3) {
              const o3 = {};
              for (let n4 = 0; n4 < e2.length; n4++) {
                const i2 = t3 && t3[e2[n4].id] || r2(e2[n4]);
                t3 && (t3[e2[n4].id] = i2);
                let s2 = o3[i2];
                s2 || (s2 = o3[i2] = []), s2.push(e2[n4]);
              }
              const n3 = [];
              for (const e3 in o3) n3.push(o3[e3]);
              return n3;
            }(e.values(this._layerConfigs), this.keyCache);
            for (const e2 of n2) {
              const t3 = e2.map((e3) => this._layers[e3.id]), r3 = t3[0];
              if ("none" === r3.visibility) continue;
              const o3 = r3.source || "";
              let n3 = this.familiesBySource[o3];
              n3 || (n3 = this.familiesBySource[o3] = {});
              const i2 = r3.sourceLayer || "_geojsonTileLayer";
              let s2 = n3[i2];
              s2 || (s2 = n3[i2] = []), s2.push(t3);
            }
          }
        }
        class n {
          loadTile(t2, r3) {
            const { uid: o2, encoding: n2, rawImageData: i2, padding: s2, buildQuadTree: a2 } = t2, l2 = e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? this.getImageData(i2, s2) : i2;
            r3(null, new e.DEMData(o2, l2, n2, s2 < 1, a2));
          }
          getImageData(e2, t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
            const r3 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r3;
          }
        }
        var i = function e2(t2, r3) {
          var o2, n2 = t2 && t2.type;
          if ("FeatureCollection" === n2) for (o2 = 0; o2 < t2.features.length; o2++) e2(t2.features[o2], r3);
          else if ("GeometryCollection" === n2) for (o2 = 0; o2 < t2.geometries.length; o2++) e2(t2.geometries[o2], r3);
          else if ("Feature" === n2) e2(t2.geometry, r3);
          else if ("Polygon" === n2) s(t2.coordinates, r3);
          else if ("MultiPolygon" === n2) for (o2 = 0; o2 < t2.coordinates.length; o2++) s(t2.coordinates[o2], r3);
          return t2;
        };
        function s(e2, t2) {
          if (0 !== e2.length) {
            a(e2[0], t2);
            for (var r3 = 1; r3 < e2.length; r3++) a(e2[r3], !t2);
          }
        }
        function a(e2, t2) {
          for (var r3 = 0, o2 = 0, n2 = 0, i2 = e2.length, s2 = i2 - 1; n2 < i2; s2 = n2++) {
            var a2 = (e2[n2][0] - e2[s2][0]) * (e2[s2][1] + e2[n2][1]), l2 = r3 + a2;
            o2 += Math.abs(r3) >= Math.abs(a2) ? r3 - l2 + a2 : a2 - l2 + r3, r3 = l2;
          }
          r3 + o2 >= 0 != !!t2 && e2.reverse();
        }
        const l = e.VectorTileFeature.prototype.toGeoJSON;
        class u {
          constructor(t2) {
            this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t2 = [];
              for (const r3 of this._feature.geometry) t2.push([new e.pointGeometry(r3[0], r3[1])]);
              return t2;
            }
            {
              const t2 = [];
              for (const r3 of this._feature.geometry) {
                const o2 = [];
                for (const t3 of r3) o2.push(new e.pointGeometry(t3[0], t3[1]));
                t2.push(o2);
              }
              return t2;
            }
          }
          toGeoJSON(e2, t2, r3) {
            return l.call(this, e2, t2, r3);
          }
        }
        class h {
          constructor(t2) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
          }
          feature(e2) {
            return new u(this._features[e2]);
          }
        }
        var c = {}, f = { get exports() {
          return c;
        }, set exports(e2) {
          c = e2;
        } }, p = e.pointGeometry, g = e.vectorTile.VectorTileFeature, d = m;
        function m(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function y(e2, t2) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        m.prototype.feature = function(e2) {
          return new y(this.features[e2], this.options.extent);
        }, y.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e2.length; t2++) {
            for (var r3 = e2[t2], o2 = [], n2 = 0; n2 < r3.length; n2++) o2.push(new p(r3[n2][0], r3[n2][1]));
            this.geometry.push(o2);
          }
          return this.geometry;
        }, y.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, r3 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i2 = 0; i2 < e2.length; i2++) for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
            var l2 = s2[a2];
            t2 = Math.min(t2, l2.x), r3 = Math.max(r3, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
          }
          return [t2, o2, r3, n2];
        }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;
        var v = e.pbf, x = d;
        function w(e2) {
          var t2 = new v();
          return function(e3, t3) {
            for (var r3 in e3.layers) t3.writeMessage(3, S, e3.layers[r3]);
          }(e2, t2), t2.finish();
        }
        function S(e2, t2) {
          var r3;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r3 = 0; r3 < e2.length; r3++) o2.feature = e2.feature(r3), t2.writeMessage(2, M, o2);
          var n2 = o2.keys;
          for (r3 = 0; r3 < n2.length; r3++) t2.writeStringField(3, n2[r3]);
          var i2 = o2.values;
          for (r3 = 0; r3 < i2.length; r3++) t2.writeMessage(4, T, i2[r3]);
        }
        function M(e2, t2) {
          var r3 = e2.feature;
          void 0 !== r3.id && t2.writeVarintField(1, r3.id), t2.writeMessage(2, P, e2), t2.writeVarintField(3, r3.type), t2.writeMessage(4, I, r3);
        }
        function P(e2, t2) {
          var r3 = e2.feature, o2 = e2.keys, n2 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
          for (var a2 in r3.properties) {
            var l2 = r3.properties[a2], u2 = i2[a2];
            if (null !== l2) {
              void 0 === u2 && (o2.push(a2), i2[a2] = u2 = o2.length - 1), t2.writeVarint(u2);
              var h2 = typeof l2;
              "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (l2 = JSON.stringify(l2));
              var c2 = h2 + ":" + l2, f2 = s2[c2];
              void 0 === f2 && (n2.push(l2), s2[c2] = f2 = n2.length - 1), t2.writeVarint(f2);
            }
          }
        }
        function b(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function k(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function I(e2, t2) {
          for (var r3 = e2.loadGeometry(), o2 = e2.type, n2 = 0, i2 = 0, s2 = r3.length, a2 = 0; a2 < s2; a2++) {
            var l2 = r3[a2], u2 = 1;
            1 === o2 && (u2 = l2.length), t2.writeVarint(b(1, u2));
            for (var h2 = 3 === o2 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
              1 === c2 && 1 !== o2 && t2.writeVarint(b(2, h2 - 1));
              var f2 = l2[c2].x - n2, p2 = l2[c2].y - i2;
              t2.writeVarint(k(f2)), t2.writeVarint(k(p2)), n2 += f2, i2 += p2;
            }
            3 === o2 && t2.writeVarint(b(7, 1));
          }
        }
        function T(e2, t2) {
          var r3 = typeof e2;
          "string" === r3 ? t2.writeStringField(1, e2) : "boolean" === r3 ? t2.writeBooleanField(7, e2) : "number" === r3 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        function _(e2, t2, r3, o2, n2, i2) {
          if (n2 - o2 <= r3) return;
          const s2 = o2 + n2 >> 1;
          L(e2, t2, s2, o2, n2, i2 % 2), _(e2, t2, r3, o2, s2 - 1, i2 + 1), _(e2, t2, r3, s2 + 1, n2, i2 + 1);
        }
        function L(e2, t2, r3, o2, n2, i2) {
          for (; n2 > o2; ) {
            if (n2 - o2 > 600) {
              const s3 = n2 - o2 + 1, a3 = r3 - o2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), h2 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              L(e2, t2, r3, Math.max(o2, Math.floor(r3 - a3 * u2 / s3 + h2)), Math.min(n2, Math.floor(r3 + (s3 - a3) * u2 / s3 + h2)), i2);
            }
            const s2 = t2[2 * r3 + i2];
            let a2 = o2, l2 = n2;
            for (C(e2, t2, o2, r3), t2[2 * n2 + i2] > s2 && C(e2, t2, o2, n2); a2 < l2; ) {
              for (C(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + i2] < s2; ) a2++;
              for (; t2[2 * l2 + i2] > s2; ) l2--;
            }
            t2[2 * o2 + i2] === s2 ? C(e2, t2, o2, l2) : (l2++, C(e2, t2, l2, n2)), l2 <= r3 && (o2 = l2 + 1), r3 <= l2 && (n2 = l2 - 1);
          }
        }
        function C(e2, t2, r3, o2) {
          O(e2, r3, o2), O(t2, 2 * r3, 2 * o2), O(t2, 2 * r3 + 1, 2 * o2 + 1);
        }
        function O(e2, t2, r3) {
          const o2 = e2[t2];
          e2[t2] = e2[r3], e2[r3] = o2;
        }
        function z(e2, t2, r3, o2) {
          const n2 = e2 - r3, i2 = t2 - o2;
          return n2 * n2 + i2 * i2;
        }
        f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function(e2, t2) {
          t2 = t2 || {};
          var r3 = {};
          for (var o2 in e2) r3[o2] = new x(e2[o2].features, t2), r3[o2].name = o2, r3[o2].version = t2.version, r3[o2].extent = t2.extent;
          return w({ layers: r3 });
        }, c.GeoJSONWrapper = x;
        const E = (e2) => e2[0], F = (e2) => e2[1];
        class N {
          constructor(e2, t2 = E, r3 = F, o2 = 64, n2 = Float64Array) {
            this.nodeSize = o2, this.points = e2;
            const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n2(2 * e2.length);
            for (let o3 = 0; o3 < e2.length; o3++) s2[o3] = o3, a2[2 * o3] = t2(e2[o3]), a2[2 * o3 + 1] = r3(e2[o3]);
            _(s2, a2, o2, 0, s2.length - 1, 0);
          }
          range(e2, t2, r3, o2) {
            return function(e3, t3, r4, o3, n2, i2, s2) {
              const a2 = [0, e3.length - 1, 0], l2 = [];
              let u2, h2;
              for (; a2.length; ) {
                const c2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
                if (f2 - p2 <= s2) {
                  for (let s3 = p2; s3 <= f2; s3++) u2 = t3[2 * s3], h2 = t3[2 * s3 + 1], u2 >= r4 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[s3]);
                  continue;
                }
                const g2 = Math.floor((p2 + f2) / 2);
                u2 = t3[2 * g2], h2 = t3[2 * g2 + 1], u2 >= r4 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[g2]);
                const d2 = (c2 + 1) % 2;
                (0 === c2 ? r4 <= u2 : o3 <= h2) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (0 === c2 ? n2 >= u2 : i2 >= h2) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
              }
              return l2;
            }(this.ids, this.coords, e2, t2, r3, o2, this.nodeSize);
          }
          within(e2, t2, r3) {
            return function(e3, t3, r4, o2, n2, i2) {
              const s2 = [0, e3.length - 1, 0], a2 = [], l2 = n2 * n2;
              for (; s2.length; ) {
                const u2 = s2.pop(), h2 = s2.pop(), c2 = s2.pop();
                if (h2 - c2 <= i2) {
                  for (let n3 = c2; n3 <= h2; n3++) z(t3[2 * n3], t3[2 * n3 + 1], r4, o2) <= l2 && a2.push(e3[n3]);
                  continue;
                }
                const f2 = Math.floor((c2 + h2) / 2), p2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
                z(p2, g2, r4, o2) <= l2 && a2.push(e3[f2]);
                const d2 = (u2 + 1) % 2;
                (0 === u2 ? r4 - n2 <= p2 : o2 - n2 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (0 === u2 ? r4 + n2 >= p2 : o2 + n2 >= g2) && (s2.push(f2 + 1), s2.push(h2), s2.push(d2));
              }
              return a2;
            }(this.ids, this.coords, e2, t2, r3, this.nodeSize);
          }
        }
        const j = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, Z = Math.fround || (G = new Float32Array(1), (e2) => (G[0] = +e2, G[0]));
        var G;
        class J {
          constructor(e2) {
            this.options = B(Object.create(j), e2), this.trees = new Array(this.options.maxZoom + 1);
          }
          load(e2) {
            const { log: t2, minZoom: r3, maxZoom: o2, nodeSize: n2 } = this.options;
            t2 && console.time("total time");
            const i2 = `prepare ${e2.length} points`;
            t2 && console.time(i2), this.points = e2;
            let s2 = [];
            for (let t3 = 0; t3 < e2.length; t3++) e2[t3].geometry && s2.push(Y(e2[t3], t3));
            this.trees[o2 + 1] = new N(s2, R, q, n2, Float32Array), t2 && console.timeEnd(i2);
            for (let e3 = o2; e3 >= r3; e3--) {
              const r4 = +Date.now();
              s2 = this._cluster(s2, e3), this.trees[e3] = new N(s2, R, q, n2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r4);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let r3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const o2 = Math.max(-90, Math.min(90, e2[1]));
            let n2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360) r3 = -180, n2 = 180;
            else if (r3 > n2) {
              const e3 = this.getClusters([r3, o2, 180, i2], t2), s3 = this.getClusters([-180, o2, n2, i2], t2);
              return e3.concat(s3);
            }
            const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(A(r3), D(i2), A(n2), D(o2)), l2 = [];
            for (const e3 of a2) {
              const t3 = s2.points[e3];
              l2.push(t3.numPoints ? X(t3) : this.points[t3.index]);
            }
            return l2;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), r3 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n2 = this.trees[r3];
            if (!n2) throw new Error(o2);
            const i2 = n2.points[t2];
            if (!i2) throw new Error(o2);
            const s2 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a2 = n2.within(i2.x, i2.y, s2), l2 = [];
            for (const t3 of a2) {
              const r4 = n2.points[t3];
              r4.parentId === e2 && l2.push(r4.numPoints ? X(r4) : this.points[r4.index]);
            }
            if (0 === l2.length) throw new Error(o2);
            return l2;
          }
          getLeaves(e2, t2, r3) {
            const o2 = [];
            return this._appendLeaves(o2, e2, t2 = t2 || 10, r3 = r3 || 0, 0), o2;
          }
          getTile(e2, t2, r3) {
            const o2 = this.trees[this._limitZoom(e2)], n2 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l2 = (r3 - a2) / n2, u2 = (r3 + 1 + a2) / n2, h2 = { features: [] };
            return this._addTileFeatures(o2.range((t2 - a2) / n2, l2, (t2 + 1 + a2) / n2, u2), o2.points, t2, r3, n2, h2), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r3, n2, h2), t2 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r3, n2, h2), h2.features.length ? h2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const r3 = this.getChildren(e2);
              if (t2++, 1 !== r3.length) break;
              e2 = r3[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, r3, o2, n2) {
            const i2 = this.getChildren(t2);
            for (const t3 of i2) {
              const i3 = t3.properties;
              if (i3 && i3.cluster ? n2 + i3.point_count <= o2 ? n2 += i3.point_count : n2 = this._appendLeaves(e2, i3.cluster_id, r3, o2, n2) : n2 < o2 ? n2++ : e2.push(t3), e2.length === r3) break;
            }
            return n2;
          }
          _addTileFeatures(e2, t2, r3, o2, n2, i2) {
            for (const s2 of e2) {
              const e3 = t2[s2], a2 = e3.numPoints;
              let l2, u2, h2;
              if (a2) l2 = V(e3), u2 = e3.x, h2 = e3.y;
              else {
                const t3 = this.points[e3.index];
                l2 = t3.properties, u2 = A(t3.geometry.coordinates[0]), h2 = D(t3.geometry.coordinates[1]);
              }
              const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r3)), Math.round(this.options.extent * (h2 * n2 - o2))]], tags: l2 };
              let f2;
              a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), void 0 !== f2 && (c2.id = f2), i2.features.push(c2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const r3 = [], { radius: o2, extent: n2, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n2 * Math.pow(2, t2));
            for (let o3 = 0; o3 < e2.length; o3++) {
              const n3 = e2[o3];
              if (n3.zoom <= t2) continue;
              n3.zoom = t2;
              const l2 = this.trees[t2 + 1], u2 = l2.within(n3.x, n3.y, a2), h2 = n3.numPoints || 1;
              let c2 = h2;
              for (const e3 of u2) {
                const r4 = l2.points[e3];
                r4.zoom > t2 && (c2 += r4.numPoints || 1);
              }
              if (c2 > h2 && c2 >= s2) {
                let e3 = n3.x * h2, s3 = n3.y * h2, a3 = i2 && h2 > 1 ? this._map(n3, true) : null;
                const f2 = (o3 << 5) + (t2 + 1) + this.points.length;
                for (const r4 of u2) {
                  const o4 = l2.points[r4];
                  if (o4.zoom <= t2) continue;
                  o4.zoom = t2;
                  const u3 = o4.numPoints || 1;
                  e3 += o4.x * u3, s3 += o4.y * u3, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n3, true)), i2(a3, this._map(o4)));
                }
                n3.parentId = f2, r3.push(W(e3 / c2, s3 / c2, f2, c2, a3));
              } else if (r3.push(n3), c2 > 1) for (const e3 of u2) {
                const o4 = l2.points[e3];
                o4.zoom <= t2 || (o4.zoom = t2, r3.push(o4));
              }
            }
            return r3;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2) {
            if (e2.numPoints) return t2 ? B({}, e2.properties) : e2.properties;
            const r3 = this.points[e2.index].properties, o2 = this.options.map(r3);
            return t2 && o2 === r3 ? B({}, o2) : o2;
          }
        }
        function W(e2, t2, r3, o2, n2) {
          return { x: Z(e2), y: Z(t2), zoom: 1 / 0, id: r3, parentId: -1, numPoints: o2, properties: n2 };
        }
        function Y(e2, t2) {
          const [r3, o2] = e2.geometry.coordinates;
          return { x: Z(A(r3)), y: Z(D(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
        }
        function X(e2) {
          return { type: "Feature", id: e2.id, properties: V(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), $(e2.y)] } };
          var t2;
        }
        function V(e2) {
          const t2 = e2.numPoints, r3 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
          return B(B({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r3 });
        }
        function A(e2) {
          return e2 / 360 + 0.5;
        }
        function D(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function $(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function B(e2, t2) {
          for (const r3 in t2) e2[r3] = t2[r3];
          return e2;
        }
        function R(e2) {
          return e2.x;
        }
        function q(e2) {
          return e2.y;
        }
        function U(e2, t2, r3, o2) {
          for (var n2, i2 = o2, s2 = r3 - t2 >> 1, a2 = r3 - t2, l2 = e2[t2], u2 = e2[t2 + 1], h2 = e2[r3], c2 = e2[r3 + 1], f2 = t2 + 3; f2 < r3; f2 += 3) {
            var p2 = Q(e2[f2], e2[f2 + 1], l2, u2, h2, c2);
            if (p2 > i2) n2 = f2, i2 = p2;
            else if (p2 === i2) {
              var g2 = Math.abs(f2 - s2);
              g2 < a2 && (n2 = f2, a2 = g2);
            }
          }
          i2 > o2 && (n2 - t2 > 3 && U(e2, t2, n2, o2), e2[n2 + 2] = i2, r3 - n2 > 3 && U(e2, n2, r3, o2));
        }
        function Q(e2, t2, r3, o2, n2, i2) {
          var s2 = n2 - r3, a2 = i2 - o2;
          if (0 !== s2 || 0 !== a2) {
            var l2 = ((e2 - r3) * s2 + (t2 - o2) * a2) / (s2 * s2 + a2 * a2);
            l2 > 1 ? (r3 = n2, o2 = i2) : l2 > 0 && (r3 += s2 * l2, o2 += a2 * l2);
          }
          return (s2 = e2 - r3) * s2 + (a2 = t2 - o2) * a2;
        }
        function H(e2, t2, r3, o2) {
          var n2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r3, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t3 = e3.geometry, r4 = e3.type;
            if ("Point" === r4 || "MultiPoint" === r4 || "LineString" === r4) K(e3, t3);
            else if ("Polygon" === r4 || "MultiLineString" === r4) for (var o3 = 0; o3 < t3.length; o3++) K(e3, t3[o3]);
            else if ("MultiPolygon" === r4) for (o3 = 0; o3 < t3.length; o3++) for (var n3 = 0; n3 < t3[o3].length; n3++) K(e3, t3[o3][n3]);
          }(n2), n2;
        }
        function K(e2, t2) {
          for (var r3 = 0; r3 < t2.length; r3 += 3) e2.minX = Math.min(e2.minX, t2[r3]), e2.minY = Math.min(e2.minY, t2[r3 + 1]), e2.maxX = Math.max(e2.maxX, t2[r3]), e2.maxY = Math.max(e2.maxY, t2[r3 + 1]);
        }
        function ee(e2, t2, r3, o2) {
          if (t2.geometry) {
            var n2 = t2.geometry.coordinates, i2 = t2.geometry.type, s2 = Math.pow(r3.tolerance / ((1 << r3.maxZoom) * r3.extent), 2), a2 = [], l2 = t2.id;
            if (r3.promoteId ? l2 = t2.properties[r3.promoteId] : r3.generateId && (l2 = o2 || 0), "Point" === i2) te(n2, a2);
            else if ("MultiPoint" === i2) for (var u2 = 0; u2 < n2.length; u2++) te(n2[u2], a2);
            else if ("LineString" === i2) re(n2, a2, s2, false);
            else if ("MultiLineString" === i2) {
              if (r3.lineMetrics) {
                for (u2 = 0; u2 < n2.length; u2++) re(n2[u2], a2 = [], s2, false), e2.push(H(l2, "LineString", a2, t2.properties));
                return;
              }
              oe(n2, a2, s2, false);
            } else if ("Polygon" === i2) oe(n2, a2, s2, true);
            else {
              if ("MultiPolygon" !== i2) {
                if ("GeometryCollection" === i2) {
                  for (u2 = 0; u2 < t2.geometry.geometries.length; u2++) ee(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r3, o2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u2 = 0; u2 < n2.length; u2++) {
                var h2 = [];
                oe(n2[u2], h2, s2, true), a2.push(h2);
              }
            }
            e2.push(H(l2, i2, a2, t2.properties));
          }
        }
        function te(e2, t2) {
          t2.push(ne(e2[0])), t2.push(ie(e2[1])), t2.push(0);
        }
        function re(e2, t2, r3, o2) {
          for (var n2, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
            var l2 = ne(e2[a2][0]), u2 = ie(e2[a2][1]);
            t2.push(l2), t2.push(u2), t2.push(0), a2 > 0 && (s2 += o2 ? (n2 * u2 - l2 * i2) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i2, 2))), n2 = l2, i2 = u2;
          }
          var h2 = t2.length - 3;
          t2[2] = 1, U(t2, 0, h2, r3), t2[h2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
        }
        function oe(e2, t2, r3, o2) {
          for (var n2 = 0; n2 < e2.length; n2++) {
            var i2 = [];
            re(e2[n2], i2, r3, o2), t2.push(i2);
          }
        }
        function ne(e2) {
          return e2 / 360 + 0.5;
        }
        function ie(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function se(e2, t2, r3, o2, n2, i2, s2, a2) {
          if (o2 /= t2, i2 >= (r3 /= t2) && s2 < o2) return e2;
          if (s2 < r3 || i2 >= o2) return null;
          for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
            var h2 = e2[u2], c2 = h2.geometry, f2 = h2.type, p2 = 0 === n2 ? h2.minX : h2.minY, g2 = 0 === n2 ? h2.maxX : h2.maxY;
            if (p2 >= r3 && g2 < o2) l2.push(h2);
            else if (!(g2 < r3 || p2 >= o2)) {
              var d2 = [];
              if ("Point" === f2 || "MultiPoint" === f2) ae(c2, d2, r3, o2, n2);
              else if ("LineString" === f2) le(c2, d2, r3, o2, n2, false, a2.lineMetrics);
              else if ("MultiLineString" === f2) he(c2, d2, r3, o2, n2, false);
              else if ("Polygon" === f2) he(c2, d2, r3, o2, n2, true);
              else if ("MultiPolygon" === f2) for (var m2 = 0; m2 < c2.length; m2++) {
                var y2 = [];
                he(c2[m2], y2, r3, o2, n2, true), y2.length && d2.push(y2);
              }
              if (d2.length) {
                if (a2.lineMetrics && "LineString" === f2) {
                  for (m2 = 0; m2 < d2.length; m2++) l2.push(H(h2.id, f2, d2[m2], h2.tags));
                  continue;
                }
                "LineString" !== f2 && "MultiLineString" !== f2 || (1 === d2.length ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), "Point" !== f2 && "MultiPoint" !== f2 || (f2 = 3 === d2.length ? "Point" : "MultiPoint"), l2.push(H(h2.id, f2, d2, h2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function ae(e2, t2, r3, o2, n2) {
          for (var i2 = 0; i2 < e2.length; i2 += 3) {
            var s2 = e2[i2 + n2];
            s2 >= r3 && s2 <= o2 && (t2.push(e2[i2]), t2.push(e2[i2 + 1]), t2.push(e2[i2 + 2]));
          }
        }
        function le(e2, t2, r3, o2, n2, i2, s2) {
          for (var a2, l2, u2 = ue(e2), h2 = 0 === n2 ? fe : pe, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
            var p2 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v2 = 0 === n2 ? p2 : g2, x2 = 0 === n2 ? m2 : y2, w2 = false;
            s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(g2 - y2, 2))), v2 < r3 ? x2 > r3 && (l2 = h2(u2, p2, g2, m2, y2, r3), s2 && (u2.start = c2 + a2 * l2)) : v2 > o2 ? x2 < o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), s2 && (u2.start = c2 + a2 * l2)) : ce(u2, p2, g2, d2), x2 < r3 && v2 >= r3 && (l2 = h2(u2, p2, g2, m2, y2, r3), w2 = true), x2 > o2 && v2 <= o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), w2 = true), !i2 && w2 && (s2 && (u2.end = c2 + a2 * l2), t2.push(u2), u2 = ue(e2)), s2 && (c2 += a2);
          }
          var S2 = e2.length - 3;
          p2 = e2[S2], g2 = e2[S2 + 1], d2 = e2[S2 + 2], (v2 = 0 === n2 ? p2 : g2) >= r3 && v2 <= o2 && ce(u2, p2, g2, d2), S2 = u2.length - 3, i2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && ce(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
        }
        function ue(e2) {
          var t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function he(e2, t2, r3, o2, n2, i2) {
          for (var s2 = 0; s2 < e2.length; s2++) le(e2[s2], t2, r3, o2, n2, i2, false);
        }
        function ce(e2, t2, r3, o2) {
          e2.push(t2), e2.push(r3), e2.push(o2);
        }
        function fe(e2, t2, r3, o2, n2, i2) {
          var s2 = (i2 - t2) / (o2 - t2);
          return e2.push(i2), e2.push(r3 + (n2 - r3) * s2), e2.push(1), s2;
        }
        function pe(e2, t2, r3, o2, n2, i2) {
          var s2 = (i2 - r3) / (n2 - r3);
          return e2.push(t2 + (o2 - t2) * s2), e2.push(i2), e2.push(1), s2;
        }
        function ge(e2, t2) {
          for (var r3 = [], o2 = 0; o2 < e2.length; o2++) {
            var n2, i2 = e2[o2], s2 = i2.type;
            if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2) n2 = de(i2.geometry, t2);
            else if ("MultiLineString" === s2 || "Polygon" === s2) {
              n2 = [];
              for (var a2 = 0; a2 < i2.geometry.length; a2++) n2.push(de(i2.geometry[a2], t2));
            } else if ("MultiPolygon" === s2) for (n2 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
              for (var l2 = [], u2 = 0; u2 < i2.geometry[a2].length; u2++) l2.push(de(i2.geometry[a2][u2], t2));
              n2.push(l2);
            }
            r3.push(H(i2.id, s2, n2, i2.tags));
          }
          return r3;
        }
        function de(e2, t2) {
          var r3 = [];
          r3.size = e2.size, void 0 !== e2.start && (r3.start = e2.start, r3.end = e2.end);
          for (var o2 = 0; o2 < e2.length; o2 += 3) r3.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
          return r3;
        }
        function me(e2, t2) {
          if (e2.transformed) return e2;
          var r3, o2, n2, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
          for (r3 = 0; r3 < e2.features.length; r3++) {
            var l2 = e2.features[r3], u2 = l2.geometry, h2 = l2.type;
            if (l2.geometry = [], 1 === h2) for (o2 = 0; o2 < u2.length; o2 += 2) l2.geometry.push(ye(u2[o2], u2[o2 + 1], t2, i2, s2, a2));
            else for (o2 = 0; o2 < u2.length; o2++) {
              var c2 = [];
              for (n2 = 0; n2 < u2[o2].length; n2 += 2) c2.push(ye(u2[o2][n2], u2[o2][n2 + 1], t2, i2, s2, a2));
              l2.geometry.push(c2);
            }
          }
          return e2.transformed = true, e2;
        }
        function ye(e2, t2, r3, o2, n2, i2) {
          return [Math.round(r3 * (e2 * o2 - n2)), Math.round(r3 * (t2 * o2 - i2))];
        }
        function ve(e2, t2, r3, o2, n2) {
          for (var i2 = t2 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t2) * n2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
            s2.numFeatures++, xe(s2, e2[a2], i2, n2);
            var l2 = e2[a2].minX, u2 = e2[a2].minY, h2 = e2[a2].maxX, c2 = e2[a2].maxY;
            l2 < s2.minX && (s2.minX = l2), u2 < s2.minY && (s2.minY = u2), h2 > s2.maxX && (s2.maxX = h2), c2 > s2.maxY && (s2.maxY = c2);
          }
          return s2;
        }
        function xe(e2, t2, r3, o2) {
          var n2 = t2.geometry, i2 = t2.type, s2 = [];
          if ("Point" === i2 || "MultiPoint" === i2) for (var a2 = 0; a2 < n2.length; a2 += 3) s2.push(n2[a2]), s2.push(n2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === i2) we(s2, n2, e2, r3, false, false);
          else if ("MultiLineString" === i2 || "Polygon" === i2) for (a2 = 0; a2 < n2.length; a2++) we(s2, n2[a2], e2, r3, "Polygon" === i2, 0 === a2);
          else if ("MultiPolygon" === i2) for (var l2 = 0; l2 < n2.length; l2++) {
            var u2 = n2[l2];
            for (a2 = 0; a2 < u2.length; a2++) we(s2, u2[a2], e2, r3, true, 0 === a2);
          }
          if (s2.length) {
            var h2 = t2.tags || null;
            if ("LineString" === i2 && o2.lineMetrics) {
              for (var c2 in h2 = {}, t2.tags) h2[c2] = t2.tags[c2];
              h2.mapbox_clip_start = n2.start / n2.size, h2.mapbox_clip_end = n2.end / n2.size;
            }
            var f2 = { geometry: s2, type: "Polygon" === i2 || "MultiPolygon" === i2 ? 3 : "LineString" === i2 || "MultiLineString" === i2 ? 2 : 1, tags: h2 };
            null !== t2.id && (f2.id = t2.id), e2.features.push(f2);
          }
        }
        function we(e2, t2, r3, o2, n2, i2) {
          var s2 = o2 * o2;
          if (o2 > 0 && t2.size < (n2 ? s2 : o2)) r3.numPoints += t2.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3) (0 === o2 || t2[l2 + 2] > s2) && (r3.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r3.numPoints++;
            n2 && function(e3, t3) {
              for (var r4 = 0, o3 = 0, n3 = e3.length, i3 = n3 - 2; o3 < n3; i3 = o3, o3 += 2) r4 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
              if (r4 > 0 === t3) for (o3 = 0, n3 = e3.length; o3 < n3 / 2; o3 += 2) {
                var s3 = e3[o3], a3 = e3[o3 + 1];
                e3[o3] = e3[n3 - 2 - o3], e3[o3 + 1] = e3[n3 - 1 - o3], e3[n3 - 2 - o3] = s3, e3[n3 - 1 - o3] = a3;
              }
            }(a2, i2), e2.push(a2);
          }
        }
        function Se(e2, t2) {
          var r3 = (t2 = this.options = function(e3, t3) {
            for (var r4 in t3) e3[r4] = t3[r4];
            return e3;
          }(Object.create(this.options), t2)).debug;
          if (r3 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
          var o2 = function(e3, t3) {
            var r4 = [];
            if ("FeatureCollection" === e3.type) for (var o3 = 0; o3 < e3.features.length; o3++) ee(r4, e3.features[o3], t3, o3);
            else ee(r4, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
            return r4;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t3) {
            var r4 = t3.buffer / t3.extent, o3 = e3, n2 = se(e3, 1, -1 - r4, r4, 0, -1, 2, t3), i2 = se(e3, 1, 1 - r4, 2 + r4, 0, -1, 2, t3);
            return (n2 || i2) && (o3 = se(e3, 1, -r4, 1 + r4, 0, -1, 2, t3) || [], n2 && (o3 = ge(n2, 1).concat(o3)), i2 && (o3 = o3.concat(ge(i2, -1)))), o3;
          }(o2, t2), o2.length && this.splitTile(o2, 0, 0, 0), r3 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Me(e2, t2, r3) {
          return 32 * ((1 << e2) * r3 + t2) + e2;
        }
        function Pe(e2, t2) {
          const r3 = e2.tileID.canonical;
          if (!this._geoJSONIndex) return t2(null, null);
          const o2 = this._geoJSONIndex.getTile(r3.z, r3.x, r3.y);
          if (!o2) return t2(null, null);
          const n2 = new h(o2.features);
          let i2 = c(n2);
          0 === i2.byteOffset && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t2(null, { vectorTile: n2, rawData: i2.buffer });
        }
        Se.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, Se.prototype.splitTile = function(e2, t2, r3, o2, n2, i2, s2) {
          for (var a2 = [e2, t2, r3, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
            o2 = a2.pop(), r3 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            var h2 = 1 << t2, c2 = Me(t2, r3, o2), f2 = this.tiles[c2];
            if (!f2 && (u2 > 1 && console.time("creation"), f2 = this.tiles[c2] = ve(e2, t2, r3, o2, l2), this.tileCoords.push({ z: t2, x: r3, y: o2 }), u2)) {
              u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r3, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
              var p2 = "z" + t2;
              this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
            }
            if (f2.source = e2, n2) {
              if (t2 === l2.maxZoom || t2 === n2) continue;
              var g2 = 1 << n2 - t2;
              if (r3 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2)) continue;
            } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints) continue;
            if (f2.source = null, 0 !== e2.length) {
              u2 > 1 && console.time("clipping");
              var d2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
              d2 = m2 = y2 = v2 = null, x2 = se(e2, h2, r3 - S2, r3 + P2, 0, f2.minX, f2.maxX, l2), w2 = se(e2, h2, r3 + M2, r3 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x2 && (d2 = se(x2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), m2 = se(x2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), x2 = null), w2 && (y2 = se(w2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), v2 = se(w2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t2 + 1, 2 * r3, 2 * o2), a2.push(m2 || [], t2 + 1, 2 * r3, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r3 + 1, 2 * o2), a2.push(v2 || [], t2 + 1, 2 * r3 + 1, 2 * o2 + 1);
            }
          }
        }, Se.prototype.getTile = function(e2, t2, r3) {
          var o2 = this.options, n2 = o2.extent, i2 = o2.debug;
          if (e2 < 0 || e2 > 24) return null;
          var s2 = 1 << e2, a2 = Me(e2, t2 = (t2 % s2 + s2) % s2, r3);
          if (this.tiles[a2]) return me(this.tiles[a2], n2);
          i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r3);
          for (var l2, u2 = e2, h2 = t2, c2 = r3; !l2 && u2 > 0; ) u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[Me(u2, h2, c2)];
          return l2 && l2.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r3), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? me(this.tiles[a2], n2) : null) : null;
        };
        class be extends e.VectorTileWorkerSource {
          constructor(e2, t2, r3, o2, n2) {
            super(e2, t2, r3, o2, Pe), n2 && (this.loadGeoJSON = n2);
          }
          loadData(t2, r3) {
            const o2 = t2 && t2.request, n2 = o2 && o2.collectResourceTiming;
            this.loadGeoJSON(t2, (s2, a2) => {
              if (s2 || !a2) return r3(s2);
              if ("object" != typeof a2) return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              {
                i(a2, true);
                try {
                  if (t2.filter) {
                    const r4 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === r4.result) throw new Error(r4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    const o3 = a2.features.filter((e2) => r4.value.evaluate({ zoom: 0 }, e2));
                    a2 = { type: "FeatureCollection", features: o3 };
                  }
                  this._geoJSONIndex = t2.cluster ? new J(function({ superclusterOptions: t3, clusterProperties: r4 }) {
                    if (!r4 || !t3) return t3;
                    const o3 = {}, n3 = {}, i2 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a3 = Object.keys(r4);
                    for (const t4 of a3) {
                      const [i3, s4] = r4[t4], a4 = e.createExpression(s4), l3 = e.createExpression("string" == typeof i3 ? [i3, ["accumulated"], ["get", t4]] : i3);
                      o3[t4] = a4.value, n3[t4] = l3.value;
                    }
                    return t3.map = (e2) => {
                      s3.properties = e2;
                      const t4 = {};
                      for (const e3 of a3) t4[e3] = o3[e3].evaluate(i2, s3);
                      return t4;
                    }, t3.reduce = (e2, t4) => {
                      s3.properties = t4;
                      for (const t5 of a3) i2.accumulated = e2[t5], e2[t5] = n3[t5].evaluate(i2, s3);
                    }, t3;
                  }(t2)).load(a2.features) : function(e2, t3) {
                    return new Se(e2, t3);
                  }(a2, t2.geojsonVtOptions);
                } catch (s3) {
                  return r3(s3);
                }
                this.loaded = {};
                const l2 = {};
                if (n2) {
                  const r4 = e.getPerformanceMeasurement(o2);
                  r4 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r4)));
                }
                r3(null, l2);
              }
            });
          }
          reloadTile(e2, t2) {
            const r3 = this.loaded;
            return r3 && r3[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
          }
          loadGeoJSON(t2, r3) {
            if (t2.request) e.getJSON(t2.request, r3);
            else {
              if ("string" != typeof t2.data) return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              try {
                return r3(null, JSON.parse(t2.data));
              } catch (e2) {
                return r3(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterChildren(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterLeaves(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t2(e3);
            }
          }
        }
        class ke {
          constructor(t2) {
            this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: be }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.workerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t3;
            }, this.self.registerRTLTextPlugin = (t3) => {
              if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
              e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
            };
          }
          clearCaches(e2, t2, r3) {
            delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], r3();
          }
          checkIfReady(e2, t2, r3) {
            r3();
          }
          setReferrer(e2, t2) {
            this.referrer = t2;
          }
          spriteLoaded(t2, r3) {
            this.isSpriteLoaded[t2] = r3;
            for (const o2 in this.workerSources[t2]) {
              const n2 = this.workerSources[t2][o2];
              for (const t3 in n2) n2[t3] instanceof e.VectorTileWorkerSource && (n2[t3].isSpriteLoaded = r3, n2[t3].fire(new e.Event("isSpriteLoaded")));
            }
          }
          setImages(e2, t2, r3) {
            this.availableImages[e2] = t2;
            for (const r4 in this.workerSources[e2]) {
              const o2 = this.workerSources[e2][r4];
              for (const e3 in o2) o2[e3].availableImages = t2;
            }
            r3();
          }
          enableTerrain(e2, t2, r3) {
            this.terrain = t2, r3();
          }
          setProjection(t2, r3) {
            this.projections[t2] = e.getProjection(r3);
          }
          setLayers(e2, t2, r3) {
            this.getLayerIndex(e2).replace(t2), r3();
          }
          updateLayers(e2, t2, r3) {
            this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r3();
          }
          loadTile(t2, r3, o2) {
            const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
            n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r3.type, r3.source).loadTile(n2, o2);
          }
          loadDEMTile(t2, r3, o2) {
            const n2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r3) : r3;
            this.getDEMWorkerSource(t2, r3.source).loadTile(n2, o2);
          }
          reloadTile(t2, r3, o2) {
            const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r3) : r3;
            n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r3.type, r3.source).reloadTile(n2, o2);
          }
          abortTile(e2, t2, r3) {
            this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r3);
          }
          removeTile(e2, t2, r3) {
            this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r3);
          }
          removeSource(e2, t2, r3) {
            if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source]) return;
            const o2 = this.workerSources[e2][t2.type][t2.source];
            delete this.workerSources[e2][t2.type][t2.source], void 0 !== o2.removeSource ? o2.removeSource(t2, r3) : r3();
          }
          loadWorkerSource(e2, t2, r3) {
            try {
              this.self.importScripts(t2.url), r3();
            } catch (e3) {
              r3(e3.toString());
            }
          }
          syncRTLPluginState(t2, r3, o2) {
            try {
              e.plugin.setState(r3);
              const t3 = e.plugin.getPluginURL();
              if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t3) {
                this.self.importScripts(t3);
                const r4 = e.plugin.isParsed();
                o2(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r4);
              }
            } catch (e2) {
              o2(e2.toString());
            }
          }
          getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          getLayerIndex(e2) {
            let t2 = this.layerIndexes[e2];
            return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
          }
          getWorkerSource(e2, t2, r3) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r3]) {
              const o2 = { send: (t3, r4, o3, n2, i2, s2) => {
                this.actor.send(t3, r4, o3, e2, i2, s2);
              }, scheduler: this.actor.scheduler };
              this.workerSources[e2][t2][r3] = new this.workerSourceTypes[t2](o2, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded[e2]);
            }
            return this.workerSources[e2][t2][r3];
          }
          getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
          }
          enforceCacheSizeLimit(t2, r3) {
            e.enforceCacheSizeLimit(r3);
          }
          getWorkerPerformanceMetrics(e2, t2, r3) {
            r3(void 0, void 0);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2, i2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(i2) || e2.length !== i2.length) return false;
            for (let o2 = 0; o2 < e2.length; o2++) if (!t(e2[o2], i2[o2])) return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== i2) {
            if ("object" != typeof i2) return false;
            if (Object.keys(e2).length !== Object.keys(i2).length) return false;
            for (const o2 in e2) if (!t(e2[o2], i2[o2])) return false;
            return true;
          }
          return e2 === i2;
        }
        var i = o;
        function o(e2) {
          return !function(e3) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return false;
              var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
              try {
                t3 = new Worker(o2), e4 = true;
              } catch (t4) {
                e4 = false;
              }
              return t3 && t3.terminate(), URL.revokeObjectURL(o2), e4;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var e4 = document.createElement("canvas");
              e4.width = e4.height = 1;
              var t3 = e4.getContext("2d");
              if (!t3) return false;
              var i2 = t3.getImageData(0, 0, 1, 1);
              return i2 && i2.width === e4.width;
            }() ? (void 0 === r2[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (r2[t2] = function(e4) {
              var t3, i2 = function(e5) {
                var t4 = document.createElement("canvas"), i3 = Object.create(o.webGLContextAttributes);
                return i3.failIfMajorPerformanceCaveat = e5, t4.getContext("webgl", i3) || t4.getContext("experimental-webgl", i3);
              }(e4);
              if (!i2) return false;
              try {
                t3 = i2.createShader(i2.VERTEX_SHADER);
              } catch (e5) {
                return false;
              }
              return !(!t3 || i2.isContextLost()) && (i2.shaderSource(t3, "void main() {}"), i2.compileShader(t3), true === i2.getShaderParameter(t3, i2.COMPILE_STATUS));
            }(t2)), r2[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var t2;
          }(e2);
        }
        var r2 = {};
        function n(t2, i2, o2) {
          const r3 = e.window.document.createElement(t2);
          return void 0 !== i2 && (r3.className = i2), o2 && o2.appendChild(r3), r3;
        }
        function s(t2, i2, o2) {
          const r3 = e.window.document.createElementNS("http://www.w3.org/2000/svg", t2);
          for (const e2 of Object.keys(i2)) r3.setAttributeNS(null, e2, i2[e2]);
          return o2 && o2.appendChild(r3), r3;
        }
        o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a = e.window.document && e.window.document.documentElement.style, l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
        let c;
        function h() {
          a && l && (c = a[l], a[l] = "none");
        }
        function u() {
          a && l && (a[l] = c);
        }
        function _(t2) {
          t2.preventDefault(), t2.stopPropagation(), e.window.removeEventListener("click", _, true);
        }
        function d() {
          e.window.addEventListener("click", _, true), e.window.setTimeout(() => {
            e.window.removeEventListener("click", _, true);
          }, 0);
        }
        function p(e2, t2) {
          const i2 = e2.getBoundingClientRect();
          return g(e2, i2, t2);
        }
        function m(e2, t2) {
          const i2 = e2.getBoundingClientRect(), o2 = [];
          for (let r3 = 0; r3 < t2.length; r3++) o2.push(g(e2, i2, t2[r3]));
          return o2;
        }
        function f(t2) {
          return void 0 !== e.window.InstallTrigger && 2 === t2.button && t2.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
        }
        function g(t2, i2, o2) {
          const r3 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
          return new e.pointGeometry((o2.clientX - i2.left) * r3, (o2.clientY - i2.top) * r3);
        }
        function v(e2, t2) {
          var i2 = t2[0], o2 = t2[1], r3 = t2[2], n2 = t2[3], s2 = i2 * n2 - r3 * o2;
          return s2 ? (e2[0] = n2 * (s2 = 1 / s2), e2[1] = -o2 * s2, e2[2] = -r3 * s2, e2[3] = i2 * s2, e2) : null;
        }
        function x(e2) {
          const { userImage: t2 } = e2;
          return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
        }
        class y extends e.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e2) {
            if (this.loaded !== e2 && (this.loaded = e2, e2)) {
              for (const { ids: e3, callback: t2 } of this.requestors) this._notify(e3, t2);
              this.requestors = [];
            }
          }
          hasImage(e2) {
            return !!this.getImage(e2);
          }
          getImage(e2) {
            return this.images[e2];
          }
          addImage(e2, t2) {
            this._validate(e2, t2) && (this.images[e2] = t2);
          }
          _validate(t2, i2) {
            let o2 = true;
            return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
          }
          _validateStretch(e2, t2) {
            if (!e2) return true;
            let i2 = 0;
            for (const o2 of e2) {
              if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1]) return false;
              i2 = o2[1];
            }
            return true;
          }
          _validateContent(e2, t2) {
            return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
          }
          updateImage(e2, t2) {
            t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
          }
          removeImage(e2) {
            const t2 = this.images[e2];
            delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e2, t2) {
            let i2 = true;
            if (!this.isLoaded()) for (const t3 of e2) this.images[t3] || (i2 = false);
            this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
          }
          _notify(t2, i2) {
            const o2 = {};
            for (const i3 of t2) {
              this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
              const t3 = this.images[i3];
              t3 ? o2[i3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i2(null, o2);
          }
          getPixelSize() {
            const { width: e2, height: t2 } = this.atlasImage;
            return { width: e2, height: t2 };
          }
          getPattern(t2) {
            const i2 = this.patterns[t2], o2 = this.getImage(t2);
            if (!o2) return null;
            if (i2 && i2.position.version === o2.version) return i2.position;
            if (i2) i2.position.version = o2.version;
            else {
              const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r3 = new e.ImagePosition(i3, o2);
              this.patterns[t2] = { bin: i3, position: r3 };
            }
            return this._updatePatternAtlas(), this.patterns[t2].position;
          }
          bind(t2) {
            const i2 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t2, this.atlasImage, i2.RGBA), this.atlasTexture && this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t2 = [];
            for (const e2 in this.patterns) t2.push(this.patterns[e2].bin);
            const { w: i2, h: o2 } = e.potpack(t2), r3 = this.atlasImage;
            r3.resize({ width: i2 || 1, height: o2 || 1 });
            for (const t3 in this.patterns) {
              const { bin: i3 } = this.patterns[t3], o3 = i3.x + 1, n2 = i3.y + 1, s2 = this.images[t3].data, a2 = s2.width, l2 = s2.height;
              e.RGBAImage.copy(s2, r3, { x: 0, y: 0 }, { x: o3, y: n2 }, { width: a2, height: l2 }), e.RGBAImage.copy(s2, r3, { x: 0, y: l2 - 1 }, { x: o3, y: n2 - 1 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r3, { x: 0, y: 0 }, { x: o3, y: n2 + l2 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r3, { x: a2 - 1, y: 0 }, { x: o3 - 1, y: n2 }, { width: 1, height: l2 }), e.RGBAImage.copy(s2, r3, { x: 0, y: 0 }, { x: o3 + a2, y: n2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (const t2 of e2) {
              if (this.callbackDispatchedThisFrame[t2]) continue;
              this.callbackDispatchedThisFrame[t2] = true;
              const e3 = this.images[t2];
              x(e3) && this.updateImage(t2, e3);
            }
          }
        }
        const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
          constructor() {
            this.specification = e.spec.light.position;
          }
          possiblyEvaluate(t2, i2) {
            return function([t3, i3, o2]) {
              const r3 = e.degToRad(i3 + 90), n2 = e.degToRad(o2);
              return { x: t3 * Math.cos(r3) * Math.sin(n2), y: t3 * Math.sin(r3) * Math.sin(n2), z: t3 * Math.cos(n2), azimuthal: i3, polar: o2 };
            }(t2.expression.evaluate(i2));
          }
          interpolate(t2, i2, o2) {
            return { x: e.number(t2.x, i2.x, o2), y: e.number(t2.y, i2.y, o2), z: e.number(t2.z, i2.z, o2), azimuthal: e.number(t2.azimuthal, i2.azimuthal, o2), polar: e.number(t2.polar, i2.polar, o2) };
          }
        }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), w = "-transition";
        class T extends e.Evented {
          constructor(t2) {
            super(), this._transitionable = new e.Transitionable(b), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t2, i2 = {}) {
            if (!this._validate(e.validateLight, t2, i2)) for (const i3 in t2) {
              const o2 = t2[i3];
              e.endsWith(i3, w) ? this._transitionable.setTransition(i3.slice(0, -w.length), o2) : this._transitionable.setValue(i3, o2);
            }
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
          }
        }
        const E = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), C = "-transition";
        class M extends e.Evented {
          constructor(t2, i2) {
            super(), this._transitionable = new e.Transitionable(E), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2) {
            for (const i2 in t2) {
              const o2 = t2[i2];
              e.endsWith(i2, C) ? this._transitionable.setTransition(i2.slice(0, -C.length), o2) : this._transitionable.setValue(i2, o2);
            }
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
        }
        function I(t2, i2, o2, r3) {
          const n2 = e.smoothstep(45, 65, o2), [s2, a2] = S(t2, r3), l2 = e.length(i2);
          let c2 = 1 - Math.min(1, Math.exp((l2 - s2) / (a2 - s2) * -6));
          return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n2 * t2.alpha;
        }
        function S(e2, t2) {
          const i2 = 0.5 / Math.tan(0.5 * t2);
          return [e2.range[0] + i2, e2.range[1] + i2];
        }
        const D = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }), L = "-transition";
        class A extends e.Evented {
          constructor(t2, i2) {
            super(), this._transitionable = new e.Transitionable(D), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
          }
          get state() {
            const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.globeToMercatorTransition(t2.zoom), r3 = this.properties.get("range"), n2 = [0.5, 3];
            return { range: i2 ? [e.number(n2[0], r3[0], o2), e.number(n2[1], r3[1], o2)] : r3, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2, i2 = {}) {
            if (!this._validate(e.validateFog, t2, i2)) {
              for (const i3 of Object.keys(e.spec.fog)) t2 && void 0 === t2[i3] && (t2[i3] = e.spec.fog[i3].default);
              for (const i3 in t2) {
                const o2 = t2[i3];
                e.endsWith(i3, L) ? this._transitionable.setTransition(i3.slice(0, -L.length), o2) : this._transitionable.setValue(i3, o2);
              }
            }
          }
          getOpacity(t2) {
            if (!this._transform.projection.supportsFog) return 0;
            const i2 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t2)) * i2.a;
          }
          getOpacityAtLatLng(t2, i2) {
            return this._transform.projection.supportsFog ? function(t3, i3, o2) {
              const r3 = e.MercatorCoordinate.fromLngLat(i3), n2 = o2.elevation ? o2.elevation.getAtPointOrZero(r3) : 0, s2 = [r3.x, r3.y, n2];
              return e.transformMat4(s2, s2, o2.mercatorFogMatrix), I(t3, s2, o2.pitch, o2._fov);
            }(this.state, t2, i2) : 0;
          }
          getFovAdjustedRange(e2) {
            return this._transform.projection.supportsFog ? S(this.state, e2) : [0, 1];
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
          }
        }
        class z {
          constructor(t2, i2) {
            this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
            const o2 = this.workerPool.acquire(this.id);
            for (let e2 = 0; e2 < o2.length; e2++) {
              const t3 = new z.Actor(o2[e2], i2, this.id);
              t3.name = `Worker ${e2}`, this.actors.push(t3);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t2, i2, o2) {
            e.asyncAll(this.actors, (e2, o3) => {
              e2.send(t2, i2, o3);
            }, o2 = o2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e2) => {
              e2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function P(t2, i2, o2) {
          return i2 * (e.EXTENT / (t2.tileSize * Math.pow(2, o2 - t2.tileID.overscaledZ)));
        }
        z.Actor = e.Actor;
        class R {
          constructor(e2, t2, i2, o2) {
            this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
          }
          static createFromScreenPoints(t2, i2) {
            let o2, r3;
            if (t2 instanceof e.pointGeometry || "number" == typeof t2[0]) {
              const n2 = e.pointGeometry.convert(t2);
              o2 = [n2], r3 = i2.isPointAboveHorizon(n2);
            } else {
              const n2 = e.pointGeometry.convert(t2[0]), s2 = e.pointGeometry.convert(t2[1]);
              o2 = [n2, s2], r3 = e.polygonizeBounds(n2, s2).every((e2) => i2.isPointAboveHorizon(e2));
            }
            return new R(o2, i2.getCameraPoint(), r3, i2);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t2) {
            return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
          }
          bufferedCameraGeometry(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r3 = e.polygonizeBounds(i2, o2, 0, false);
            return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r3[3] = this.cameraPoint)), e.bufferConvexPolygon(r3, t2);
          }
          bufferedCameraGeometryGlobe(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r3 = e.polygonizeBounds(i2, o2, t2), n2 = this.cameraPoint.clone();
            switch (3 * ((n2.y > i2.y) + (n2.y > o2.y)) + ((n2.x > i2.x) + (n2.x > o2.x))) {
              case 0:
                r3[0] = n2, r3[4] = n2.clone();
                break;
              case 1:
                r3.splice(1, 0, n2);
                break;
              case 2:
                r3[1] = n2;
                break;
              case 3:
                r3.splice(4, 0, n2);
                break;
              case 5:
                r3.splice(2, 0, n2);
                break;
              case 6:
                r3[3] = n2;
                break;
              case 7:
                r3.splice(3, 0, n2);
                break;
              case 8:
                r3[2] = n2;
            }
            return r3;
          }
          containsTile(t2, i2, o2, r3 = 0) {
            const n2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, s2 = o2 ? this._bufferedCameraMercator(n2, i2) : this._bufferedScreenMercator(n2, i2);
            let a2 = t2.tileID.wrap + (s2.unwrapped ? r3 : 0);
            const l2 = s2.polygon.map((i3) => e.getTilePoint(t2.tileTransform, i3, a2));
            if (!e.polygonIntersectsBox(l2, 0, 0, e.EXTENT, e.EXTENT)) return;
            a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r3 : 0);
            const c2 = this.screenGeometryMercator.polygon.map((i3) => e.getTileVec3(t2.tileTransform, i3, a2)), h2 = c2.map((t3) => new e.pointGeometry(t3[0], t3[1])), u2 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), _2 = e.getTileVec3(t2.tileTransform, u2, a2), d2 = c2.map((t3) => {
              const i3 = e.sub(t3, t3, _2);
              return e.normalize(i3, i3), new e.Ray(_2, i3);
            }), p2 = P(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: d2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m2 = e.getBounds(l2), m2.min.x = e.clamp(m2.min.x, 0, e.EXTENT), m2.min.y = e.clamp(m2.min.y, 0, e.EXTENT), m2.max.x = e.clamp(m2.max.x, 0, e.EXTENT), m2.max.y = e.clamp(m2.max.y, 0, e.EXTENT), m2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
            var m2;
          }
          _bufferedScreenMercator(e2, t2) {
            const i2 = k(e2);
            if (this._screenRaycastCache[i2]) return this._screenRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
            }
          }
          _bufferedCameraMercator(e2, t2) {
            const i2 = k(e2);
            if (this._cameraRaycastCache[i2]) return this._cameraRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
            }
          }
          _projectAndResample(t2, i2) {
            const o2 = function(t3, i3) {
              const o3 = e.multiply([], i3.pixelMatrix, i3.globeMatrix), r4 = [0, -e.GLOBE_RADIUS, 0, 1], n2 = [0, e.GLOBE_RADIUS, 0, 1], s2 = [0, 0, 0, 1];
              e.transformMat4$1(r4, r4, o3), e.transformMat4$1(n2, n2, o3), e.transformMat4$1(s2, s2, o3);
              const a2 = new e.pointGeometry(r4[0] / r4[3], r4[1] / r4[3]), l2 = new e.pointGeometry(n2[0] / n2[3], n2[1] / n2[3]), c2 = e.polygonContainsPoint(t3, a2) && r4[3] < s2[3], h2 = e.polygonContainsPoint(t3, l2) && n2[3] < s2[3];
              if (!c2 && !h2) return null;
              const u2 = function(e2, t4, i4) {
                for (let o4 = 1; o4 < e2.length; o4++) {
                  const r5 = B(t4.pointCoordinate3D(e2[o4 - 1]).x), n3 = B(t4.pointCoordinate3D(e2[o4]).x);
                  if (i4 < 0) {
                    if (r5 < n3) return { idx: o4, t: -r5 / (n3 - 1 - r5) };
                  } else if (n3 < r5) return { idx: o4, t: (1 - r5) / (n3 + 1 - r5) };
                }
                return null;
              }(t3, i3, c2 ? -1 : 1);
              if (!u2) return null;
              const { idx: _2, t: d2 } = u2;
              let p2 = _2 > 1 ? O(t3.slice(0, _2), i3) : [], m2 = _2 < t3.length ? O(t3.slice(_2), i3) : [];
              p2 = p2.map((t4) => new e.pointGeometry(B(t4.x), t4.y)), m2 = m2.map((t4) => new e.pointGeometry(B(t4.x), t4.y));
              const f2 = [...p2];
              0 === f2.length && f2.push(m2[m2.length - 1]);
              const g2 = e.number(f2[f2.length - 1].y, (0 === m2.length ? p2[0] : m2[0]).y, d2);
              let v2;
              return v2 = c2 ? [new e.pointGeometry(0, g2), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g2)] : [new e.pointGeometry(1, g2), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g2)], f2.push(...v2), 0 === m2.length ? f2.push(p2[0]) : f2.push(...m2), { polygon: f2.map((t4) => new e.MercatorCoordinate(t4.x, t4.y)), unwrapped: false };
            }(t2, i2);
            if (o2) return o2;
            const r3 = function(t3, i3) {
              let o3 = false, r4 = -1 / 0, n2 = 0;
              for (let e2 = 0; e2 < t3.length - 1; e2++) t3[e2].x > r4 && (r4 = t3[e2].x, n2 = e2);
              for (let e2 = 0; e2 < t3.length - 1; e2++) {
                const i4 = (n2 + e2) % (t3.length - 1), r5 = t3[i4], s3 = t3[i4 + 1];
                Math.abs(r5.x - s3.x) > 0.5 && (r5.x < s3.x ? (r5.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (s3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
              }
              const s2 = e.mercatorXfromLng(i3.center.lng);
              return o3 && s2 < Math.abs(s2 - 1) && t3.forEach((e2) => {
                e2.x -= 1;
              }), { polygon: t3, unwrapped: o3 };
            }(O(t2, i2).map((t3) => new e.pointGeometry(B(t3.x), t3.y)), i2);
            return { polygon: r3.polygon.map((t3) => new e.MercatorCoordinate(t3.x, t3.y)), unwrapped: r3.unwrapped };
          }
        }
        function O(t2, i2) {
          return e.resample(t2, (e2) => {
            const t3 = i2.pointCoordinate3D(e2);
            e2.x = t3.x, e2.y = t3.y;
          }, 1 / 256);
        }
        function B(e2) {
          return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
        }
        function k(e2) {
          return 100 * e2 | 0;
        }
        function F(t2, i2, o2, r3, n2) {
          const s2 = function(o3, r4) {
            if (o3) return n2(o3);
            if (r4) {
              t2.url && r4.tiles && t2.tiles && delete t2.tiles;
              const o4 = e.pick(e.extend(r4, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              r4.vector_layers && (o4.vectorLayers = r4.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), n2(null, o4);
            }
          };
          return t2.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r3), e.ResourceType.Source), s2) : e.exported.frame(() => s2(null, t2));
        }
        class U {
          constructor(t2, i2, o2) {
            this.bounds = e.LngLatBounds.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(e2) {
            return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
          }
          contains(t2) {
            const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r3 = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n2 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), s2 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
            return t2.x >= o2 && t2.x < n2 && t2.y >= r3 && t2.y < s2;
          }
        }
        class N {
          constructor(e2, t2, i2) {
            this.context = e2;
            const o2 = e2.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const G = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class j {
          constructor(e2, t2, i2, o2) {
            this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
            const r3 = e2.gl;
            this.buffer = r3.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r3.bufferData(r3.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || t2.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          enableAttributes(e2, t2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const o2 = t2.attributes[this.attributes[i2].name];
              void 0 !== o2 && e2.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(e2, t2, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const r3 = this.attributes[o2], n2 = t2.attributes[r3.name];
              void 0 !== n2 && e2.vertexAttribPointer(n2, r3.components, e2[G[r3.type]], false, this.itemSize, r3.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Z {
          constructor(e2) {
            this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class V extends Z {
          getDefault() {
            return e.Color.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class W extends Z {
          getDefault() {
            return 1;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
          }
        }
        class X extends Z {
          getDefault() {
            return 0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
          }
        }
        class q extends Z {
          getDefault() {
            return [true, true, true, true];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class $ extends Z {
          getDefault() {
            return true;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class H extends Z {
          getDefault() {
            return 255;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class Y extends Z {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e2) {
            const t2 = this.current;
            (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
          }
        }
        class K extends Z {
          getDefault() {
            const e2 = this.gl;
            return [e2.KEEP, e2.KEEP, e2.KEEP];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
          }
        }
        class J extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
          }
        }
        class Q extends Z {
          getDefault() {
            return [0, 1];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class ee extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
          }
        }
        class te extends Z {
          getDefault() {
            return this.gl.LESS;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
          }
        }
        class ie extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
          }
        }
        class oe extends Z {
          getDefault() {
            const e2 = this.gl;
            return [e2.ONE, e2.ZERO];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class re extends Z {
          getDefault() {
            return e.Color.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class ne extends Z {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
          }
        }
        class se extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
          }
        }
        class ae extends Z {
          getDefault() {
            return this.gl.BACK;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class le extends Z {
          getDefault() {
            return this.gl.CCW;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class ce extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
          }
        }
        class he extends Z {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
          }
        }
        class ue extends Z {
          getDefault() {
            const e2 = this.gl;
            return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class _e extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class de extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class pe extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
          }
        }
        class me extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class fe extends Z {
          getDefault() {
            return null;
          }
          set(e2) {
            const t2 = this.gl;
            t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class ge extends Z {
          constructor(e2) {
            super(e2), this.vao = e2.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(e2) {
            this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
          }
        }
        class ve extends Z {
          getDefault() {
            return 4;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
          }
        }
        class xe extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class ye extends Z {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class be extends Z {
          constructor(e2, t2) {
            super(e2), this.context = e2, this.parent = t2;
          }
          getDefault() {
            return null;
          }
        }
        class we extends be {
          setDirty() {
            this.dirty = true;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
          }
        }
        class Te extends be {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ee extends Te {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class Ce {
          constructor(e2, t2, i2, o2) {
            this.context = e2, this.width = t2, this.height = i2;
            const r3 = this.framebuffer = e2.gl.createFramebuffer();
            this.colorAttachment = new we(e2, r3), o2 && (this.depthAttachment = new Te(e2, r3));
          }
          destroy() {
            const e2 = this.context.gl, t2 = this.colorAttachment.get();
            if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
              const t3 = this.depthAttachment.get();
              t3 && e2.deleteRenderbuffer(t3);
            }
            e2.deleteFramebuffer(this.framebuffer);
          }
        }
        class Me {
          constructor(e2, t2 = false) {
            if (this.gl = e2, this.isWebGL2 = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t2) {
              const t3 = e2;
              this.extVertexArrayObject = { createVertexArrayOES: t3.createVertexArray.bind(e2), deleteVertexArrayOES: t3.deleteVertexArray.bind(e2), bindVertexArrayOES: t3.bindVertexArray.bind(e2) };
            }
            this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t2 || (this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float")), (t2 || this.extTextureHalfFloat && e2.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t2 || e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e2, t2) {
            return new N(this, e2, t2);
          }
          createVertexBuffer(e2, t2, i2) {
            return new j(this, e2, t2, i2);
          }
          createRenderbuffer(e2, t2, i2) {
            const o2 = this.gl, r3 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(r3), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r3;
          }
          createFramebuffer(e2, t2, i2) {
            return new Ce(this, e2, t2, i2);
          }
          clear({ color: e2, depth: t2, stencil: i2 }) {
            const o2 = this.gl;
            let r3 = 0;
            e2 && (r3 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r3 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r3 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r3);
          }
          setCullFace(e2) {
            false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
          }
          setDepthMode(e2) {
            e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
          }
          setStencilMode(e2) {
            e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(i2) {
            t(i2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor)), this.colorMask.set(i2.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class Ie extends e.Evented {
          constructor(t2, i2, o2, r3) {
            if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
          }
          load(t2) {
            this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" }));
            const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
            this._tileJSONRequest = F(this._options, this.map._requestManager, i2, o2, (r3, n2) => {
              this._tileJSONRequest = null, this._loaded = true, r3 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.ErrorEvent(r3))) : n2 && (e.extend(this, n2), n2.bounds && (this.tileBounds = new U(n2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r3);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e.extend({}, this._options);
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile };
            if (r3.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state) "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r3, n2.bind(this));
            else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready) t2.request = t2.actor.send("loadTile", r3, n2.bind(this), void 0, true);
            else {
              const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r3, (e2, i4) => {
                e2 || !i4 ? n2.call(this, e2) : (r3.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r3, n2.bind(this), void 0, true));
              }, true);
              t2.request = { cancel: i3 };
            }
            function n2(o3, r4) {
              return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r4 && r4.resourceTiming && (t2.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && t2.setExpiryData(r4), t2.loadVectorData(r4, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
            }
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          unloadTile(e2) {
            e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Se extends e.Evented {
          constructor(t2, i2, o2, r3) {
            super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
          }
          load(t2) {
            this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i2, o2) => {
              this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.ErrorEvent(i2)) : o2 && (e.extend(this, o2), o2.bounds && (this.tileBounds = new U(o2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e.extend({}, this._options);
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(t2, i2) {
            const o2 = e.exported.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
            t2.request = e.getImage(this.map._requestManager.transformRequest(r3, e.ResourceType.Tile), (o3, r4, n2, s2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r4 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: s2 }), t2.setTexture(r4, this.map.painter), t2.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i2(null)) : i2(null)));
          }
          static loadTileData(e2, t2, i2) {
            e2.setTexture(t2, i2);
          }
          static unloadTileData(e2, t2) {
            e2.texture && t2.saveTileTexture(e2.texture);
          }
          abortTile(e2, t2) {
            e2.request && (e2.request.cancel(), delete e2.request), t2();
          }
          unloadTile(e2, t2) {
            e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        let De;
        function Le(t2, i2, o2, r3, n2, s2, a2, l2) {
          const c2 = [t2, o2, n2, i2, r3, s2, 1, 1, 1], h2 = [a2, l2, 1], u2 = e.adjoint([], c2), [_2, d2, p2] = e.transformMat3(h2, h2, e.transpose(u2, u2));
          return e.multiply$1(c2, [_2, 0, 0, 0, d2, 0, 0, 0, p2], c2);
        }
        class Ae extends e.Evented {
          constructor(e2, t2, i2, o2) {
            super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t2, this._dirty = false;
          }
          load(t2, i2) {
            this._loaded = i2 || false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i3, o2) => {
              if (this._imageRequest = null, this._loaded = true, i3) this.fire(new e.ErrorEvent(i3));
              else if (o2) {
                const { HTMLImageElement: i4 } = e.window;
                this.image = o2 instanceof i4 ? e.exported.getImageData(o2) : o2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading();
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e2) {
            return this.image && e2.url ? (this._imageRequest && e2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          onRemove() {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
          }
          setCoordinates(t2) {
            this.coordinates = t2, this._boundsArray = void 0;
            const i2 = t2.map(e.MercatorCoordinate.fromLngLat);
            return this.tileID = function(t3) {
              let i3 = 1 / 0, o2 = 1 / 0, r3 = -1 / 0, n2 = -1 / 0;
              for (const e2 of t3) i3 = Math.min(i3, e2.x), o2 = Math.min(o2, e2.y), r3 = Math.max(r3, e2.x), n2 = Math.max(n2, e2.y);
              const s2 = Math.max(r3 - i3, n2 - o2), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, a2);
              return new e.CanonicalTileID(a2, Math.floor((i3 + r3) / 2 * l2), Math.floor((o2 + n2) / 2 * l2));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0;
          }
          _prepareData(t2) {
            for (const e2 in this.tiles) {
              const t3 = this.tiles[e2];
              "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
            }
            if (this._boundsArray) return;
            const i2 = e.tileTransform(this.tileID, this.map.transform.projection), [o2, r3, n2, s2] = this.coordinates.map((t3) => {
              const o3 = i2.projection.project(t3[0], t3[1]);
              return e.getTilePoint(i2, o3)._round();
            });
            this.perspectiveTransform = function(t3, i3, o3, r4, n3, s3, a3, l2, c2, h2) {
              const u2 = Le(0, 0, t3, 0, 0, i3, t3, i3), _2 = Le(o3, r4, n3, s3, a3, l2, c2, h2);
              return e.multiply$1(_2, e.adjoint(u2, u2), _2), [_2[6] / _2[8] * t3 / e.EXTENT, _2[7] / _2[8] * i3 / e.EXTENT];
            }(this.width, this.height, o2.x, o2.y, r3.x, r3.y, s2.x, s2.y, n2.x, n2.y);
            const a2 = this._boundsArray = new e.StructArrayLayout4i8();
            a2.emplaceBack(o2.x, o2.y, 0, 0), a2.emplaceBack(r3.x, r3.y, e.EXTENT, 0), a2.emplaceBack(s2.x, s2.y, 0, e.EXTENT), a2.emplaceBack(n2.x, n2.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t2.createVertexBuffer(a2, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(t2);
          }
          loadTile(e2, t2) {
            this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        const ze = { vector: Ie, raster: Se, "raster-dem": class extends Se {
          constructor(t2, i2, o2, r3) {
            super(t2, i2, o2, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r3(e2, o3) {
              e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
            }
            t2.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), function(o3, n2, s2, a2) {
              if (delete t2.request, t2.aborted) t2.state = "unloaded", i2(null);
              else if (o3) t2.state = "errored", i2(o3);
              else if (n2) {
                this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: a2 });
                const i3 = e.window.ImageBitmap && n2 instanceof e.window.ImageBitmap && (null == De && (De = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), De), o4 = 1 - (n2.width - e.prevPowerOfTwo(n2.width)) / 2;
                o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                const l2 = i3 ? n2 : e.exported.getImageData(n2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
                t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r3.bind(this), void 0, true));
              }
            }.bind(this));
          }
          _getNeighboringTiles(t2) {
            const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r3 = (i2.x - 1 + o2) % o2, n2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, s2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
            return l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r3, i2.y).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r3, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r3, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(e2) {
            e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
          }
        }, geojson: class extends e.Evented {
          constructor(t2, i2, o2, r3) {
            super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r3), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const n2 = e.EXTENT / this.tileSize;
            this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * n2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * n2, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * n2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
          }
          onAdd(e2) {
            this.map = e2, this.setData(this._data);
          }
          setData(e2) {
            return this._data = e2, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e2, t2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
          }
          getClusterChildren(e2, t2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
          }
          getClusterLeaves(e2, t2, i2, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, o2), this;
          }
          _updateWorkerData() {
            if (this._pendingLoad) return void (this._coalesce = true);
            this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
            const t2 = e.extend({}, this.workerOptions), i2 = this._data;
            "string" == typeof i2 ? (t2.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
              if (this._loaded = true, this._pendingLoad = null, t3) this.fire(new e.ErrorEvent(t3));
              else {
                const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t4)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t2, i2) {
            const o2 = t2.actor ? "reloadTile" : "loadTile";
            t2.actor = this.actor, t2.request = this.actor.send(o2, { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r3) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
          }
          unloadTile(e2) {
            e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends Ae {
          constructor(e2, t2, i2, o2) {
            super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
          }
          load() {
            this._loaded = false;
            const t2 = this.options;
            this.urls = [];
            for (const i2 of t2.urls) this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
            e.getVideo(this.urls, (t3, i2) => {
              this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t2) {
            if (this.video) {
              const i2 = this.video.seekable;
              t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e2) {
            this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: Ae, canvas: class extends Ae {
          constructor(t2, i2, o2, r3) {
            super(t2, i2, o2, r3), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e2) {
            this.map = e2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i2 = this.map.painter.context;
            this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
            return false;
          }
        }, custom: class extends e.Evented {
          constructor(t2, i2, o2, r3) {
            super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r3), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this._map = t2, this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
          }
          onRemove(e2) {
            this._implementation.onRemove && this._implementation.onRemove(e2);
          }
          hasTile(e2) {
            if (this._implementation.hasTile) {
              const { x: t2, y: i2, z: o2 } = e2.canonical;
              return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
            }
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(t2, i2) {
            const { x: o2, y: r3, z: n2 } = t2.tileID.canonical, s2 = new e.window.AbortController();
            t2.request = Promise.resolve(this._implementation.loadTile({ x: o2, y: r3, z: n2 }, { signal: s2.signal })).then(function(o3) {
              return delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : void 0 === o3 ? (t2.state = "errored", i2(null)) : null === o3 ? (this.loadTileData(t2, { width: this.tileSize, height: this.tileSize, data: null }), t2.state = "loaded", i2(null)) : function(t3) {
                return t3 instanceof e.window.ImageData || t3 instanceof e.window.HTMLCanvasElement || t3 instanceof e.window.ImageBitmap || t3 instanceof e.window.HTMLImageElement;
              }(o3) ? (this.loadTileData(t2, o3), t2.state = "loaded", void i2(null)) : (t2.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }.bind(this)).catch((e2) => {
              20 !== e2.code && (t2.state = "errored", i2(e2));
            }), t2.request.cancel = () => s2.abort();
          }
          loadTileData(e2, t2) {
            Se.loadTileData(e2, t2, this._map.painter);
          }
          unloadTileData(e2) {
            Se.unloadTileData(e2, this._map.painter);
          }
          unloadTile(e2, t2) {
            if (this.unloadTileData(e2), this._implementation.unloadTile) {
              const { x: t3, y: i2, z: o2 } = e2.tileID.canonical;
              this._implementation.unloadTile({ x: t3, y: i2, z: o2 });
            }
            t2();
          }
          abortTile(e2, t2) {
            e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
          }
          _clearTiles() {
            this._map.style._clearSource(this.id);
          }
          _update() {
            this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, Pe = function(t2, i2, o2, r3) {
          const n2 = new ze[i2.type](t2, i2, o2, r3);
          if (n2.id !== t2) throw new Error(`Expected Source id to be ${t2} instead of ${n2.id}`);
          return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
        };
        function Re(t2, i2) {
          const o2 = e.identity([]);
          return e.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
        }
        function Oe(e2, t2, i2, o2, r3, n2, s2, a2 = false) {
          const l2 = e2.tilesIn(o2, s2, a2);
          l2.sort(ke);
          const c2 = [];
          for (const o3 of l2) c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r3, n2, Re(e2.transform, o3.tile.tileID), a2) });
          const h2 = function(e3) {
            const t3 = {}, i3 = {};
            for (const o3 of e3) {
              const e4 = o3.queryResults, r4 = o3.wrappedTileID, n3 = i3[r4] = i3[r4] || {};
              for (const i4 in e4) {
                const o4 = e4[i4], r5 = n3[i4] = n3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
                for (const e5 of o4) r5[e5.featureIndex] || (r5[e5.featureIndex] = true, s3.push(e5));
              }
            }
            return t3;
          }(c2);
          for (const t3 in h2) h2[t3].forEach((t4) => {
            const i3 = t4.feature, o3 = i3.layer;
            o3 && "background" !== o3.type && "sky" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
          });
          return h2;
        }
        function Be(e2, t2) {
          const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r3 = {};
          for (let e3 = 0; e3 < i2.length; e3++) {
            const n2 = i2[e3], s2 = n2.tileID.canonical.key;
            r3[s2] || (r3[s2] = true, n2.querySourceFeatures(o2, t2));
          }
          return o2;
        }
        function ke(e2, t2) {
          const i2 = e2.tileID, o2 = t2.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        function Fe() {
          return null != fn.workerClass ? new fn.workerClass() : new e.window.Worker(fn.workerUrl);
        }
        const Ue = "mapboxgl_preloaded_worker_pool";
        class Ne {
          constructor() {
            this.active = {};
          }
          acquire(e2) {
            if (!this.workers) for (this.workers = []; this.workers.length < Ne.workerCount; ) this.workers.push(new Fe());
            return this.active[e2] = true, this.workers.slice();
          }
          release(e2) {
            delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
              e3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Ue];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let Ge;
        function je() {
          return Ge || (Ge = new Ne()), Ge;
        }
        function Ze(t2, i2) {
          const o2 = {};
          for (const e2 in t2) "ref" !== e2 && (o2[e2] = t2[e2]);
          return e.refProperties.forEach((e2) => {
            e2 in i2 && (o2[e2] = i2[e2]);
          }), o2;
        }
        function Ve(e2) {
          e2 = e2.slice();
          const t2 = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < e2.length; i2++) t2[e2[i2].id] = e2[i2];
          for (let i2 = 0; i2 < e2.length; i2++) "ref" in e2[i2] && (e2[i2] = Ze(e2[i2], t2[e2[i2].ref]));
          return e2;
        }
        Ne.workerCount = 2;
        const We = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
        function Xe(e2, t2, i2) {
          i2.push({ command: We.addSource, args: [e2, t2[e2]] });
        }
        function qe(e2, t2, i2) {
          t2.push({ command: We.removeSource, args: [e2] }), i2[e2] = true;
        }
        function $e(e2, t2, i2, o2) {
          qe(e2, i2, o2), Xe(e2, t2, i2);
        }
        function He(e2, i2, o2) {
          let r3;
          for (r3 in e2[o2]) if (e2[o2].hasOwnProperty(r3) && "data" !== r3 && !t(e2[o2][r3], i2[o2][r3])) return false;
          for (r3 in i2[o2]) if (i2[o2].hasOwnProperty(r3) && "data" !== r3 && !t(e2[o2][r3], i2[o2][r3])) return false;
          return true;
        }
        function Ye(e2, i2, o2, r3, n2, s2) {
          let a2;
          for (a2 in i2 = i2 || {}, e2 = e2 || {}) e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r3, a2, i2[a2], n2] }));
          for (a2 in i2) i2.hasOwnProperty(a2) && !e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r3, a2, i2[a2], n2] }));
        }
        function Ke(e2) {
          return e2.id;
        }
        function Je(e2, t2) {
          return e2[t2.id] = t2, e2;
        }
        class Qe {
          constructor(e2, t2) {
            this.reset(e2, t2);
          }
          reset(e2, t2) {
            this.points = e2 || [], this._distances = [0];
            for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t2) {
            if (1 === this.points.length) return this.points[0];
            t2 = e.clamp(t2, 0, 1);
            let i2 = 1, o2 = this._distances[i2];
            const r3 = t2 * this.paddedLength + this.padding;
            for (; o2 < r3 && i2 < this._distances.length; ) o2 = this._distances[++i2];
            const n2 = i2 - 1, s2 = this._distances[n2], a2 = o2 - s2, l2 = a2 > 0 ? (r3 - s2) / a2 : 0;
            return this.points[n2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        class et {
          constructor(e2, t2, i2) {
            const o2 = this.boxCells = [], r3 = this.circleCells = [];
            this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
            for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) o2.push([]), r3.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e2, t2, i2, o2, r3) {
            this._forEachCell(t2, i2, o2, r3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r3);
          }
          insertCircle(e2, t2, i2, o2) {
            this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
          }
          _insertBoxCell(e2, t2, i2, o2, r3, n2) {
            this.boxCells[r3].push(n2);
          }
          _insertCircleCell(e2, t2, i2, o2, r3, n2) {
            this.circleCells[r3].push(n2);
          }
          _query(e2, t2, i2, o2, r3, n2) {
            if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height) return !r3 && [];
            const s2 = [];
            if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
              if (r3) return true;
              for (let e3 = 0; e3 < this.boxKeys.length; e3++) s2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
              for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                s2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
              }
              return n2 ? s2.filter(n2) : s2;
            }
            return this._forEachCell(e2, t2, i2, o2, this._queryCell, s2, { hitTest: r3, seenUids: { box: {}, circle: {} } }, n2), r3 ? s2.length > 0 : s2;
          }
          _queryCircle(e2, t2, i2, o2, r3) {
            const n2 = e2 - i2, s2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
            if (s2 < 0 || n2 > this.width || l2 < 0 || a2 > this.height) return !o2 && [];
            const c2 = [];
            return this._forEachCell(n2, a2, s2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r3), o2 ? c2.length > 0 : c2;
          }
          query(e2, t2, i2, o2, r3) {
            return this._query(e2, t2, i2, o2, false, r3);
          }
          hitTest(e2, t2, i2, o2, r3) {
            return this._query(e2, t2, i2, o2, true, r3);
          }
          hitTestCircle(e2, t2, i2, o2) {
            return this._queryCircle(e2, t2, i2, true, o2);
          }
          _queryCell(e2, t2, i2, o2, r3, n2, s2, a2) {
            const l2 = s2.seenUids, c2 = this.boxCells[r3];
            if (null !== c2) {
              const r4 = this.bboxes;
              for (const h3 of c2) if (!l2.box[h3]) {
                l2.box[h3] = true;
                const c3 = 4 * h3;
                if (e2 <= r4[c3 + 2] && t2 <= r4[c3 + 3] && i2 >= r4[c3 + 0] && o2 >= r4[c3 + 1] && (!a2 || a2(this.boxKeys[h3]))) {
                  if (s2.hitTest) return n2.push(true), true;
                  n2.push({ key: this.boxKeys[h3], x1: r4[c3], y1: r4[c3 + 1], x2: r4[c3 + 2], y2: r4[c3 + 3] });
                }
              }
            }
            const h2 = this.circleCells[r3];
            if (null !== h2) {
              const r4 = this.circles;
              for (const c3 of h2) if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const h3 = 3 * c3;
                if (this._circleAndRectCollide(r4[h3], r4[h3 + 1], r4[h3 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                  if (s2.hitTest) return n2.push(true), true;
                  {
                    const e3 = r4[h3], t3 = r4[h3 + 1], i3 = r4[h3 + 2];
                    n2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
            }
          }
          _queryCellCircle(e2, t2, i2, o2, r3, n2, s2, a2) {
            const l2 = s2.circle, c2 = s2.seenUids, h2 = this.boxCells[r3];
            if (null !== h2) {
              const e3 = this.bboxes;
              for (const t3 of h2) if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3]))) return n2.push(true), true;
              }
            }
            const u2 = this.circleCells[r3];
            if (null !== u2) {
              const e3 = this.circles;
              for (const t3 of u2) if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3]))) return n2.push(true), true;
              }
            }
          }
          _forEachCell(e2, t2, i2, o2, r3, n2, s2, a2) {
            const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
            for (let _2 = l2; _2 <= h2; _2++) for (let l3 = c2; l3 <= u2; l3++) if (r3.call(this, e2, t2, i2, o2, this.xCellCount * l3 + _2, n2, s2, a2)) return;
          }
          _convertToXCellCoord(e2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
          }
          _convertToYCellCoord(e2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
          }
          _circlesCollide(e2, t2, i2, o2, r3, n2) {
            const s2 = o2 - e2, a2 = r3 - t2, l2 = i2 + n2;
            return l2 * l2 > s2 * s2 + a2 * a2;
          }
          _circleAndRectCollide(e2, t2, i2, o2, r3, n2, s2) {
            const a2 = (n2 - o2) / 2, l2 = Math.abs(e2 - (o2 + a2));
            if (l2 > a2 + i2) return false;
            const c2 = (s2 - r3) / 2, h2 = Math.abs(t2 - (r3 + c2));
            if (h2 > c2 + i2) return false;
            if (l2 <= a2 || h2 <= c2) return true;
            const u2 = l2 - a2, _2 = h2 - c2;
            return u2 * u2 + _2 * _2 <= i2 * i2;
          }
        }
        const tt = Math.tan(85 * Math.PI / 180);
        function it(t2, i2, o2, r3, n2, s2, a2) {
          const l2 = e.create();
          if (o2) if ("globe" === s2.name) {
            const t3 = e.calculateGlobeLabelMatrix(n2, i2);
            e.multiply(l2, l2, t3);
          } else {
            const t3 = v([], a2);
            l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], r3 || e.rotateZ(l2, l2, n2.angle);
          }
          else e.multiply(l2, n2.labelPlaneMatrix, t2);
          return l2;
        }
        function ot(e2, t2, i2, o2, r3, n2, s2) {
          const a2 = it(e2, t2, i2, o2, r3, n2, s2);
          return "globe" === n2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
        }
        function rt(t2, i2, o2, r3, n2, s2, a2) {
          if (o2) {
            if ("globe" === s2.name) {
              const l2 = it(t2, i2, o2, r3, n2, s2, a2);
              return e.invert(l2, l2), e.multiply(l2, t2, l2), l2;
            }
            {
              const i3 = e.clone(t2), o3 = e.identity([]);
              return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.multiply(i3, i3, o3), r3 || e.rotateZ(i3, i3, -n2.angle), i3;
            }
          }
          return n2.glCoordMatrix;
        }
        function nt(t2, i2, o2, r3) {
          const n2 = [t2, i2, o2, 1];
          o2 ? e.transformMat4$1(n2, n2, r3) : ft(n2, n2, r3);
          const s2 = n2[3];
          return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
        }
        function st(e2, t2) {
          return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
        }
        function at(e2, t2) {
          const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
          return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
        }
        function lt(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2) {
          const u2 = o2.transform, _2 = r3 ? t2.textSizeData : t2.iconSizeData, d2 = e.evaluateSizeForZoom(_2, o2.transform.zoom), p2 = "globe" === u2.projection.name, m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r3 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
          f2.clear();
          let g2 = null;
          p2 && (g2 = r3 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
          const v2 = t2.lineVertexArray, x2 = r3 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
          let b2, w2 = false;
          for (let r4 = 0; r4 < x2.length; r4++) {
            const p3 = x2.get(r4), { numGlyphs: T2, writingMode: E2 } = p3;
            if (E2 !== e.WritingMode.vertical || w2 || b2 === e.WritingMode.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.WritingMode.vertical) && !w2) {
              mt(T2, f2);
              continue;
            }
            w2 = false;
            const C2 = new e.pointGeometry(p3.tileAnchorX, p3.tileAnchorY);
            let { x: M2, y: I2, z: S2 } = u2.projection.projectTilePoint(C2.x, C2.y, h2.canonical);
            if (c2) {
              const [e2, t3, i3] = c2(C2);
              M2 += e2, I2 += t3, S2 += i3;
            }
            const D2 = [M2, I2, S2, 1];
            if (e.transformMat4$1(D2, D2, i2), !at(D2, m2)) {
              mt(T2, f2);
              continue;
            }
            const L2 = st(o2.transform.cameraToCenterDistance, D2[3]), A2 = e.evaluateSizeForFeature(_2, d2, p3), z2 = a2 ? A2 / L2 : A2 * L2, P2 = nt(M2, I2, S2, n2);
            if (P2[3] <= 0) {
              mt(T2, f2);
              continue;
            }
            let R2 = {};
            const O2 = a2 ? null : c2, B2 = ut(p3, z2, false, l2, i2, n2, s2, t2.glyphOffsetArray, v2, f2, g2, P2, C2, R2, y2, O2, u2.projection, h2, a2);
            w2 = B2.useVertical, O2 && B2.needsFlipping && (R2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && ut(p3, z2, true, l2, i2, n2, s2, t2.glyphOffsetArray, v2, f2, g2, P2, C2, R2, y2, O2, u2.projection, h2, a2).notEnoughRoom) && mt(T2, f2);
          }
          r3 ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer.updateData(g2));
        }
        function ct(e2, t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2) {
          const { lineStartIndex: f2, glyphStartIndex: g2, segment: v2 } = a2, x2 = g2 + a2.numGlyphs, y2 = f2 + a2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = pt(e2 * b2, i2, o2, r3, n2, s2, v2, f2, y2, l2, c2, h2, u2, _2, true, d2, p2, m2);
          if (!T2) return null;
          const E2 = pt(e2 * w2, i2, o2, r3, n2, s2, v2, f2, y2, l2, c2, h2, u2, _2, true, d2, p2, m2);
          return E2 ? { first: T2, last: E2 } : null;
        }
        function ht(t2, i2, o2, r3) {
          return t2 === e.WritingMode.horizontal && Math.abs(r3) > Math.abs(o2) ? { useVertical: true } : t2 === e.WritingMode.vertical ? r3 > 0 ? { needsFlipping: true } : null : 0 !== i2 && function(e2, t3) {
            return 0 === e2 || Math.abs(t3 / e2) > tt;
          }(o2, r3) ? 1 === i2 ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
        }
        function ut(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2, v2, x2) {
          const y2 = i2 / 24, b2 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: C2, segment: M2, writingMode: I2, flipState: S2 } = t2, D2 = T2 + t2.lineLength, L2 = (t3) => {
            if (u2) {
              const [i4, o4, r5] = t3.up, n3 = h2.length;
              e.updateGlobeVertexNormal(u2, n3 + 0, i4, o4, r5), e.updateGlobeVertexNormal(u2, n3 + 1, i4, o4, r5), e.updateGlobeVertexNormal(u2, n3 + 2, i4, o4, r5), e.updateGlobeVertexNormal(u2, n3 + 3, i4, o4, r5);
            }
            const [i3, o3, r4] = t3.point;
            e.addDynamicAttributes(h2, i3, o3, r4, t3.angle);
          };
          if (C2 > 1) {
            const e2 = ct(y2, l2, b2, w2, o2, _2, d2, t2, c2, s2, p2, f2, false, g2, v2, x2);
            if (!e2) return { notEnoughRoom: true };
            if (r3 && !o2) {
              let [i3, o3, r4] = e2.first.point, [n3, s3, l3] = e2.last.point;
              [i3, o3] = nt(i3, o3, r4, a2), [n3, s3] = nt(n3, s3, l3, a2);
              const c3 = ht(I2, S2, (n3 - i3) * m2, s3 - o3);
              if (t2.flipState = c3 && c3.needsFlipping ? 1 : 2, c3) return c3;
            }
            L2(e2.first);
            for (let e3 = E2 + 1; e3 < E2 + C2 - 1; e3++) {
              const t3 = pt(y2 * l2.getoffsetX(e3), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v2, x2);
              if (!t3) return h2.length -= 4 * (e3 - E2), { notEnoughRoom: true };
              L2(t3);
            }
            L2(e2.last);
          } else {
            if (r3 && !o2) {
              const i4 = nt(d2.x, d2.y, 0, n2), o3 = T2 + M2 + 1, r4 = new e.pointGeometry(c2.getx(o3), c2.gety(o3)), s3 = nt(r4.x, r4.y, 0, n2), a3 = s3[3] > 0 ? s3 : dt(d2, r4, i4, 1, n2, void 0, g2, v2.canonical), l3 = ht(I2, S2, (a3[0] - i4[0]) * m2, a3[1] - i4[1]);
              if (t2.flipState = l3 && l3.needsFlipping ? 1 : 2, l3) return l3;
            }
            const i3 = pt(y2 * l2.getoffsetX(E2), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v2, x2);
            if (!i3) return { notEnoughRoom: true };
            L2(i3);
          }
          return {};
        }
        function _t(e2, t2, i2, o2, r3) {
          const { x: n2, y: s2, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
          if (!r3) return nt(n2, s2, a2, i2);
          const [l2, c2, h2] = r3(e2);
          return nt(n2 + l2, s2 + c2, a2 + h2, i2);
        }
        function dt(t2, i2, o2, r3, n2, s2, a2, l2) {
          const c2 = _t(t2.sub(i2)._unit()._add(t2), l2, n2, a2, s2);
          return e.sub(c2, o2, c2), e.normalize(c2, c2), e.scaleAndAdd(c2, o2, c2, r3);
        }
        function pt(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2, v2) {
          const x2 = r3 ? t2 - i2 : t2 + i2;
          let y2 = x2 > 0 ? 1 : -1, b2 = 0;
          r3 && (y2 *= -1, b2 = Math.PI), y2 < 0 && (b2 += Math.PI);
          let w2 = l2 + a2 + (y2 > 0 ? 0 : 1) | 0, T2 = n2, E2 = n2, C2 = 0, M2 = 0;
          const I2 = Math.abs(x2), S2 = [], D2 = [];
          let L2 = s2, A2 = L2;
          const z2 = () => dt(A2, L2, E2, I2 - C2 + 1, u2, d2, f2, g2.canonical);
          for (; C2 + M2 <= I2; ) {
            if (w2 += y2, w2 < l2 || w2 >= c2) return null;
            if (E2 = T2, A2 = L2, S2.push(E2), p2 && D2.push(A2), L2 = new e.pointGeometry(h2.getx(w2), h2.gety(w2)), T2 = _2[w2], !T2) {
              const e2 = _t(L2, g2.canonical, u2, f2, d2);
              T2 = e2[3] > 0 ? _2[w2] = e2 : z2();
            }
            C2 += M2, M2 = e.distance(E2, T2);
          }
          m2 && d2 && (_2[w2] && (T2 = z2(), M2 = e.distance(E2, T2)), _2[w2] = T2);
          const P2 = (I2 - C2) / M2, R2 = L2.sub(A2)._mult(P2)._add(A2), O2 = e.sub([], T2, E2), B2 = e.scaleAndAdd([], E2, O2, P2);
          let k2 = [0, 0, 1], F2 = O2[0], U2 = O2[1];
          if (v2 && (k2 = f2.upVector(g2.canonical, R2.x, R2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
            const t3 = [k2[2], 0, -k2[0]], i3 = e.cross([], k2, t3);
            e.normalize(t3, t3), e.normalize(i3, i3), F2 = e.dot(O2, t3), U2 = e.dot(O2, i3);
          }
          if (o2) {
            const t3 = e.cross([], k2, O2);
            e.normalize(t3, t3), e.scaleAndAdd(B2, B2, t3, o2 * y2);
          }
          const N2 = b2 + Math.atan2(U2, F2);
          return S2.push(B2), p2 && D2.push(R2), { point: B2, angle: N2, path: S2, tilePath: D2, up: k2 };
        }
        function mt(e2, t2) {
          const i2 = t2.length, o2 = i2 + 4 * e2;
          t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
        }
        function ft(e2, t2, i2) {
          const o2 = t2[0], r3 = t2[1];
          return e2[0] = i2[0] * o2 + i2[4] * r3 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r3 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r3 + i2[15], e2;
        }
        const gt = 100;
        class vt {
          constructor(e2, t2, i2 = new et(e2.width + 200, e2.height + 200, 25), o2 = new et(e2.width + 200, e2.height + 200, 25)) {
            this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + gt, this.screenBottomBoundary = e2.height + gt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
          }
          placeCollisionBox(e2, t2, i2, o2, r3, n2, s2, a2) {
            let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h2 = i2.projectedAnchorZ;
            const u2 = i2.elevation, _2 = i2.tileID, d2 = e2.getProjection();
            if (u2 && _2) {
              const [e3, t3, o3] = d2.upVector(_2.canonical, i2.tileAnchorX, i2.tileAnchorY), r4 = d2.upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              l2 += e3 * u2 * r4, c2 += t3 * u2 * r4, h2 += o3 * u2 * r4;
            }
            const p2 = this.projectAndGetPerspectiveRatio(s2, l2, c2, h2, i2.tileID, "globe" === d2.name || !!u2 || this.transform.pitch > 0, d2), m2 = n2 * p2.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m2 + p2.point.y, v2 = (i2.x2 * t2 + o2.x + i2.padding) * m2 + p2.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m2 + p2.point.y, y2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
            return !this.isInsideGrid(f2, g2, v2, x2) || !r3 && this.grid.hitTest(f2, g2, v2, x2, a2) || y2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [f2, g2, v2, x2], offscreen: this.isOffscreen(f2, g2, v2, x2), occluded: false };
          }
          placeCollisionCircles(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2) {
            const f2 = [], g2 = this.transform.elevation, v2 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, v2) : null, y2 = new e.pointGeometry(o2.tileAnchorX, o2.tileAnchorY);
            let { x: b2, y: w2, z: T2 } = v2.projectTilePoint(y2.x, y2.y, m2.canonical);
            if (x2) {
              const [e2, t3, i3] = x2(y2);
              b2 += e2, w2 += t3, T2 += i3;
            }
            const E2 = "globe" === v2.name, C2 = this.projectAndGetPerspectiveRatio(a2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, v2), { perspectiveRatio: M2 } = C2, I2 = (u2 ? s2 / M2 : s2 * M2) / e.ONE_EM, S2 = nt(b2, w2, T2, l2), D2 = C2.signedDistanceFromCamera > 0 ? ct(I2, n2, o2.lineOffsetX * I2, o2.lineOffsetY * I2, false, S2, y2, o2, r3, l2, {}, g2 && !u2 ? x2 : null, u2 && !!g2, v2, m2, u2) : null;
            let L2 = false, A2 = false, z2 = true;
            if (D2 && !C2.occluded) {
              const t3 = 0.5 * d2 * M2 + p2, o3 = new e.pointGeometry(-100, -100), r4 = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new Qe(), { first: s3, last: a3 } = D2, l3 = s3.path.length;
              let u3 = [];
              for (let e2 = l3 - 1; e2 >= 1; e2--) u3.push(s3.path[e2]);
              for (let e2 = 1; e2 < a3.path.length; e2++) u3.push(a3.path[e2]);
              const m3 = 2.5 * t3;
              c2 && (u3 = u3.map(([e2, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l3 - 1 ? s3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), nt(e2, t4, i3, c2))), u3.some((e2) => e2[3] <= 0) && (u3 = []));
              let g3 = [];
              if (u3.length > 0) {
                let t4 = 1 / 0, i3 = -1 / 0, n4 = 1 / 0, s4 = -1 / 0;
                for (const e2 of u3) t4 = Math.min(t4, e2[0]), n4 = Math.min(n4, e2[1]), i3 = Math.max(i3, e2[0]), s4 = Math.max(s4, e2[1]);
                i3 >= o3.x && t4 <= r4.x && s4 >= o3.y && n4 <= r4.y && (g3 = [u3.map((t5) => new e.pointGeometry(t5[0], t5[1]))], (t4 < o3.x || i3 > r4.x || n4 < o3.y || s4 > r4.y) && (g3 = e.clipLine(g3, o3.x, o3.y, r4.x, r4.y)));
              }
              for (const e2 of g3) {
                n3.reset(e2, 0.25 * t3);
                let o4 = 0;
                o4 = n3.length <= 0.5 * t3 ? 1 : Math.ceil(n3.paddedLength / m3) + 1;
                for (let e3 = 0; e3 < o4; e3++) {
                  const r5 = e3 / Math.max(o4 - 1, 1), s4 = n3.lerp(r5), a4 = s4.x + gt, l4 = s4.y + gt;
                  f2.push(a4, l4, t3, 0);
                  const c3 = a4 - t3, u4 = l4 - t3, d3 = a4 + t3, p3 = l4 + t3;
                  if (z2 = z2 && this.isOffscreen(c3, u4, d3, p3), A2 = A2 || this.isInsideGrid(c3, u4, d3, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, _2) && (L2 = true, !h2)) return { circles: [], offscreen: false, collisionDetected: L2, occluded: false };
                }
              }
            }
            return { circles: !h2 && L2 || !A2 ? [] : f2, offscreen: z2, collisionDetected: L2, occluded: C2.occluded };
          }
          queryRenderedSymbols(t2) {
            if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i2 = [];
            let o2 = 1 / 0, r3 = 1 / 0, n2 = -1 / 0, s2 = -1 / 0;
            for (const a3 of t2) {
              const t3 = new e.pointGeometry(a3.x + gt, a3.y + gt);
              o2 = Math.min(o2, t3.x), r3 = Math.min(r3, t3.y), n2 = Math.max(n2, t3.x), s2 = Math.max(s2, t3.y), i2.push(t3);
            }
            const a2 = this.grid.query(o2, r3, n2, s2).concat(this.ignoredGrid.query(o2, r3, n2, s2)), l2 = {}, c2 = {};
            for (const t3 of a2) {
              const o3 = t3.key;
              if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex]) continue;
              const r4 = [new e.pointGeometry(t3.x1, t3.y1), new e.pointGeometry(t3.x2, t3.y1), new e.pointGeometry(t3.x2, t3.y2), new e.pointGeometry(t3.x1, t3.y2)];
              e.polygonIntersectsPolygon(i2, r4) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c2;
          }
          insertCollisionBox(e2, t2, i2, o2, r3) {
            (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 }, e2[0], e2[1], e2[2], e2[3]);
          }
          insertCollisionCircles(e2, t2, i2, o2, r3) {
            const n2 = t2 ? this.ignoredGrid : this.grid, s2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r3 };
            for (let t3 = 0; t3 < e2.length; t3 += 4) n2.insertCircle(s2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
          }
          projectAndGetPerspectiveRatio(t2, i2, o2, r3, n2, s2, a2) {
            const l2 = [i2, o2, r3, 1];
            let c2 = false;
            if (r3 || this.transform.pitch > 0) {
              e.transformMat4$1(l2, l2, t2);
              const s3 = "globe" === a2.name;
              if (this.fogState && n2 && !s3) {
                const t3 = function(t4, i3, o3, r4, n3, s4) {
                  const a3 = s4.calculateFogTileMatrix(n3), l3 = [i3, o3, r4];
                  return e.transformMat4(l3, l3, a3), I(t4, l3, s4.pitch, s4._fov);
                }(this.fogState, i2, o2, r3, n2.toUnwrapped(), this.transform);
                c2 = t3 > 0.9;
              }
            } else ft(l2, l2, t2);
            const h2 = l2[3];
            return { point: new e.pointGeometry((l2[0] / h2 + 1) / 2 * this.transform.width + gt, (-l2[1] / h2 + 1) / 2 * this.transform.height + gt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: s2 && l2[2] > h2 || c2 };
          }
          isOffscreen(e2, t2, i2, o2) {
            return i2 < gt || e2 >= this.screenRightBoundary || o2 < gt || t2 > this.screenBottomBoundary;
          }
          isInsideGrid(e2, t2, i2, o2) {
            return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t2 = e.identity([]);
            return e.translate(t2, t2, [-100, -100, 0]), t2;
          }
        }
        function xt(t2, i2, o2) {
          const r3 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
          return e.multiply(new Float32Array(16), t2.projMatrix, r3);
        }
        function yt(e2, t2, i2) {
          if (t2.projection.name === i2.projection.name) return e2.projMatrix;
          const o2 = i2.clone();
          return o2.setProjection(t2.projection), xt(o2, t2.getProjection(), e2);
        }
        function bt(e2, t2, i2) {
          return t2.name === i2.projection.name ? e2.projMatrix : xt(i2, t2, e2);
        }
        class wt {
          constructor(e2, t2, i2, o2) {
            this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Tt {
          constructor(e2, t2, i2, o2, r3, n2 = false) {
            this.text = new wt(e2 ? e2.text : null, t2, i2, r3), this.icon = new wt(e2 ? e2.icon : null, t2, o2, r3), this.clipped = n2;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Et {
          constructor(e2, t2, i2, o2 = false) {
            this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
          }
        }
        class Ct {
          constructor() {
            this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
          }
        }
        class Mt {
          constructor(e2, t2, i2, o2, r3) {
            this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r3;
          }
        }
        class It {
          constructor(e2) {
            this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e2) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e2]) {
              const t2 = ++this.maxGroupID;
              this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
            }
            return this.collisionGroups[e2];
          }
        }
        function St(t2, i2, o2, r3, n2) {
          const { horizontalAlign: s2, verticalAlign: a2 } = e.getAnchorAlignment(t2), l2 = -(s2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h2 = e.evaluateVariableOffset(t2, r3);
          return new e.pointGeometry(l2 + h2[0] * n2, c2 + h2[1] * n2);
        }
        function Dt(t2, i2, o2, r3, n2) {
          const s2 = new e.pointGeometry(t2, i2);
          return o2 && s2._rotate(r3 ? n2 : -n2), s2;
        }
        class Lt {
          constructor(e2, t2, i2, o2, r3) {
            this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new vt(this.transform, r3), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new It(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t2, i2, o2, r3) {
            const n2 = o2.getBucket(i2), s2 = o2.latestFeatureIndex;
            if (!n2 || !s2 || i2.id !== n2.layerIds[0]) return;
            const a2 = n2.layers[0].layout, l2 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / e.EXTENT, u2 = o2.tileID.toUnwrapped();
            this.transform.setProjection(n2.projection);
            const _2 = (d2 = o2.tileID, p2 = n2.getProjection(), m2 = this.transform, p2.name === this.projection ? m2.calculateProjMatrix(d2.toUnwrapped()) : xt(m2, p2, d2));
            var d2, p2, m2;
            const f2 = "map" === a2.get("text-pitch-alignment"), g2 = "map" === a2.get("text-rotation-alignment");
            i2.compileFilter();
            const v2 = i2.dynamicFilter(), x2 = i2.dynamicFilterNeedsFeature(), y2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b2 = ot(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
            let w2 = null;
            if (f2) {
              const t3 = rt(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
              w2 = e.multiply([], this.transform.labelPlaneMatrix, t3);
            }
            let T2 = null;
            v2 && o2.latestFeatureIndex && (T2 = { unwrappedTileID: u2, dynamicFilter: v2, dynamicFilterNeedsFeature: x2, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n2.bucketInstanceId] = new Mt(n2.bucketInstanceId, s2, n2.sourceLayerIndex, n2.index, o2.tileID);
            const E2 = { bucket: n2, layout: a2, posMatrix: _2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
            if (r3) for (const e2 of n2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r4, parameters: E2 });
            }
            else t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: E2 });
          }
          attemptAnchorPlacement(e2, t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2) {
            const { textOffset0: v2, textOffset1: x2, crossTileID: y2 } = u2, b2 = [v2, x2], w2 = St(e2, i2, o2, b2, r3), T2 = this.collisionIndex.placeCollisionBox(d2, r3, t2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h2, a2, l2, c2.predicate);
            if (m2) {
              const e3 = d2.getSymbolInstanceIconSize(g2, this.transform.zoom, u2.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(d2, e3, m2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h2, a2, l2, c2.predicate).box.length) return;
            }
            if (T2.box.length > 0) {
              let t3;
              return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b2, width: i2, height: o2, anchor: e2, textScale: r3, prevAnchor: t3 }, this.markUsedJustification(d2, e2, u2, p2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, p2, u2), this.placedOrientations[y2] = p2), { shift: w2, placedGlyphBoxes: T2 };
            }
          }
          placeLayerBucketPart(t2, i2, o2, r3) {
            const { bucket: n2, layout: s2, posMatrix: a2, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, clippingData: h2, textPixelRatio: u2, holdingForFade: _2, collisionBoxArray: d2, partiallyEvaluatedTextSize: p2, partiallyEvaluatedIconSize: m2, collisionGroup: f2 } = t2.parameters, g2 = s2.get("text-optional"), v2 = s2.get("icon-optional"), x2 = s2.get("text-allow-overlap"), y2 = s2.get("icon-allow-overlap"), b2 = "map" === s2.get("text-rotation-alignment"), w2 = "map" === s2.get("text-pitch-alignment"), T2 = "none" !== s2.get("icon-text-fit"), E2 = "viewport-y" === s2.get("symbol-z-order");
            this.transform.setProjection(n2.projection);
            let C2 = x2 && (y2 || !n2.hasIconData() || v2), M2 = y2 && (x2 || !n2.hasTextData() || g2);
            !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2), o2 && r3 && n2.updateCollisionDebugBuffers(this.transform.zoom, d2);
            const I2 = (t3, r4, d3) => {
              const { crossTileID: E3, numVerticalGlyphVertices: I3 } = t3;
              if (h2) {
                const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r5 = null;
                if (h2.dynamicFilterNeedsFeature) {
                  const e2 = this.retainedQueryData[n2.bucketInstanceId];
                  r5 = h2.featureIndex.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h2.dynamicFilter)(o3, r5, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e.pointGeometry(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(h2.unwrappedTileID))) return this.placements[E3] = new Et(false, false, false, true), void (i2[E3] = true);
              }
              if (i2[E3]) return;
              if (_2) return void (this.placements[E3] = new Et(false, false, false));
              let S2 = false, D2 = false, L2 = true, A2 = false, z2 = false, P2 = null, R2 = { box: null, offscreen: null, occluded: null }, O2 = { box: null, offscreen: null, occluded: null }, B2 = null, k2 = null, F2 = null, U2 = 0, N2 = 0, G2 = 0;
              d3.textFeatureIndex ? U2 = d3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), d3.verticalTextFeatureIndex && (N2 = d3.verticalTextFeatureIndex);
              const j2 = (e2) => {
                e2.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
                const t4 = this.transform.elevation;
                (t4 || e2.elevation) && (e2.elevation = t4 ? t4.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
              }, Z2 = d3.textBox;
              if (Z2) {
                j2(Z2);
                const i3 = (i4) => {
                  let o4 = e.WritingMode.horizontal;
                  if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const e2 = this.prevPlacement.placedOrientations[E3];
                    e2 && (this.placedOrientations[E3] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                  }
                  return o4;
                }, o3 = (t4, i4) => {
                  if (n2.allowVerticalPlacement && I3 > 0 && d3.verticalTextBox) {
                    for (const o4 of n2.writingModes) if (o4 === e.WritingMode.vertical ? (R2 = i4(), O2 = R2) : R2 = t4(), R2 && R2.box && R2.box.length) break;
                  } else R2 = t4();
                };
                if (s2.get("text-variable-anchor")) {
                  let l3 = s2.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[E3]) {
                    const e2 = this.prevPlacement.variableOffsets[E3];
                    l3.indexOf(e2.anchor) > 0 && (l3 = l3.filter((t4) => t4 !== e2.anchor), l3.unshift(e2.anchor));
                  }
                  const c3 = (e2, i4, o4) => {
                    const s3 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r4), c4 = (e2.x2 - e2.x1) * s3 + 2 * e2.padding, h4 = (e2.y2 - e2.y1) * s3 + 2 * e2.padding, _3 = T2 && !y2 ? i4 : null;
                    _3 && j2(_3);
                    let d4 = { box: [], offscreen: false, occluded: false };
                    const g3 = x2 ? 2 * l3.length : l3.length;
                    for (let i5 = 0; i5 < g3; ++i5) {
                      const g4 = this.attemptAnchorPlacement(l3[i5 % l3.length], e2, c4, h4, s3, b2, w2, u2, a2, f2, i5 >= l3.length, t3, r4, n2, o4, _3, p2, m2);
                      if (g4 && (d4 = g4.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                        S2 = true, P2 = g4.shift;
                        break;
                      }
                    }
                    return d4;
                  };
                  o3(() => c3(Z2, d3.iconBox, e.WritingMode.horizontal), () => {
                    const t4 = d3.verticalTextBox;
                    return t4 && j2(t4), n2.allowVerticalPlacement && !(R2 && R2.box && R2.box.length) && I3 > 0 && t4 ? c3(t4, d3.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                  }), R2 && (S2 = R2.box, L2 = R2.offscreen, A2 = R2.occluded);
                  const h3 = i3(R2 && R2.box);
                  if (!S2 && this.prevPlacement) {
                    const e2 = this.prevPlacement.variableOffsets[E3];
                    e2 && (this.variableOffsets[E3] = e2, this.markUsedJustification(n2, e2.anchor, t3, h3));
                  }
                } else {
                  const s3 = (i4, o4) => {
                    const s4 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r4), l3 = this.collisionIndex.placeCollisionBox(n2, s4, i4, new e.pointGeometry(0, 0), x2, u2, a2, f2.predicate);
                    return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[E3] = o4), l3;
                  };
                  o3(() => s3(Z2, e.WritingMode.horizontal), () => {
                    const t4 = d3.verticalTextBox;
                    return n2.allowVerticalPlacement && I3 > 0 && t4 ? (j2(t4), s3(t4, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i3(R2 && R2.box && R2.box.length);
                }
              }
              if (B2 = R2, S2 = B2 && B2.box && B2.box.length > 0, L2 = B2 && B2.offscreen, A2 = B2 && B2.occluded, t3.useRuntimeCollisionCircles) {
                const i3 = n2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r5 = e.evaluateSizeForFeature(n2.textSizeData, p2, i3), h3 = s2.get("text-padding");
                k2 = this.collisionIndex.placeCollisionCircles(n2, x2, i3, n2.lineVertexArray, n2.glyphOffsetArray, r5, a2, l2, c2, o2, w2, f2.predicate, t3.collisionCircleDiameter * r5 / e.ONE_EM, h3, this.retainedQueryData[n2.bucketInstanceId].tileID), S2 = x2 || k2.circles.length > 0 && !k2.collisionDetected, L2 = L2 && k2.offscreen, A2 = k2.occluded;
              }
              if (d3.iconFeatureIndex && (G2 = d3.iconFeatureIndex), d3.iconBox) {
                const i3 = (i4) => {
                  j2(i4);
                  const o3 = T2 && P2 ? Dt(P2.x, P2.y, b2, w2, this.transform.angle) : new e.pointGeometry(0, 0), r5 = n2.getSymbolInstanceIconSize(m2, this.transform.zoom, t3.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(n2, r5, i4, o3, y2, u2, a2, f2.predicate);
                };
                O2 && O2.box && O2.box.length && d3.verticalIconBox ? (F2 = i3(d3.verticalIconBox), D2 = F2.box.length > 0) : (F2 = i3(d3.iconBox), D2 = F2.box.length > 0), L2 = L2 && F2.offscreen, z2 = F2.occluded;
              }
              const V2 = g2 || 0 === t3.numHorizontalGlyphVertices && 0 === I3, W2 = v2 || 0 === t3.numIconVertices;
              if (V2 || W2 ? W2 ? V2 || (D2 = D2 && S2) : S2 = D2 && S2 : D2 = S2 = D2 && S2, S2 && B2 && B2.box && this.collisionIndex.insertCollisionBox(B2.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, O2 && O2.box && N2 ? N2 : U2, f2.ID), D2 && F2 && this.collisionIndex.insertCollisionBox(F2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, G2, f2.ID), k2 && (S2 && this.collisionIndex.insertCollisionCircles(k2.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, U2, f2.ID), o2)) {
                const e2 = n2.bucketInstanceId;
                let t4 = this.collisionCircleArrays[e2];
                void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new Ct());
                for (let e3 = 0; e3 < k2.circles.length; e3 += 4) t4.circles.push(k2.circles[e3 + 0]), t4.circles.push(k2.circles[e3 + 1]), t4.circles.push(k2.circles[e3 + 2]), t4.circles.push(k2.collisionDetected ? 1 : 0);
              }
              const X2 = "globe" !== n2.projection.name;
              C2 = C2 && (X2 || !A2), M2 = M2 && (X2 || !z2), this.placements[E3] = new Et(S2 || C2, D2 || M2, L2 || n2.justReloaded), i2[E3] = true;
            };
            if (E2) {
              const e2 = n2.getSortedSymbolIndexes(this.transform.angle);
              for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                const i3 = e2[t3];
                I2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
              }
            } else for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++) I2(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
            if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
              e.invert(t3.invProjMatrix, a2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n2.justReloaded = false;
          }
          markUsedJustification(t2, i2, o2, r3) {
            const { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: s2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h2 = e.getAnchorJustification(i2), u2 = r3 === e.WritingMode.vertical ? l2 : "left" === h2 ? n2 : "center" === h2 ? s2 : "right" === h2 ? a2 : -1;
            n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = u2 >= 0 && n2 !== u2 ? 0 : c2), s2 >= 0 && (t2.text.placedSymbolArray.get(s2).crossTileID = u2 >= 0 && s2 !== u2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = u2 >= 0 && a2 !== u2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = u2 >= 0 && l2 !== u2 ? 0 : c2);
          }
          markUsedOrientation(t2, i2, o2) {
            const r3 = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n2 = i2 === e.WritingMode.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h2 = t2.text.placedSymbolArray;
            s2 >= 0 && (h2.get(s2).placedOrientation = r3), a2 >= 0 && (h2.get(a2).placedOrientation = r3), l2 >= 0 && (h2.get(l2).placedOrientation = r3), c2 >= 0 && (h2.get(c2).placedOrientation = n2);
          }
          commit(e2) {
            this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
            const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r3 = t2 ? t2.opacities : {}, n2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
            for (const e3 in this.placements) {
              const t3 = this.placements[e3], n3 = r3[e3];
              n3 ? (this.opacities[e3] = new Tt(n3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== n3.text.placed || t3.icon !== n3.icon.placed) : (this.opacities[e3] = new Tt(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
            }
            for (const e3 in r3) {
              const t3 = r3[e3];
              if (!this.opacities[e3]) {
                const r4 = new Tt(t3, o2, false, false);
                r4.isHidden() || (this.opacities[e3] = r4, i2 = i2 || t3.text.placed || t3.icon.placed);
              }
            }
            for (const e3 in n2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n2[e3]);
            for (const e3 in s2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
            i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
          }
          updateLayerOpacities(e2, t2) {
            const i2 = {};
            for (const o2 of t2) {
              const t3 = o2.getBucket(e2);
              t3 && o2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, o2.collisionBoxArray);
            }
          }
          updateBucketOpacities(t2, i2, o2) {
            t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
            const r3 = t2.layers[0].layout, n2 = !!t2.layers[0].dynamicFilter(), s2 = new Tt(null, 0, false, false, true), a2 = r3.get("text-allow-overlap"), l2 = r3.get("icon-allow-overlap"), c2 = r3.get("text-variable-anchor"), h2 = "map" === r3.get("text-rotation-alignment"), u2 = "map" === r3.get("text-pitch-alignment"), _2 = "none" !== r3.get("icon-text-fit"), d2 = new Tt(null, 0, a2 && (l2 || !t2.hasIconData() || r3.get("icon-optional")), l2 && (a2 || !t2.hasTextData() || r3.get("text-optional")), true);
            !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
            const p2 = (e2, t3, i3) => {
              for (let o3 = 0; o3 < t3 / 4; o3++) e2.opacityVertexArray.emplaceBack(i3);
            };
            let m2 = 0;
            for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
              const r4 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: l3, crossTileID: f2, numIconVertices: g2 } = r4;
              let v2 = this.opacities[f2];
              i2[f2] ? v2 = s2 : v2 || (v2 = d2, this.opacities[f2] = v2), i2[f2] = true;
              const x2 = a3 > 0 || l3 > 0, y2 = g2 > 0, b2 = this.placedOrientations[f2], w2 = b2 === e.WritingMode.vertical, T2 = b2 === e.WritingMode.horizontal || b2 === e.WritingMode.horizontalOnly;
              if (!x2 && !y2 || v2.isHidden() || m2++, x2) {
                const e2 = Ut(v2.text);
                p2(t2.text, a3, w2 ? Nt : e2), p2(t2.text, l3, T2 ? Nt : e2);
                const i3 = v2.text.isHidden(), { leftJustifiedTextSymbolIndex: o4, centerJustifiedTextSymbolIndex: n3, rightJustifiedTextSymbolIndex: s3, verticalPlacedTextSymbolIndex: c3 } = r4, h3 = t2.text.placedSymbolArray, u3 = i3 || w2 ? 1 : 0;
                o4 >= 0 && (h3.get(o4).hidden = u3), n3 >= 0 && (h3.get(n3).hidden = u3), s3 >= 0 && (h3.get(s3).hidden = u3), c3 >= 0 && (h3.get(c3).hidden = i3 || T2 ? 1 : 0);
                const _3 = this.variableOffsets[f2];
                _3 && this.markUsedJustification(t2, _3.anchor, r4, b2);
                const d3 = this.placedOrientations[f2];
                d3 && (this.markUsedJustification(t2, "left", r4, d3), this.markUsedOrientation(t2, d3, r4));
              }
              if (y2) {
                const e2 = Ut(v2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o4 } = r4, n3 = t2.icon.placedSymbolArray, s3 = v2.icon.isHidden() ? 1 : 0;
                i3 >= 0 && (p2(t2.icon, g2, w2 ? Nt : e2), n3.get(i3).hidden = s3), o4 >= 0 && (p2(t2.icon, r4.numVerticalIconVertices, T2 ? Nt : e2), n3.get(o4).hidden = s3);
              }
              if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                const i3 = t2.collisionArrays[o3];
                if (i3) {
                  let o4 = new e.pointGeometry(0, 0), r5 = true;
                  if (i3.textBox || i3.verticalTextBox) {
                    if (c2) {
                      const e2 = this.variableOffsets[f2];
                      e2 ? (o4 = St(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), h2 && o4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : r5 = false;
                    }
                    n2 && (r5 = !v2.clipped), i3.textBox && At(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !r5 || w2, o4.x, o4.y), i3.verticalTextBox && At(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !r5 || T2, o4.x, o4.y);
                  }
                  const s3 = r5 && Boolean(!T2 && i3.verticalIconBox);
                  i3.iconBox && At(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, s3, _2 ? o4.x : 0, _2 ? o4.y : 0), i3.verticalIconBox && At(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, !s3, _2 ? o4.x : 0, _2 ? o4.y : 0);
                }
              }
            }
            if (t2.fullyClipped = 0 === m2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
              const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
              t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
            }
          }
          symbolFadeChange(e2) {
            return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e2) {
            return Math.max(0, (this.transform.zoom - e2) / 1.5);
          }
          hasTransitions(e2) {
            return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e2, t2) {
            const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
            return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function At(e2, t2, i2, o2, r3) {
          e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r3 || 0);
        }
        const zt = Math.pow(2, 25), Pt = Math.pow(2, 24), Rt = Math.pow(2, 17), Ot = Math.pow(2, 16), Bt = Math.pow(2, 9), kt = Math.pow(2, 8), Ft = Math.pow(2, 1);
        function Ut(e2) {
          if (0 === e2.opacity && !e2.placed) return 0;
          if (1 === e2.opacity && e2.placed) return 4294967295;
          const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
          return i2 * zt + t2 * Pt + i2 * Rt + t2 * Ot + i2 * Bt + t2 * kt + i2 * Ft + t2;
        }
        const Nt = 0;
        class Gt {
          constructor(e2) {
            this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e2, t2, i2, o2, r3) {
            const n2 = this._bucketParts;
            for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r3()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
              const e3 = n2[this._currentPartIndex];
              if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r3()) return true;
            }
            return false;
          }
        }
        class jt {
          constructor(e2, t2, i2, o2, r3, n2, s2, a2) {
            this.placement = new Lt(e2, r3, n2, s2, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t2, i2, o2) {
            const r3 = e.exported.now(), n2 = () => {
              const t3 = e.exported.now() - r3;
              return !this._forceFullPlacement && t3 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const e2 = i2[t2[this._currentPlacementIndex]], r4 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === e2.type && (!e2.minzoom || e2.minzoom <= r4) && (!e2.maxzoom || e2.maxzoom > r4)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Gt(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n2)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e2) {
            return this.placement.commit(e2), this.placement;
          }
        }
        const Zt = 512 / e.EXTENT / 2;
        class Vt {
          constructor(e2, t2, i2) {
            this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
            for (let i3 = 0; i3 < t2.length; i3++) {
              const o2 = t2.get(i3), r3 = o2.key;
              this.indexedSymbolInstances[r3] || (this.indexedSymbolInstances[r3] = []), this.indexedSymbolInstances[r3].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e2) });
            }
          }
          getScaledCoordinates(t2, i2) {
            const o2 = Zt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
            return { x: Math.floor((i2.canonical.x * e.EXTENT + t2.tileAnchorX) * o2), y: Math.floor((i2.canonical.y * e.EXTENT + t2.tileAnchorY) * o2) };
          }
          findMatches(e2, t2, i2) {
            const o2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
            for (let r3 = 0; r3 < e2.length; r3++) {
              const n2 = e2.get(r3);
              if (n2.crossTileID) continue;
              const s2 = this.indexedSymbolInstances[n2.key];
              if (!s2) continue;
              const a2 = this.getScaledCoordinates(n2, t2);
              for (const e3 of s2) if (Math.abs(e3.coord.x - a2.x) <= o2 && Math.abs(e3.coord.y - a2.y) <= o2 && !i2[e3.crossTileID]) {
                i2[e3.crossTileID] = true, n2.crossTileID = e3.crossTileID;
                break;
              }
            }
          }
        }
        class Wt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Xt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - this.lng) / 360);
            if (0 !== t2) for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r3 = i2[e4];
                r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t2), o2[r3.tileID.key] = r3;
              }
              this.indexes[e3] = o2;
            }
            this.lng = e2;
          }
          addBucket(e2, t2, i2) {
            if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
              if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
            this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
            const o2 = this.usedCrossTileIDs[e2.overscaledZ];
            for (const i3 in this.indexes) {
              const r3 = this.indexes[i3];
              if (Number(i3) > e2.overscaledZ) for (const i4 in r3) {
                const n2 = r3[i4];
                n2.tileID.isChildOf(e2) && n2.findMatches(t2.symbolInstances, e2, o2);
              }
              else {
                const n2 = r3[e2.scaledTo(Number(i3)).key];
                n2 && n2.findMatches(t2.symbolInstances, e2, o2);
              }
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
              const r3 = t2.symbolInstances.get(e3);
              r3.crossTileID || (r3.crossTileID = i2.generate(), o2[r3.crossTileID] = true);
            }
            return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Vt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e2, t2) {
            for (const i2 in t2.indexedSymbolInstances) for (const o2 of t2.indexedSymbolInstances[i2]) delete this.usedCrossTileIDs[e2][o2.crossTileID];
          }
          removeStaleBuckets(e2) {
            let t2 = false;
            for (const i2 in this.indexes) {
              const o2 = this.indexes[i2];
              for (const r3 in o2) e2[o2[r3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r3]), delete o2[r3], t2 = true);
            }
            return t2;
          }
        }
        class qt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Wt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e2, t2, i2, o2) {
            let r3 = this.layerIndexes[e2.id];
            void 0 === r3 && (r3 = this.layerIndexes[e2.id] = new Xt());
            let n2 = false;
            const s2 = {};
            "globe" !== o2.name && r3.handleWrapJump(i2);
            for (const i3 of t2) {
              const t3 = i3.getBucket(e2);
              t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r3.addBucket(i3.tileID, t3, this.crossTileIDs) && (n2 = true), s2[t3.bucketInstanceId] = true);
            }
            return r3.removeStaleBuckets(s2) && (n2 = true), n2;
          }
          pruneUnusedLayers(e2) {
            const t2 = {};
            e2.forEach((e3) => {
              t2[e3] = true;
            });
            for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
          }
        }
        const $t = (t2, i2) => e.emitValidationErrors(t2, i2 && i2.filter((e2) => "source.canvas" !== e2.identifier)), Ht = e.pick(We, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Yt = e.pick(We, ["setCenter", "setZoom", "setBearing", "setPitch"]), Kt = { version: 8, layers: [], sources: {} }, Jt = { fill: true, line: true, background: true, hillshade: true, raster: true };
        class Qt extends e.Evented {
          constructor(t2, i2 = {}) {
            super(), this.map = t2, this.dispatcher = new z(je(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t2._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.crossTileSymbolIndex = new qt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
            const o2 = this;
            this._rtlTextPluginCallback = Qt.registerForPluginStateChange((t3) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                if (e.triggerPluginCompletionEvent(t4), i3 && i3.every((e2) => e2)) for (const e2 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                  "vector" !== i4 && "geojson" !== i4 || t5.reload();
                }
              });
            }), this.on("data", (e2) => {
              if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType) return;
              const t3 = this.getSource(e2.sourceId);
              if (t3 && t3.vectorLayerIds) for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
            });
          }
          loadURL(t2, i2 = {}) {
            this.fire(new e.Event("dataloading", { dataType: "style" }));
            const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.isMapboxURL(t2);
            t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken);
            const r3 = this.map._requestManager.transformRequest(t2, e.ResourceType.Style);
            this._request = e.getJSON(r3, (t3, i3) => {
              this._request = null, t3 ? this.fire(new e.ErrorEvent(t3)) : i3 && this._load(i3, o2);
            });
          }
          loadJSON(t2, i2 = {}) {
            this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
              this._request = null, this._load(t2, false !== i2.validate);
            });
          }
          loadEmpty() {
            this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Kt, false);
          }
          _updateLayerCount(e2, t2) {
            const i2 = t2 ? 1 : -1;
            e2.is3D() && (this._num3DLayers += i2), "circle" === e2.type && (this._numCircleLayers += i2), "symbol" === e2.type && (this._numSymbolLayers += i2);
          }
          _load(t2, i2) {
            if (i2 && $t(this, e.validateStyle(t2))) return;
            this._loaded = true, this.stylesheet = e.clone$1(t2), this._updateMapProjection();
            for (const e2 in t2.sources) this.addSource(e2, t2.sources[e2], { validate: false });
            this._changed = false, t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t2.glyphs);
            const o2 = Ve(this.stylesheet.layers);
            this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
            for (const t3 of o2) {
              const i3 = e.createStyleLayer(t3);
              i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize(), this._updateLayerCount(i3, true);
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          setProjection(e2) {
            e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
          }
          _updateMapProjection() {
            this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
          }
          _loadSprite(t2) {
            this._spriteRequest = function(t3, i2, o2) {
              let r3, n2, s2;
              const a2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
              let l2 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.ResourceType.SpriteJSON), (e2, t4) => {
                l2 = null, s2 || (s2 = e2, r3 = t4, h2());
              }), c2 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.ResourceType.SpriteImage), (e2, t4) => {
                c2 = null, s2 || (s2 = e2, n2 = t4, h2());
              });
              function h2() {
                if (s2) o2(s2);
                else if (r3 && n2) {
                  const t4 = e.exported.getImageData(n2), i3 = {};
                  for (const o3 in r3) {
                    const { width: n3, height: s3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u2, stretchY: _2, content: d2 } = r3[o3], p2 = new e.RGBAImage({ width: n3, height: s3 });
                    e.RGBAImage.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: n3, height: s3 }), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: u2, stretchY: _2, content: d2 };
                  }
                  o2(null, i3);
                }
              }
              return { cancel() {
                l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
              } };
            }(t2, this.map._requestManager, (t3, i2) => {
              if (this._spriteRequest = null, t3) this.fire(new e.ErrorEvent(t3));
              else if (i2) for (const e2 in i2) this.imageManager.addImage(e2, i2[e2]);
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(t2) {
            const i2 = this.getSource(t2.source);
            if (!i2) return;
            const o2 = t2.sourceLayer;
            o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._updatedSources).length) return false;
            for (const e2 in this._sourceCaches) if (!this._sourceCaches[e2].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(e2) {
            const t2 = [];
            for (const i2 of e2) {
              const e3 = this._layers[i2];
              "custom" !== e3.type && t2.push(e3.serialize());
            }
            return t2;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition()) return true;
            if (this.fog && this.fog.hasTransition()) return true;
            for (const e2 in this._sourceCaches) if (this._sourceCaches[e2].hasTransition()) return true;
            for (const e2 in this._layers) if (this._layers[e2].hasTransition()) return true;
            return false;
          }
          get order() {
            return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
          }
          isLayerDraped(e2) {
            return !!this.terrain && ("function" == typeof e2.isLayerDraped ? e2.isLayerDraped() : Jt[e2.type]);
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }
          update(t2) {
            if (!this._loaded) return;
            const i2 = this._changed;
            if (this._changed) {
              const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
              for (const e3 in this._updatedSources) {
                const t3 = this._updatedSources[e3];
                "reload" === t3 ? this._reloadSource(e3) : "clear" === t3 && this._clearSource(e3);
              }
              this._updateTilesForChangedImages();
              for (const e3 in this._updatedPaintProps) this._layers[e3].updateTransitions(t2);
              this.light.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._resetUpdates();
            }
            const o2 = {};
            for (const e2 in this._sourceCaches) {
              const t3 = this._sourceCaches[e2];
              o2[e2] = t3.used, t3.used = false;
            }
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                const e3 = this._getLayerSourceCache(i3);
                e3 && (e3.used = true);
              }
              const o3 = this.map.painter;
              if (o3) {
                const e3 = i3.getProgramIds();
                if (!e3) continue;
                const r3 = i3.getProgramConfiguration(t2.zoom);
                for (const t3 of e3) o3.useProgram(t3, r3);
              }
            }
            for (const t3 in o2) {
              const i3 = this._sourceCaches[t3];
              o2[t3] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
            }
            this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e2 = Object.keys(this._changedImages);
            if (e2.length) {
              for (const t2 in this._sourceCaches) this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(e2, t2) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setState(i2) {
            if (this._checkLoaded(), $t(this, e.validateStyle(i2))) return false;
            (i2 = e.clone$1(i2)).layers = Ve(i2.layers);
            const o2 = function(e2, i3) {
              if (!e2) return [{ command: We.setStyle, args: [i3] }];
              let o3 = [];
              try {
                if (!t(e2.version, i3.version)) return [{ command: We.setStyle, args: [i3] }];
                t(e2.center, i3.center) || o3.push({ command: We.setCenter, args: [i3.center] }), t(e2.zoom, i3.zoom) || o3.push({ command: We.setZoom, args: [i3.zoom] }), t(e2.bearing, i3.bearing) || o3.push({ command: We.setBearing, args: [i3.bearing] }), t(e2.pitch, i3.pitch) || o3.push({ command: We.setPitch, args: [i3.pitch] }), t(e2.sprite, i3.sprite) || o3.push({ command: We.setSprite, args: [i3.sprite] }), t(e2.glyphs, i3.glyphs) || o3.push({ command: We.setGlyphs, args: [i3.glyphs] }), t(e2.transition, i3.transition) || o3.push({ command: We.setTransition, args: [i3.transition] }), t(e2.light, i3.light) || o3.push({ command: We.setLight, args: [i3.light] }), t(e2.fog, i3.fog) || o3.push({ command: We.setFog, args: [i3.fog] }), t(e2.projection, i3.projection) || o3.push({ command: We.setProjection, args: [i3.projection] });
                const r4 = {}, n2 = [];
                !function(e3, i4, o4, r5) {
                  let n3;
                  for (n3 in i4 = i4 || {}, e3 = e3 || {}) e3.hasOwnProperty(n3) && (i4.hasOwnProperty(n3) || qe(n3, o4, r5));
                  for (n3 in i4) {
                    if (!i4.hasOwnProperty(n3)) continue;
                    const s3 = i4[n3];
                    e3.hasOwnProperty(n3) ? t(e3[n3], s3) || ("geojson" === e3[n3].type && "geojson" === s3.type && He(e3, i4, n3) ? o4.push({ command: We.setGeoJSONSourceData, args: [n3, s3.data] }) : $e(n3, i4, o4, r5)) : Xe(n3, i4, o4);
                  }
                }(e2.sources, i3.sources, n2, r4);
                const s2 = [];
                e2.layers && e2.layers.forEach((e3) => {
                  e3.source && r4[e3.source] ? o3.push({ command: We.removeLayer, args: [e3.id] }) : s2.push(e3);
                });
                let a2 = e2.terrain;
                a2 && r4[a2.source] && (o3.push({ command: We.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(n2), t(a2, i3.terrain) || o3.push({ command: We.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                  i4 = i4 || [];
                  const r5 = (e3 = e3 || []).map(Ke), n3 = i4.map(Ke), s3 = e3.reduce(Je, {}), a3 = i4.reduce(Je, {}), l2 = r5.slice(), c2 = /* @__PURE__ */ Object.create(null);
                  let h2, u2, _2, d2, p2, m2, f2;
                  for (h2 = 0, u2 = 0; h2 < r5.length; h2++) _2 = r5[h2], a3.hasOwnProperty(_2) ? u2++ : (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.indexOf(_2, u2), 1));
                  for (h2 = 0, u2 = 0; h2 < n3.length; h2++) _2 = n3[n3.length - 1 - h2], l2[l2.length - 1 - h2] !== _2 && (s3.hasOwnProperty(_2) ? (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - u2), 1)) : u2++, m2 = l2[l2.length - h2], o4.push({ command: We.addLayer, args: [a3[_2], m2] }), l2.splice(l2.length - h2, 0, _2), c2[_2] = true);
                  for (h2 = 0; h2 < n3.length; h2++) if (_2 = n3[h2], d2 = s3[_2], p2 = a3[_2], !c2[_2] && !t(d2, p2)) if (t(d2.source, p2.source) && t(d2["source-layer"], p2["source-layer"]) && t(d2.type, p2.type)) {
                    for (f2 in Ye(d2.layout, p2.layout, o4, _2, null, We.setLayoutProperty), Ye(d2.paint, p2.paint, o4, _2, null, We.setPaintProperty), t(d2.filter, p2.filter) || o4.push({ command: We.setFilter, args: [_2, p2.filter] }), t(d2.minzoom, p2.minzoom) && t(d2.maxzoom, p2.maxzoom) || o4.push({ command: We.setLayerZoomRange, args: [_2, p2.minzoom, p2.maxzoom] }), d2) d2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                    for (f2 in p2) p2.hasOwnProperty(f2) && !d2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                  } else o4.push({ command: We.removeLayer, args: [_2] }), m2 = l2[l2.lastIndexOf(_2) + 1], o4.push({ command: We.addLayer, args: [p2, m2] });
                }(s2, i3.layers, o3);
              } catch (e3) {
                console.warn("Unable to compute style diff:", e3), o3 = [{ command: We.setStyle, args: [i3] }];
              }
              return o3;
            }(this.serialize(), i2).filter((e2) => !(e2.command in Yt));
            if (0 === o2.length) return false;
            const r3 = o2.filter((e2) => !(e2.command in Ht));
            if (r3.length > 0) throw new Error(`Unimplemented: ${r3.map((e2) => e2.command).join(", ")}.`);
            return o2.forEach((e2) => {
              "setTransition" !== e2.command && "setProjection" !== e2.command && this[e2.command].apply(this, e2.args);
            }), this.stylesheet = i2, this._updateMapProjection(), true;
          }
          addImage(t2, i2) {
            return this.getImage(t2) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2), this);
          }
          updateImage(e2, t2) {
            this.imageManager.updateImage(e2, t2);
          }
          getImage(e2) {
            return this.imageManager.getImage(e2);
          }
          removeImage(t2) {
            return this.getImage(t2) ? (this.imageManager.removeImage(t2), this._afterImageUpdated(t2), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addSource(t2, i2, o2 = {}) {
            if (this._checkLoaded(), void 0 !== this.getSource(t2)) throw new Error("There is already a source with this ID");
            if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateSource, `sources.${t2}`, i2, null, o2)) return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const r3 = Pe(t2, i2, this.dispatcher, this);
            r3.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t2), source: r3.serialize(), sourceId: t2 }));
            const n2 = (i3) => {
              const o3 = (i3 ? "symbol:" : "other:") + t2, n3 = this._sourceCaches[o3] = new e.SourceCache(o3, r3, i3);
              (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t2] = n3, n3.style = this, n3.onAdd(this.map);
            };
            n2(false), "vector" !== i2.type && "geojson" !== i2.type || n2(true), r3.onAdd && r3.onAdd(this.map), this._changed = true;
          }
          removeSource(t2) {
            this._checkLoaded();
            const i2 = this.getSource(t2);
            if (!i2) throw new Error("There is no source with this ID");
            for (const i3 in this._layers) if (this._layers[i3].source === t2) return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
            if (this.terrain && this.terrain.get().source === t2) return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
            const o2 = this._getSourceCaches(t2);
            for (const t3 of o2) delete this._sourceCaches[t3.id], delete this._updatedSources[t3.id], t3.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
            return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true, this;
          }
          setGeoJSONSourceData(e2, t2) {
            this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
          }
          getSource(e2) {
            const t2 = this._getSourceCache(e2);
            return t2 && t2.getSource();
          }
          _getSources() {
            const e2 = [];
            for (const t2 in this._otherSourceCaches) {
              const i2 = this._getSourceCache(t2);
              i2 && e2.push(i2.getSource());
            }
            return e2;
          }
          addLayer(t2, i2, o2 = {}) {
            this._checkLoaded();
            const r3 = t2.id;
            if (this.getLayer(r3)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r3}" already exists on this map`)));
            let n2;
            if ("custom" === t2.type) {
              if ($t(this, e.validateCustomStyleLayer(t2))) return;
              n2 = e.createStyleLayer(t2);
            } else {
              if ("object" == typeof t2.source && (this.addSource(r3, t2.source), t2 = e.clone$1(t2), t2 = e.extend(t2, { source: r3 })), this._validate(e.validateLayer, `layers.${r3}`, t2, { arrayIndex: -1 }, o2)) return;
              n2 = e.createStyleLayer(t2), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
            }
            const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === s2) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
            this._order.splice(s2, 0, r3), this._layerOrderChanged = true, this._layers[r3] = n2;
            const a2 = this._getLayerSourceCache(n2);
            if (this._removedLayers[r3] && n2.source && a2 && "custom" !== n2.type) {
              const e2 = this._removedLayers[r3];
              delete this._removedLayers[r3], e2.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", a2.pause());
            }
            this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
          }
          moveLayer(t2, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t2]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
            if (t2 === i2) return;
            const o2 = this._order.indexOf(t2);
            this._order.splice(o2, 1);
            const r3 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === r3 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r3, 0, t2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
          }
          removeLayer(t2) {
            this._checkLoaded();
            const i2 = this._layers[t2];
            if (!i2) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be removed.`)));
            i2.setEventedParent(null), this._updateLayerCount(i2, false);
            const o2 = this._order.indexOf(t2);
            this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
          }
          getLayer(e2) {
            return this._layers[e2];
          }
          hasLayer(e2) {
            return e2 in this._layers;
          }
          hasLayerType(e2) {
            for (const t2 in this._layers) if (this._layers[t2].type === e2) return true;
            return false;
          }
          setLayerZoomRange(t2, i2, o2) {
            this._checkLoaded();
            const r3 = this.getLayer(t2);
            r3 ? r3.minzoom === i2 && r3.maxzoom === o2 || (null != i2 && (r3.minzoom = i2), null != o2 && (r3.maxzoom = o2), this._updateLayer(r3)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot have zoom extent.`)));
          }
          setFilter(i2, o2, r3 = {}) {
            this._checkLoaded();
            const n2 = this.getLayer(i2);
            if (n2) {
              if (!t(n2.filter, o2)) return null == o2 ? (n2.filter = void 0, void this._updateLayer(n2)) : void (this._validate(e.validateFilter, `layers.${n2.id}.filter`, o2, { layerType: n2.type }, r3) || (n2.filter = e.clone$1(o2), this._updateLayer(n2)));
            } else this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be filtered.`)));
          }
          getFilter(t2) {
            const i2 = this.getLayer(t2);
            return i2 && e.clone$1(i2.filter);
          }
          setLayoutProperty(i2, o2, r3, n2 = {}) {
            this._checkLoaded();
            const s2 = this.getLayer(i2);
            s2 ? t(s2.getLayoutProperty(o2), r3) || (s2.setLayoutProperty(o2, r3, n2), this._updateLayer(s2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
          }
          getLayoutProperty(t2, i2) {
            const o2 = this.getLayer(t2);
            if (o2) return o2.getLayoutProperty(i2);
            this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style.`)));
          }
          setPaintProperty(i2, o2, r3, n2 = {}) {
            this._checkLoaded();
            const s2 = this.getLayer(i2);
            s2 ? t(s2.getPaintProperty(o2), r3) || (s2.setPaintProperty(o2, r3, n2) && this._updateLayer(s2), this._changed = true, this._updatedPaintProps[i2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
          }
          getPaintProperty(e2, t2) {
            const i2 = this.getLayer(e2);
            return i2 && i2.getPaintProperty(t2);
          }
          setFeatureState(t2, i2) {
            this._checkLoaded();
            const o2 = t2.source, r3 = t2.sourceLayer, n2 = this.getSource(o2);
            if (!n2) return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const s2 = n2.type;
            if ("geojson" === s2 && r3) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === s2 && !r3) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
            const a2 = this._getSourceCaches(o2);
            for (const e2 of a2) e2.setFeatureState(r3, t2.id, i2);
          }
          removeFeatureState(t2, i2) {
            this._checkLoaded();
            const o2 = t2.source, r3 = this.getSource(o2);
            if (!r3) return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const n2 = r3.type, s2 = "vector" === n2 ? t2.sourceLayer : void 0;
            if ("vector" === n2 && !s2) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i2 && "string" != typeof t2.id && "number" != typeof t2.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
            const a2 = this._getSourceCaches(o2);
            for (const e2 of a2) e2.removeFeatureState(s2, t2.id, i2);
          }
          getFeatureState(t2) {
            this._checkLoaded();
            const i2 = t2.source, o2 = t2.sourceLayer, r3 = this.getSource(i2);
            if (r3) {
              if ("vector" !== r3.type || o2) return void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t2.id);
              this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            const t2 = {};
            for (const e2 in this._sourceCaches) {
              const i2 = this._sourceCaches[e2].getSource();
              t2[i2.id] || (t2[i2.id] = i2.serialize());
            }
            return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t2, layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
          }
          _updateLayer(e2) {
            this._updatedLayers[e2.id] = true;
            const t2 = this._getLayerSourceCache(e2);
            e2.source && !this._updatedSources[e2.source] && t2 && "raster" !== t2.getSource().type && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true, e2.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e2) {
            const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, o2 = [];
            for (let r4 = this._order.length - 1; r4 >= 0; r4--) {
              const n2 = this._order[r4];
              if (t2(n2)) {
                i2[n2] = r4;
                for (const t3 of e2) {
                  const e3 = t3[n2];
                  if (e3) for (const t4 of e3) o2.push(t4);
                }
              }
            }
            o2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
            const r3 = [];
            for (let n2 = this._order.length - 1; n2 >= 0; n2--) {
              const s2 = this._order[n2];
              if (t2(s2)) for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                const t3 = o2[e3].feature;
                if (i2[t3.layer.id] < n2) break;
                r3.push(t3), o2.pop();
              }
              else for (const t3 of e2) {
                const e3 = t3[s2];
                if (e3) for (const t4 of e3) r3.push(t4.feature);
              }
            }
            return r3;
          }
          queryRenderedFeatures(t2, i2, o2) {
            i2 && i2.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const r3 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const t3 of i2.layers) {
                const i3 = this._layers[t3];
                if (!i3) return this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                r3[i3.source] = true;
              }
            }
            const n2 = [];
            i2.availableImages = this._availableImages;
            const s2 = i2 && i2.layers ? i2.layers.some((e2) => {
              const t3 = this.getLayer(e2);
              return t3 && t3.is3D();
            }) : this.has3DLayers(), a2 = R.createFromScreenPoints(t2, o2);
            for (const e2 in this._sourceCaches) {
              const t3 = this._sourceCaches[e2].getSource().id;
              i2.layers && !r3[t3] || n2.push(Oe(this._sourceCaches[e2], this._layers, this._serializedLayers, a2, i2, o2, s2, !!this.map._showQueryGeometry));
            }
            return this.placement && n2.push(function(e2, t3, i3, o3, r4, n3, s3) {
              const a3 = {}, l2 = n3.queryRenderedSymbols(o3), c2 = [];
              for (const e3 of Object.keys(l2).map(Number)) c2.push(s3[e3]);
              c2.sort(ke);
              for (const i4 of c2) {
                const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r4.filter, r4.layers, r4.availableImages, e2);
                for (const e3 in o4) {
                  const t4 = a3[e3] = a3[e3] || [], r5 = o4[e3];
                  r5.sort((e4, t5) => {
                    const o5 = i4.featureSortOrder;
                    if (o5) {
                      const i5 = o5.indexOf(e4.featureIndex);
                      return o5.indexOf(t5.featureIndex) - i5;
                    }
                    return t5.featureIndex - e4.featureIndex;
                  });
                  for (const e4 of r5) t4.push(e4);
                }
              }
              for (const t4 in a3) a3[t4].forEach((o4) => {
                const r5 = o4.feature, n4 = i3(e2[t4]);
                if (!n4) return;
                const s4 = n4.getFeatureState(r5.layer["source-layer"], r5.id);
                r5.source = r5.layer.source, r5.layer["source-layer"] && (r5.sourceLayer = r5.layer["source-layer"]), r5.state = s4;
              });
              return a3;
            }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
          }
          querySourceFeatures(t2, i2) {
            i2 && i2.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i2.filter, null, i2);
            const o2 = this._getSourceCaches(t2);
            let r3 = [];
            for (const e2 of o2) r3 = r3.concat(Be(e2, i2));
            return r3;
          }
          addSourceType(e2, t2, i2) {
            return Qt.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Qt.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i2 = {}) {
            this._checkLoaded();
            const o2 = this.light.getLight();
            let r3 = false;
            for (const i3 in e2) if (!t(e2[i3], o2[i3])) {
              r3 = true;
              break;
            }
            if (!r3) return;
            const n2 = this._setTransitionParameters({ duration: 300, delay: 0 });
            this.light.setLight(e2, i2), this.light.updateTransitions(n2);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(i2, o2 = 1) {
            if (this._checkLoaded(), !i2) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            let r3 = i2;
            if (1 === o2) {
              if ("object" == typeof r3.source) {
                const t2 = "terrain-dem-src";
                this.addSource(t2, r3.source), r3 = e.clone$1(r3), r3 = e.extend(r3, { source: t2 });
              }
              if (this._validate(e.validateTerrain, "terrain", r3)) return;
            }
            if (!this.terrain || this.terrain && o2 !== this.terrain.drapeRenderMode) {
              if (!r3) return;
              this._createTerrain(r3, o2);
            } else {
              const i3 = this.terrain, o3 = i3.get();
              for (const t2 of Object.keys(e.spec.terrain)) !r3.hasOwnProperty(t2) && e.spec.terrain[t2].default && (r3[t2] = e.spec.terrain[t2].default);
              for (const e2 in r3) if (!t(r3[e2], o3[e2])) {
                i3.set(r3), this.stylesheet.terrain = r3;
                const e3 = this._setTransitionParameters({ duration: 0 });
                i3.updateTransitions(e3);
                break;
              }
            }
            this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e2) {
            const t2 = this.fog = new A(e2, this.map.transform);
            this.stylesheet.fog = e2;
            const i2 = this._setTransitionParameters({ duration: 0 });
            t2.updateTransitions(i2);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e2 of this.map._markers) e2._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(e2) {
            if (this._checkLoaded(), !e2) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i2 = this.fog, o2 = i2.get();
              0 === Object.keys(e2).length && i2.set(e2);
              for (const r3 in e2) if (!t(e2[r3], o2[r3])) {
                i2.set(e2), this.stylesheet.fog = e2;
                const t2 = this._setTransitionParameters({ duration: 0 });
                i2.updateTransitions(t2);
                break;
              }
            } else this._createFog(e2);
            this._markersNeedUpdate = true;
          }
          _setTransitionParameters(t2) {
            return { now: e.exported.now(), transition: e.extend(t2, this.stylesheet.transition) };
          }
          _updateDrapeFirstLayers() {
            if (!this.map._optimizeForTerrain || !this.terrain) return;
            const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
          }
          _createTerrain(e2, t2) {
            const i2 = this.terrain = new M(e2, t2);
            this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
            const o2 = this._setTransitionParameters({ duration: 0 });
            i2.updateTransitions(o2);
          }
          _force3DLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "fill-extrusion" === t2.type && this._updateLayer(t2);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "symbol" === t2.type && this._updateLayer(t2);
            }
          }
          _validate(t2, i2, o2, r3, n2 = {}) {
            return (!n2 || false !== n2.validate) && $t(this, t2.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r3)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e2 in this._layers) this._layers[e2].setEventedParent(null);
            for (const e2 in this._sourceCaches) this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(e2) {
            const t2 = this._getSourceCaches(e2);
            for (const e3 of t2) e3.clearTiles();
          }
          _reloadSource(e2) {
            const t2 = this._getSourceCaches(e2);
            for (const e3 of t2) e3.resume(), e3.reload();
          }
          _reloadSources() {
            for (const e2 of this._getSources()) e2.reload && e2.reload();
          }
          _updateSources(e2) {
            for (const t2 in this._sourceCaches) this._sourceCaches[t2].update(e2);
          }
          _generateCollisionBoxes() {
            for (const e2 in this._sourceCaches) {
              const t2 = this._sourceCaches[e2];
              t2.resume(), t2.reload();
            }
          }
          _updatePlacement(t2, i2, o2, r3, n2 = false) {
            let s2 = false, a2 = false;
            const l2 = {};
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              if ("symbol" !== i3.type) continue;
              if (!l2[i3.source]) {
                const e3 = this._getLayerSourceCache(i3);
                if (!e3) continue;
                l2[i3.source] = e3.getRenderableIds(true).map((t3) => e3.getTileByID(t3)).sort((e4, t3) => t3.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t3.tileID) ? -1 : 1));
              }
              const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng, t2.projection);
              s2 = s2 || o3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || 0 === o2, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t2.zoom)) && (this.pauseablePlacement = new jt(t2, this._order, n2, i2, o2, r3, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a2 = true), s2 && this.pauseablePlacement.placement.setStale()), a2 || s2) for (const e2 of this._order) {
              const t3 = this._layers[e2];
              "symbol" === t3.type && this.placement.updateLayerOpacities(t3, l2[t3.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e2 in this._sourceCaches) this._sourceCaches[e2].releaseSymbolFadeTiles();
          }
          getImages(e2, t2, i2) {
            this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
            const o2 = (e3) => {
              e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
            };
            o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
          }
          getGlyphs(e2, t2, i2) {
            this.glyphManager.getGlyphs(t2.stacks, i2);
          }
          getResource(t2, i2, o2) {
            return e.makeRequest(i2, o2);
          }
          _getSourceCache(e2) {
            return this._otherSourceCaches[e2];
          }
          _getLayerSourceCache(e2) {
            return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
          }
          _getSourceCaches(e2) {
            const t2 = [];
            return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
          }
          _isSourceCacheLoaded(t2) {
            const i2 = this._getSourceCaches(t2);
            return 0 === i2.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
          }
          has3DLayers() {
            return this._num3DLayers > 0;
          }
          hasSymbolLayers() {
            return this._numSymbolLayers > 0;
          }
          hasCircleLayers() {
            return this._numCircleLayers > 0;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Qt.getSourceType = function(e2) {
          return ze[e2];
        }, Qt.setSourceType = function(e2, t2) {
          ze[e2] = t2;
        }, Qt.registerForPluginStateChange = e.registerForPluginStateChange;
        var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let ni = {}, si = {};
        const ai = [];
        _i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);
        const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ci = ei, hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ui = { background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
        function _i(e2, t2) {
          const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
          for (let e3 of i2) if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3) t2.includes(e4) || t2.push(e4);
          }
        }
        function di(e2, t2) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r3 = {}, n2 = [...ai];
          return _i(e2, n2), _i(t2, n2), { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, o3, n3) => (r3[n3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, o3, n3) => {
            const s2 = "float" === o3 ? "vec2" : "vec4", a2 = n3.match(/color/) ? "color" : s2;
            return r3[n3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`;
          }), staticAttributes: o2, usedDefines: n2 };
        }
        class pi {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e2, t2, i2, o2, r3, n2, s2) {
            this.context = e2;
            let a2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let e3 = 0; !a2 && e3 < o2.length; e3++) this.boundPaintVertexBuffers[e3] !== o2[e3] && (a2 = true);
            let l2 = this.boundDynamicVertexBuffers.length !== s2.length;
            for (let e3 = 0; !l2 && e3 < s2.length; e3++) this.boundDynamicVertexBuffers[e3] !== s2[e3] && (l2 = true);
            if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || a2 || l2 || this.boundIndexBuffer !== r3 || this.boundVertexOffset !== n2) this.freshBind(t2, i2, o2, r3, n2, s2);
            else {
              e2.bindVertexArrayOES.set(this.vao);
              for (const e3 of s2) e3 && e3.bind();
              r3 && r3.dynamicDraw && r3.bind();
            }
          }
          freshBind(e2, t2, i2, o2, r3, n2) {
            let s2;
            const a2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
            if (l2.extVertexArrayObject) this.vao && this.destroy(), this.vao = l2.extVertexArrayObject.createVertexArrayOES(), l2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r3, this.boundDynamicVertexBuffers = n2;
            else {
              s2 = l2.currentNumAttributes || 0;
              for (let e3 = a2; e3 < s2; e3++) c2.disableVertexAttribArray(e3);
            }
            t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, r3);
            for (const t3 of i2) t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r3);
            for (const t3 of n2) t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r3));
            o2 && o2.bind(), l2.currentNumAttributes = a2;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function mi(t2, i2) {
          const o2 = Math.pow(2, i2.canonical.z), r3 = i2.canonical.y;
          return [new e.MercatorCoordinate(0, r3 / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r3 + 1) / o2).toLngLat().lat];
        }
        function fi(t2, i2, o2, r3, n2, s2, a2) {
          const l2 = t2.context, c2 = l2.gl, h2 = o2.fbo;
          if (!h2) return;
          t2.prepareDrawTile();
          const u2 = t2.useProgram("hillshade");
          l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
          const _2 = ((e2, t3, i3, o3) => {
            const r4 = i3.paint.get("hillshade-shadow-color"), n3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
            let a3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i3.paint.get("hillshade-illumination-anchor") && (a3 -= e2.transform.angle);
            const l3 = !e2.options.moving;
            return { u_matrix: o3 || e2.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: mi(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), a3], u_shadow: r4, u_highlight: n3, u_accent: s3 };
          })(t2, o2, r3, t2.terrain ? i2.projMatrix : null);
          t2.prepareDrawProgram(l2, u2, i2.toUnwrapped());
          const { tileBoundsBuffer: d2, tileBoundsIndexBuffer: p2, tileBoundsSegments: m2 } = t2.getTileBoundsBuffers(o2);
          u2.draw(l2, c2.TRIANGLES, n2, s2, a2, e.CullFaceMode.disabled, _2, r3.id, d2, p2, m2);
        }
        function gi(t2, i2, o2) {
          if (!i2.needsDEMTextureUpload) return;
          const r3 = t2.context, n2 = r3.gl;
          r3.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
          const s2 = o2.getPixels();
          i2.demTexture ? i2.demTexture.update(s2, { premultiply: false }) : i2.demTexture = new e.Texture(r3, s2, n2.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
        }
        function vi(t2, i2, o2, r3, n2, s2) {
          const a2 = t2.context, l2 = a2.gl;
          if (!i2.dem) return;
          const c2 = i2.dem;
          if (a2.activeTexture.set(l2.TEXTURE1), gi(t2, i2, c2), !i2.demTexture) return;
          i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          const h2 = c2.dim;
          a2.activeTexture.set(l2.TEXTURE0);
          let u2 = i2.fbo;
          if (!u2) {
            const t3 = new e.Texture(a2, { width: h2, height: h2, data: null }, l2.RGBA);
            t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u2 = i2.fbo = a2.createFramebuffer(h2, h2, true), u2.colorAttachment.set(t3.texture);
          }
          a2.bindFramebuffer.set(u2.framebuffer), a2.viewport.set([0, 0, h2, h2]);
          const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d2, tileBoundsSegments: p2 } = t2.getMercatorTileBoundsBuffers();
          t2.useProgram("hillshadePrepare").draw(a2, l2.TRIANGLES, r3, n2, s2, e.CullFaceMode.disabled, ((t3, i3) => {
            const o3 = i3.stride, r4 = e.create();
            return e.ortho(r4, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r4, r4, [0, -e.EXTENT, 0]), { u_matrix: r4, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ, u_unpack: i3.unpackVector };
          })(i2.tileID, c2), o2.id, _2, d2, p2), i2.needsHillshadePrepare = false;
        }
        const xi = (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image0: new e.Uniform1i(t2), u_skirt_height: new e.Uniform1f(t2) }), yi = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), bi = (e2, t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r3, u_merc_center: n2, u_image0: 0, u_frustum_tl: s2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h2, u_globe_radius: u2, u_viewport: _2, u_grid_matrix: p2 ? Float32Array.from(p2) : new Float32Array(9), u_skirt_height: d2 });
        function wi(e2, t2) {
          return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
        }
        const Ti = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e2, t2, i2, o2, r3) {
            if (e2 in this.operations) {
              const t3 = this.operations[e2];
              t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
            } else this.operations[e2] = { startTime: o2, phase: 0, duration: r3, from: t2, to: i2, queued: null };
          }
          getMorphValuesForProxy(e2) {
            if (!(e2 in this.operations)) return null;
            const t2 = this.operations[e2];
            return { from: t2.from, to: t2.to, phase: t2.phase };
          }
          update(e2) {
            for (const t2 in this.operations) {
              const i2 = this.operations[t2];
              for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); ) if (!this._nextOp(i2, e2)) {
                delete this.operations[t2];
                break;
              }
            }
          }
          _nextOp(e2, t2) {
            return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
          }
          _validOp(e2) {
            return e2.from.hasData() && e2.to.hasData();
          }
        }(), Ei = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
        function Ci(e2) {
          return 6 * Math.pow(1.5, 22 - e2);
        }
        function Mi(e2, t2) {
          const i2 = 1 << e2.z;
          return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
        }
        const Ii = (e2) => ({ u_matrix: e2 });
        function Si(t2, i2, o2, r3, n2) {
          if (n2 > 0) {
            const s2 = e.exported.now(), a2 = (s2 - t2.timeAdded) / n2, l2 = i2 ? (s2 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = r3.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), _2 = u2 && t2.refreshedUponExpiration ? 1 : e.clamp(u2 ? a2 : 1 - l2, 0, 1);
            return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class Di extends e.SourceCache {
          constructor(e2) {
            const t2 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new z(je(), null), o2 = Pe("mock-dem", t2, i2, e2.style);
            super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e2, t2) {
            e2.state = "loaded", t2(null);
          }
        }
        class Li extends e.SourceCache {
          constructor(e2) {
            const t2 = Pe("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new z(je(), null), e2.style);
            super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t2, i2, o2) {
            if (t2.freezeTileCoverage) return;
            this.transform = t2;
            const r3 = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
              if (i3[o3.key] = "", !this._tiles[o3.key]) {
                const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
                i4.state = "loaded", this._tiles[o3.key] = i4;
              }
              return i3;
            }, {});
            for (const e2 in this._tiles) e2 in r3 || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
          }
          freeFBO(e2) {
            const t2 = this.proxyCachedFBO[e2];
            if (void 0 !== t2) {
              const i2 = Object.values(t2);
              this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class Ai extends e.OverscaledTileID {
          constructor(e2, t2, i2) {
            super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
          }
        }
        class zi extends e.Elevation {
          constructor(t2, i2) {
            super(), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o2, r3, n2] = function(t3) {
              const i3 = new e.StructArrayLayout2i4(), o3 = new e.StructArrayLayout3ui6(), r4 = 131;
              i3.reserve(17161), o3.reserve(33800);
              const n3 = e.EXTENT / 128, s3 = e.EXTENT + n3 / 2, a3 = s3 + n3;
              for (let t4 = -n3; t4 < a3; t4 += n3) for (let o4 = -n3; o4 < a3; o4 += n3) {
                const r5 = o4 < 0 || o4 > s3 || t4 < 0 || t4 > s3 ? 24575 : 0, n4 = e.clamp(Math.round(o4), 0, e.EXTENT), a4 = e.clamp(Math.round(t4), 0, e.EXTENT);
                i3.emplaceBack(n4 + r5, a4);
              }
              const l2 = (e2, t4) => {
                const i4 = t4 * r4 + e2;
                o3.emplaceBack(i4 + 1, i4, i4 + r4), o3.emplaceBack(i4 + r4, i4 + r4 + 1, i4 + 1);
              };
              for (let e2 = 1; e2 < 129; e2++) for (let t4 = 1; t4 < 129; t4++) l2(t4, e2);
              return [0, 129].forEach((e2) => {
                for (let t4 = 0; t4 < 130; t4++) l2(t4, e2), l2(e2, t4);
              }), [i3, o3, 32768];
            }(), s2 = t2.context;
            this.gridBuffer = s2.createVertexBuffer(o2, e.posAttributes.members), this.gridIndexBuffer = s2.createIndexBuffer(r3), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r3.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i2.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);
            const a2 = s2.gl;
            this._overlapStencilMode = new e.StencilMode({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Di(i2.map);
          }
          set style(e2) {
            e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t2, i2, o2) {
            if (t2 && t2.terrain) {
              this._style !== t2 && (this.style = t2), this.enabled = true;
              const r3 = t2.terrain.properties;
              this.sourceCache = 0 === t2.terrain.drapeRenderMode ? this._mockSourceCache : t2._getSourceCache(r3.get("source")), this._exaggeration = r3.get("exaggeration");
              const n2 = () => {
                this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t3 = this.getScaledDemTileSize();
                this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
            } else this._disable();
          }
          resetTileLookupCache(e2) {
            this._findCoveringTileCache[e2] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _checkRenderCacheEfficiency() {
            const t2 = this.renderCacheEfficiency(this._style);
            this._style.map._optimizeForTerrain || 100 !== t2.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
          }
          _onStyleDataEvent(e2) {
            e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this._invalidateRenderCache = true);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e2 in this._style._sourceCaches) this._style._sourceCaches[e2].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e2 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e2, e2];
          }
          set useVertexMorphing(e2) {
            this._useVertexMorphing = e2;
          }
          updateTileBinding(t2) {
            if (!this.enabled) return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i2 = this.proxySourceCache, o2 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const r3 = this.proxyCoords = i2.getIds().map((e2) => {
              const t3 = i2.getTileByID(e2).tileID;
              return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
            });
            !function(t3, i3) {
              const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r4 = new e.pointGeometry(o3.x, o3.y);
              t3.sort((t4, i4) => {
                if (i4.overscaledZ - t4.overscaledZ) return i4.overscaledZ - t4.overscaledZ;
                const o4 = new e.pointGeometry(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), n3 = new e.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), s3 = r4.mult(1 << t4.canonical.z);
                return s3.x -= 0.5, s3.y -= 0.5, s3.distSqr(o4) - s3.distSqr(n3);
              });
            }(r3, this.painter), this._previousZoom = o2.zoom;
            const n2 = this.proxyToSource || {};
            this.proxyToSource = {}, r3.forEach((e2) => {
              this.proxyToSource[e2.key] = {};
            }), this.terrainTileForTile = {};
            const s2 = this._style._sourceCaches;
            for (const e2 in s2) {
              const i3 = s2[e2];
              if (!i3.used) continue;
              if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], n2), i3.usedForTerrain) continue;
              const o3 = t2[e2];
              i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
            }
            this.proxiedCoords[i2.id] = r3.map((e2) => new Ai(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
            const a2 = {};
            this._visibleDemTiles = [];
            for (const e2 of this.proxyCoords) {
              const t3 = this.terrainTileForTile[e2.key];
              if (!t3) continue;
              const i3 = t3.tileID.key;
              i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
            }
          }
          _assignTerrainTiles(e2) {
            this._initializing || e2.forEach((e3) => {
              if (this.terrainTileForTile[e3.key]) return;
              const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
              t2 && (this.terrainTileForTile[e3.key] = t2);
            });
          }
          _prepareDEMTextures() {
            const e2 = this.painter.context, t2 = e2.gl;
            for (const i2 in this.terrainTileForTile) {
              const o2 = this.terrainTileForTile[i2], r3 = o2.dem;
              !r3 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), gi(this.painter, o2, r3));
            }
          }
          _prepareDemTileUniforms(e2, t2, i2, o2) {
            if (!t2 || null == t2.demTexture) return false;
            const r3 = e2.tileID.canonical, n2 = Math.pow(2, t2.tileID.canonical.z - r3.z), s2 = o2 || "";
            return i2[`u_dem_tl${s2}`] = [r3.x * n2 % 1, r3.y * n2 % 1], i2[`u_dem_scale${s2}`] = n2, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t2 = this.painter.context, i2 = t2.gl;
            if (!this._emptyDepthBufferTexture) {
              const o2 = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
              this._emptyDepthBufferTexture = new e.Texture(t2, o2, i2.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e2 = 0;
            const t2 = this._visibleDemTiles.reduce((t3, i2) => {
              if (!i2.dem) return t3;
              const o2 = i2.dem.tree.minimums[0];
              return o2 > 0 && e2++, t3 + o2;
            }, 0);
            return e2 ? t2 / e2 : 0;
          }
          _updateEmptyDEMTexture() {
            const t2 = this.painter.context, i2 = t2.gl;
            t2.activeTexture.set(i2.TEXTURE2);
            const o2 = this._getLoadedAreaMinimum(), r3 = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)));
            this._emptyDEMTextureDirty = false;
            let n2 = this._emptyDEMTexture;
            return n2 ? n2.update(r3, { premultiply: false }) : n2 = this._emptyDEMTexture = new e.Texture(t2, r3, i2.RGBA, { premultiply: false }), n2;
          }
          setupElevationDraw(t2, i2, o2) {
            const r3 = this.painter.context, n2 = r3.gl, s2 = (a2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
            var a2;
            s2.u_dem_size = this.sourceCache.getSource().tileSize, s2.u_exaggeration = this.exaggeration();
            let l2 = null, c2 = null, h2 = 1;
            if (o2 && o2.morphing && this._useVertexMorphing) {
              const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
              h2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, s2, "_prev") && (c2 = e2), this._prepareDemTileUniforms(t2, i3, s2) && (l2 = i3));
            }
            if (c2 && l2 ? (r3.activeTexture.set(n2.TEXTURE2), l2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r3.activeTexture.set(n2.TEXTURE4), c2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), s2.u_dem_lerp = h2) : (l2 = this.terrainTileForTile[t2.tileID.key], r3.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(t2, l2, s2) ? l2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE)), r3.activeTexture.set(n2.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), this._depthFBO && (s2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), s2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && l2) {
              const t3 = (1 << l2.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              s2.u_meter_to_dem = t3;
            }
            if (o2 && o2.labelPlaneMatrixInv && (s2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r3, s2), "globe" === this.painter.transform.projection.name) {
              const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
              i2.setGlobeUniformValues(r3, e2);
            }
          }
          globeUniformValues(t2, i2, o2) {
            const r3 = t2.projection;
            return { u_tile_tl_up: r3.upVector(i2, 0, 0), u_tile_tr_up: r3.upVector(i2, e.EXTENT, 0), u_tile_br_up: r3.upVector(i2, e.EXTENT, e.EXTENT), u_tile_bl_up: r3.upVector(i2, 0, e.EXTENT), u_tile_up_scale: o2 ? e.globeMetersToEcef(1) : r3.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
          }
          renderToBackBuffer(t2) {
            const i2 = this.painter, o2 = this.painter.context;
            0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r3, n2) {
              if ("globe" === t3.transform.projection.name) !function(t4, i4, o4, r4, n3) {
                const s2 = t4.context, a2 = s2.gl;
                let l2, c2;
                const h2 = t4.options.showTerrainWireframe ? 2 : 0, u2 = t4.transform, _2 = e.globeUseCustomAntiAliasing(t4, s2, u2), d2 = (e2, i5) => {
                  if (c2 === e2) return;
                  const o5 = [Ei[e2], "PROJECTION_GLOBE_VIEW"];
                  _2 && o5.push("CUSTOM_ANTIALIASING"), i5 && o5.push(Ei[h2]), l2 = t4.useProgram("globeRaster", null, o5), c2 = e2;
                }, p2 = t4.colorModeForRenderPass(), m2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
                Ti.update(n3);
                const f2 = e.calculateGlobeMercatorMatrix(u2), g2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], v2 = h2 ? [false, true] : [false], x2 = t4.globeSharedBuffers, y2 = [u2.width * e.exported.devicePixelRatio, u2.height * e.exported.devicePixelRatio], b2 = Float32Array.from(u2.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                if (v2.forEach((h3) => {
                  const u3 = t4.transform, _3 = Ci(u3.zoom) * i4.exaggeration();
                  c2 = -1;
                  const v3 = h3 ? a2.LINES : a2.TRIANGLES;
                  for (const c3 of r4) {
                    const r5 = o4.getTile(c3), T2 = e.StencilMode.disabled, E2 = i4.prevTerrainTileForTile[c3.key], C2 = i4.terrainTileForTile[c3.key];
                    wi(E2, C2) && Ti.newMorphing(c3.key, E2, C2, n3, 250), s2.activeTexture.set(a2.TEXTURE0), r5.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                    const M2 = Ti.getMorphValuesForProxy(c3.key), I2 = M2 ? 1 : 0;
                    M2 && e.extend$1(w2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e.easeCubicInOut(M2.phase) } });
                    const S2 = e.tileCornersToBounds(c3.canonical), D2 = e.getLatitudinalLod(S2.getCenter().lat), L2 = e.getGridMatrix(c3.canonical, S2, D2, u3.worldSize / u3._pixelsPerMercatorPixel), A2 = e.globeNormalizeECEF(e.globeTileBounds(c3.canonical)), z2 = bi(u3.projMatrix, b2, f2, A2, e.globeToMercatorTransition(u3.zoom), g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y2, _3, L2);
                    if (d2(I2, h3), i4.setupElevationDraw(r5, l2, w2), t4.prepareDrawProgram(s2, l2, c3.toUnwrapped()), x2) {
                      const [i5, o5, r6] = h3 ? x2.getWirefameBuffers(t4.context, D2) : x2.getGridBuffers(D2, 0 !== _3);
                      l2.draw(s2, v3, m2, T2, p2, e.CullFaceMode.backCCW, z2, "globe_raster", i5, o5, r6);
                    }
                  }
                }), x2) {
                  const n4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _2 && n4.push("CUSTOM_ANTIALIASING"), l2 = t4.useProgram("globeRaster", null, n4);
                  for (const n5 of r4) {
                    const { x: r5, y: c3, z: h3 } = n5.canonical, _3 = 0 === c3, d3 = c3 === (1 << h3) - 1, [f3, v3, b3, T2] = x2.getPoleBuffers(h3);
                    if (T2 && (_3 || d3)) {
                      const c4 = o4.getTile(n5);
                      s2.activeTexture.set(a2.TEXTURE0), c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      let x3 = e.globePoleMatrixForTile(h3, r5, u2);
                      const E2 = e.globeNormalizeECEF(e.globeTileBounds(n5.canonical)), C2 = (t5, i5) => t5.draw(s2, a2.TRIANGLES, m2, e.StencilMode.disabled, p2, e.CullFaceMode.disabled, bi(u2.projMatrix, x3, x3, E2, 0, g2, u2.frustumCorners.TL, u2.frustumCorners.TR, u2.frustumCorners.BR, u2.frustumCorners.BL, u2.globeCenterInViewSpace, u2.globeRadius, y2, 0), "globe_pole_raster", i5, b3, T2);
                      i4.setupElevationDraw(c4, l2, w2), t4.prepareDrawProgram(s2, l2, n5.toUnwrapped()), _3 && C2(l2, f3), d3 && (x3 = e.scale(e.create(), x3, [1, -1, 1]), C2(l2, v3));
                    }
                  }
                }
              }(t3, i3, o3, r3, n2);
              else {
                const s2 = t3.context, a2 = s2.gl;
                let l2, c2;
                const h2 = t3.options.showTerrainWireframe ? 2 : 0, u2 = (e2, i4) => {
                  if (c2 === e2) return;
                  const o4 = [Ei[e2]];
                  i4 && o4.push(Ei[h2]), l2 = t3.useProgram("terrainRaster", null, o4), c2 = e2;
                }, _2 = t3.colorModeForRenderPass(), d2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
                Ti.update(n2);
                const p2 = t3.transform, m2 = Ci(p2.zoom) * i3.exaggeration();
                (h2 ? [false, true] : [false]).forEach((h3) => {
                  c2 = -1;
                  const f2 = h3 ? a2.LINES : a2.TRIANGLES, [g2, v2] = h3 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                  for (const c3 of r3) {
                    const r4 = o3.getTile(c3), x2 = e.StencilMode.disabled, y2 = i3.prevTerrainTileForTile[c3.key], b2 = i3.terrainTileForTile[c3.key];
                    wi(y2, b2) && Ti.newMorphing(c3.key, y2, b2, n2, 250), s2.activeTexture.set(a2.TEXTURE0), r4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
                    const w2 = Ti.getMorphValuesForProxy(c3.key), T2 = w2 ? 1 : 0;
                    let E2;
                    w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e.easeCubicInOut(w2.phase) } });
                    const C2 = yi(c3.projMatrix, Mi(c3.canonical, p2.renderWorldCopies) ? m2 / 10 : m2);
                    u2(T2, h3), i3.setupElevationDraw(r4, l2, E2), t3.prepareDrawProgram(s2, l2, c3.toUnwrapped()), l2.draw(s2, f2, d2, x2, _2, e.CullFaceMode.backCCW, C2, "terrain_raster", i3.gridBuffer, g2, v2);
                  }
                });
              }
            }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
          }
          renderBatch(t2) {
            if (0 === this._drapedRenderBatches.length) return t2 + 1;
            this.renderingToTexture = true;
            const i2 = this.painter, o2 = this.painter.context, r3 = this.proxySourceCache, n2 = this.proxiedCoords[r3.id], s2 = this._drapedRenderBatches.shift(), a2 = [], l2 = i2.style.order;
            let c2 = 0;
            for (const h2 of n2) {
              const n3 = r3.getTileByID(h2.proxyTileKey), u2 = r3.proxyCachedFBO[h2.key] ? r3.proxyCachedFBO[h2.key][t2] : void 0, _2 = void 0 !== u2 ? r3.renderCache[u2] : this.pool[c2++], d2 = void 0 !== u2;
              if (n3.texture = _2.tex, d2 && !_2.dirty) {
                a2.push(n3.tileID);
                continue;
              }
              let p2;
              o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e.Color.transparent, stencil: 0 }), _2.dirty = false);
              for (let e2 = s2.start; e2 <= s2.end; ++e2) {
                const t3 = i2.style._layers[l2[e2]];
                if (t3.isHidden(i2.transform.zoom)) continue;
                const r4 = i2.style._getLayerSourceCache(t3), n4 = r4 ? this.proxyToSource[h2.key][r4.id] : [h2];
                if (!n4) continue;
                const s3 = n4;
                o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p2 !== (r4 ? r4.id : null) && (this._setupStencil(_2, n4, t3, r4), p2 = r4 ? r4.id : null), i2.renderLayer(i2, r4, t3, s3);
              }
              this.renderedToTile ? (_2.dirty = true, a2.push(n3.tileID)) : d2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(a2));
            }
            return this.renderToBackBuffer(a2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), s2.end + 1;
          }
          postRender() {
          }
          renderCacheEfficiency(e2) {
            const t2 = e2.order.length;
            if (0 === t2) return { efficiency: 100 };
            let i2, o2 = 0, r3 = 0, n2 = false;
            for (let s2 = 0; s2 < t2; ++s2) {
              const t3 = e2._layers[e2.order[s2]];
              this._style.isLayerDraped(t3) ? (n2 && ++o2, ++r3) : n2 || (n2 = true, i2 = t3.id);
            }
            return 0 === r3 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r3), firstUndrapedLayer: i2 };
          }
          getMinElevationBelowMSL() {
            let e2 = 0;
            return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
              e2 = Math.min(e2, t2.dem.tree.minimums[0]);
            }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
          }
          raycast(e2, t2, i2) {
            if (!this._visibleDemTiles) return null;
            const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
              const r3 = o3.tileID, n2 = 1 << r3.overscaledZ, { x: s2, y: a2 } = r3.canonical, l2 = s2 / n2, c2 = (s2 + 1) / n2, h2 = a2 / n2, u2 = (a2 + 1) / n2;
              return { minx: l2, miny: h2, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h2, c2, u2, e2, t2, i2), tile: o3 };
            });
            o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
            for (const r3 of o2) {
              if (null == r3.t) return null;
              const o3 = r3.tile.dem.tree.raycast(r3.minx, r3.miny, r3.maxx, r3.maxy, e2, t2, i2);
              if (null != o3) return o3;
            }
            return null;
          }
          _createFBO() {
            const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
            t2.activeTexture.set(i2.TEXTURE0);
            const r3 = new e.Texture(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
            r3.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
            const n2 = t2.createFramebuffer(o2[0], o2[1], false);
            return n2.colorAttachment.set(r3.texture), n2.depthAttachment = new Ee(t2, n2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && !t2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: n2, tex: r3, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._style.light && this._style.light.hasTransition()) return true;
            for (const e2 in this._style._sourceCaches) if (this._style._sourceCaches[e2].hasTransition()) return true;
            return this._style.order.some((e2) => {
              const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
              return "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t2 = false;
            for (const e2 of this._style._getSources()) if (e2 instanceof Ie) {
              t2 = true;
              break;
            }
            if (!t2) return;
            const i2 = {};
            for (let t3 = 0; t3 < this._style.order.length; ++t3) {
              const o2 = this._style._layers[this._style.order[t3]], r3 = this._style._getLayerSourceCache(o2);
              if (r3 && !i2[r3.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.ZoomDependentExpression) {
                i2[r3.id] = true;
                for (const e2 of this.proxyCoords) {
                  const t4 = this.proxyToSource[e2.key][r3.id];
                  if (t4) for (const e3 of t4) this._clearRenderCacheForTile(r3.id, e3);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e2 = false;
            for (const t3 in this._style._sourceCaches) if (this._style._sourceCaches[t3]._source instanceof Se) {
              e2 = true;
              break;
            }
            if (!e2) return;
            const t2 = {};
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const i2 = this._style._layers[this._style.order[e3]], o2 = this._style._getLayerSourceCache(i2);
              if (!o2 || t2[o2.id]) continue;
              if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type) continue;
              const r3 = i2.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t3 = this.proxyToSource[e4.key][o2.id];
                if (t3) for (const e5 of t3) {
                  const t4 = Si(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r3);
                  (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                }
              }
            }
          }
          _setupDrapedRenderBatches() {
            const e2 = this._style.order, t2 = e2.length;
            if (0 === t2) return;
            const i2 = [];
            let o2, r3 = 0, n2 = this._style._layers[e2[r3]];
            for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r3 < t2; ) n2 = this._style._layers[e2[r3]];
            for (; r3 < t2; ++r3) {
              const t3 = this._style._layers[e2[r3]];
              t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? void 0 === o2 && (o2 = r3) : void 0 !== o2 && (i2.push({ start: o2, end: r3 - 1 }), o2 = void 0));
            }
            void 0 !== o2 && i2.push({ start: o2, end: r3 - 1 }), this._drapedRenderBatches = i2;
          }
          _setupRenderCache(e2) {
            const t2 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
              if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                const e3 = Object.values(t2.proxyCachedFBO);
                t2.proxyCachedFBO = {};
                for (let i3 = 0; i3 < e3.length; ++i3) {
                  const o3 = Object.values(e3[i3]);
                  t2.renderCachePool.push(...o3);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i2 = this.proxyCoords, o2 = this._tilesDirty;
            for (let r4 = i2.length - 1; r4 >= 0; r4--) {
              const n2 = i2[r4];
              if (t2.getTileByID(n2.key), void 0 !== t2.proxyCachedFBO[n2.key]) {
                const i3 = e2[n2.key], r5 = this.proxyToSource[n2.key];
                let s2 = 0;
                for (const e3 in r5) {
                  const t3 = r5[e3], n3 = i3[e3];
                  if (!n3 || n3.length !== t3.length || t3.some((t4, i4) => t4 !== n3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                    s2 = -1;
                    break;
                  }
                  ++s2;
                }
                for (const e3 in t2.proxyCachedFBO[n2.key]) t2.renderCache[t2.proxyCachedFBO[n2.key][e3]].dirty = s2 < 0 || s2 !== Object.values(i3).length;
              }
            }
            const r3 = [...this._drapedRenderBatches];
            r3.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
            for (const e3 of r3) for (const o3 of i2) {
              if (t2.proxyCachedFBO[o3.key]) continue;
              let i3 = t2.renderCachePool.pop();
              void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
            this._tilesDirty = {};
          }
          _setupStencil(e2, t2, i2, o2) {
            if (!o2 || !this._sourceTilesOverlap[o2.id]) return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r3 = this.painter.context, n2 = r3.gl;
            if (t2.length <= 1) return void (this._overlapStencilType = false);
            let s2;
            if (i2.isTileClipped()) s2 = t2.length, this._overlapStencilMode.test = { func: n2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ)) return void (this._overlapStencilType = false);
              s2 = 1, this._overlapStencilMode.test = { func: n2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + s2 > 255 && (r3.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(t2) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.StencilMode.disabled;
          }
          _renderTileClippingMasks(t2, i2) {
            const o2 = this.painter, r3 = this.painter.context, n2 = r3.gl;
            o2._tileClippingMaskIDs = {}, r3.setColorMode(e.ColorMode.disabled), r3.setDepthMode(e.DepthMode.disabled);
            const s2 = o2.useProgram("clippingMask");
            for (const a2 of t2) {
              const t3 = o2._tileClippingMaskIDs[a2.key] = --i2;
              s2.draw(r3, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, t3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(a2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
            }
          }
          pointCoordinate(t2) {
            const i2 = this.painter.transform;
            if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height) return null;
            const o2 = [t2.x, t2.y, 1, 1];
            e.transformMat4$1(o2, o2, i2.pixelMatrixInverse), e.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
            const r3 = i2._camera.position, n2 = e.mercatorZfromAltitude(1, i2.center.lat), s2 = [r3[0], r3[1], r3[2] / n2, 0], a2 = e.subtract([], o2.slice(0, 3), s2);
            e.normalize(a2, a2);
            const l2 = this.raycast(s2, a2, this._exaggeration);
            return null !== l2 && l2 ? (e.scaleAndAdd(s2, s2, a2, l2), s2[3] = s2[2], s2[2] *= n2, s2) : null;
          }
          drawDepth() {
            const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r3 = Math.ceil(t2.width), n2 = Math.ceil(t2.height);
            if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === n2 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
              const t3 = i2.gl, o3 = i2.createFramebuffer(r3, n2, true);
              i2.activeTexture.set(t3.TEXTURE0);
              const s2 = new e.Texture(i2, { width: r3, height: n2, data: null }, t3.RGBA);
              s2.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(s2.texture);
              const a2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r3, n2);
              o3.depthAttachment.set(a2), this._depthFBO = o3, this._depthTexture = s2;
            }
            i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r3, n2]), function(t3, i3, o3, r4) {
              if ("globe" === t3.transform.projection.name) return;
              const n3 = t3.context, s2 = n3.gl;
              n3.clear({ depth: 1 });
              const a2 = t3.useProgram("terrainDepth"), l2 = new e.DepthMode(s2.LESS, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
              for (const t4 of r4) {
                const r5 = o3.getTile(t4), c2 = yi(t4.projMatrix, 0);
                i3.setupElevationDraw(r5, a2), a2.draw(n3, s2.TRIANGLES, l2, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
              }
            }(t2, this, o2, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(e2, t2, i2) {
            if (e2.getSource() instanceof Ae) return this._setupProxiedCoordsForImageSource(e2, t2, i2);
            this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
            const o2 = this.proxiedCoords[e2.id] = [], r3 = this.proxyCoords;
            for (let t3 = 0; t3 < r3.length; t3++) {
              const n3 = r3[t3], s2 = this._findTileCoveringTileID(n3, e2);
              if (s2) {
                const t4 = this._createProxiedId(n3, s2, i2[n3.key] && i2[n3.key][e2.id]);
                o2.push(t4), this.proxyToSource[n3.key][e2.id] = [t4];
              }
            }
            let n2 = false;
            for (let r4 = 0; r4 < t2.length; r4++) {
              const s2 = e2.getTile(t2[r4]);
              if (!s2 || !s2.hasData()) continue;
              const a2 = this._findTileCoveringTileID(s2.tileID, this.proxySourceCache);
              if (a2 && a2.tileID.canonical.z !== s2.tileID.canonical.z) {
                const t3 = this.proxyToSource[a2.tileID.key][e2.id], r5 = this._createProxiedId(a2.tileID, s2, i2[a2.tileID.key] && i2[a2.tileID.key][e2.id]);
                t3 ? t3.splice(t3.length - 1, 0, r5) : this.proxyToSource[a2.tileID.key][e2.id] = [r5], o2.push(r5), n2 = true;
              }
            }
            this._sourceTilesOverlap[e2.id] = n2;
          }
          _setupProxiedCoordsForImageSource(t2, i2, o2) {
            if (!t2.getSource().loaded()) return;
            const r3 = this.proxiedCoords[t2.id] = [], n2 = this.proxyCoords, s2 = t2.getSource(), a2 = new e.pointGeometry(s2.tileID.x, s2.tileID.y)._div(1 << s2.tileID.z), l2 = s2.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - a2.x), e2.min.y = Math.min(e2.min.y, t3.y - a2.y), e2.max.x = Math.max(e2.max.x, t3.x - a2.x), e2.max.y = Math.max(e2.max.y, t3.y - a2.y), e2), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t3, i3) => {
              const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r4 = t3.canonical.y / (1 << t3.canonical.z), n3 = e.EXTENT / (1 << t3.canonical.z), s3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
              return o3 + n3 < s3 + l2.min.x || o3 > s3 + l2.max.x || r4 + n3 < a3 + l2.min.y || r4 > a3 + l2.max.y;
            };
            for (let e2 = 0; e2 < n2.length; e2++) {
              const s3 = n2[e2];
              for (let e3 = 0; e3 < i2.length; e3++) {
                const n3 = t2.getTile(i2[e3]);
                if (!n3 || !n3.hasData()) continue;
                if (c2(s3, n3.tileID)) continue;
                const a3 = this._createProxiedId(s3, n3, o2[s3.key] && o2[s3.key][t2.id]), l3 = this.proxyToSource[s3.key][t2.id];
                l3 ? l3.push(a3) : this.proxyToSource[s3.key][t2.id] = [a3], r3.push(a3);
              }
            }
          }
          _createProxiedId(t2, i2, o2) {
            let r3 = this.orthoMatrix;
            if (o2) {
              const e2 = o2.find((e3) => e3.key === i2.tileID.key);
              if (e2) return e2;
            }
            if (i2.tileID.key !== t2.key) {
              const o3 = t2.canonical.z - i2.tileID.canonical.z;
              let n2, s2, a2;
              r3 = e.create();
              const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
              o3 > 0 ? (n2 = e.EXTENT >> o3, s2 = n2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = n2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (n2 = e.EXTENT << -o3, s2 = e.EXTENT * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.EXTENT * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ortho(r3, 0, n2, 0, n2, 0, 1), e.translate(r3, r3, [s2, a2, 0]);
            }
            return new Ai(i2.tileID, t2.key, r3);
          }
          _findTileCoveringTileID(t2, i2) {
            let o2 = i2.getTile(t2);
            if (o2 && o2.hasData()) return o2;
            const r3 = this._findCoveringTileCache[i2.id], n2 = r3[t2.key];
            if (o2 = n2 ? i2.getTileByID(n2) : null, o2 && o2.hasData() || null === n2) return o2;
            let s2 = o2 ? o2.tileID : t2, a2 = s2.overscaledZ;
            const l2 = i2.getSource().minzoom, c2 = [];
            if (!n2) {
              const r4 = i2.getSource().maxzoom;
              if (t2.canonical.z >= r4) {
                const o3 = t2.canonical.z - r4;
                i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), s2 = new e.OverscaledTileID(a2, t2.wrap, r4, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = r4, s2 = new e.OverscaledTileID(a2, t2.wrap, r4, t2.canonical.x >> o3, t2.canonical.y >> o3));
              }
              s2.key !== t2.key && (c2.push(s2.key), o2 = i2.getTile(s2));
            }
            const h2 = (e2) => {
              c2.forEach((t3) => {
                r3[t3] = e2;
              }), c2.length = 0;
            };
            for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
              o2 && h2(o2.tileID.key);
              const e2 = s2.calculateScaledKey(a2);
              if (o2 = i2.getTileByID(e2), o2 && o2.hasData()) break;
              const t3 = r3[e2];
              if (null === t3) break;
              void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
            }
            return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
          }
          findDEMTileFor(e2) {
            return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e2, t2) {
            let i2 = this._tilesDirty[e2];
            i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
          }
          getWirefameBuffer() {
            if (!this.wireframeSegments) {
              const t2 = function(t3) {
                let i2 = 0;
                const o2 = new e.StructArrayLayout2ui4(), r3 = 131;
                for (let e2 = 1; e2 < 129; e2++) {
                  for (let t4 = 1; t4 < 129; t4++) i2 = e2 * r3 + t4, o2.emplaceBack(i2, i2 + 1), o2.emplaceBack(i2, i2 + r3), o2.emplaceBack(i2 + 1, i2 + r3), 128 === e2 && o2.emplaceBack(i2 + r3, i2 + r3 + 1);
                  o2.emplaceBack(i2 + 1, i2 + 1 + r3);
                }
                return o2;
              }();
              this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t2), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t2.length);
            }
            return [this.wireframeIndexBuffer, this.wireframeSegments];
          }
        }
        class Pi {
          static cacheKey(e2, t2, i2, o2) {
            let r3 = `${t2}${o2 ? o2.cacheKey : ""}`;
            for (const t3 of i2) e2.usedDefines.includes(t3) && (r3 += `/${t3}`);
            return r3;
          }
          constructor(t2, i2, o2, r3, n2, s2) {
            const a2 = t2.gl;
            this.program = a2.createProgram();
            const l2 = function(e2) {
              const t3 = [];
              for (let i3 = 0; i3 < e2.length; i3++) {
                if (null === e2[i3]) continue;
                const o3 = e2[i3].split(" ");
                t3.push(o3.pop());
              }
              return t3;
            }(o2.staticAttributes), c2 = r3 ? r3.getBinderAttributes() : [], h2 = l2.concat(c2);
            let u2 = r3 ? r3.defines() : [];
            u2 = u2.concat(s2.map((e2) => `#define ${e2}`));
            const _2 = t2.isWebGL2 ? "#version 300 es\n" : "", d2 = _2 + u2.concat(t2.extStandardDerivatives && 0 === _2.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o2.fragmentSource).join("\n"), p2 = _2 + u2.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o2.vertexSource).join("\n"), m2 = a2.createShader(a2.FRAGMENT_SHADER);
            if (a2.isContextLost()) return void (this.failedToCreate = true);
            a2.shaderSource(m2, d2), a2.compileShader(m2), a2.attachShader(this.program, m2);
            const f2 = a2.createShader(a2.VERTEX_SHADER);
            if (a2.isContextLost()) this.failedToCreate = true;
            else {
              a2.shaderSource(f2, p2), a2.compileShader(f2), a2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = h2.length;
              for (let e2 = 0; e2 < this.numAttributes; e2++) h2[e2] && (a2.bindAttribLocation(this.program, e2, h2[e2]), this.attributes[h2[e2]] = e2);
              a2.linkProgram(this.program), a2.deleteShader(f2), a2.deleteShader(m2), this.fixedUniforms = n2(t2), this.binderUniforms = r3 ? r3.getUniforms(t2) : [], s2.includes("TERRAIN") && (this.terrainUniforms = ((t3) => ({ u_dem: new e.Uniform1i(t3), u_dem_prev: new e.Uniform1i(t3), u_dem_unpack: new e.Uniform4f(t3), u_dem_tl: new e.Uniform2f(t3), u_dem_scale: new e.Uniform1f(t3), u_dem_tl_prev: new e.Uniform2f(t3), u_dem_scale_prev: new e.Uniform1f(t3), u_dem_size: new e.Uniform1f(t3), u_dem_lerp: new e.Uniform1f(t3), u_exaggeration: new e.Uniform1f(t3), u_depth: new e.Uniform1i(t3), u_depth_size_inv: new e.Uniform2f(t3), u_meter_to_dem: new e.Uniform1f(t3), u_label_plane_matrix_inv: new e.UniformMatrix4f(t3) }))(t2)), s2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.Uniform3f(t3), u_tile_tr_up: new e.Uniform3f(t3), u_tile_br_up: new e.Uniform3f(t3), u_tile_bl_up: new e.Uniform3f(t3), u_tile_up_scale: new e.Uniform1f(t3) }))(t2)), s2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.UniformMatrix4f(t3), u_fog_range: new e.Uniform2f(t3), u_fog_color: new e.Uniform4f(t3), u_fog_horizon_blend: new e.Uniform1f(t3), u_fog_temporal_offset: new e.Uniform1f(t3), u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_globe_pos: new e.Uniform3f(t3), u_globe_radius: new e.Uniform1f(t3), u_globe_transition: new e.Uniform1f(t3), u_is_globe: new e.Uniform1i(t3), u_viewport: new e.Uniform2f(t3) }))(t2));
            }
          }
          setTerrainUniformValues(e2, t2) {
            if (!this.terrainUniforms) return;
            const i2 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setGlobeUniformValues(e2, t2) {
            if (!this.globeUniforms) return;
            const i2 = this.globeUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setFogUniformValues(e2, t2) {
            if (!this.fogUniforms) return;
            const i2 = this.fogUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          draw(e2, t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2) {
            const m2 = e2.gl;
            if (this.failedToCreate) return;
            e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r3), e2.setCullFace(n2);
            for (const e3 of Object.keys(this.fixedUniforms)) this.fixedUniforms[e3].set(this.program, e3, s2[e3]);
            d2 && d2.setUniforms(this.program, e2, this.binderUniforms, u2, { zoom: _2 });
            const f2 = { [m2.LINES]: 2, [m2.TRIANGLES]: 3, [m2.LINE_STRIP]: 1 }[t2];
            for (const i3 of h2.get()) {
              const o3 = i3.vaos || (i3.vaos = {});
              (o3[a2] || (o3[a2] = new pi())).bind(e2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p2 || []), m2.drawElements(t2, i3.primitiveLength * f2, m2.UNSIGNED_SHORT, i3.primitiveOffset * f2 * 2);
            }
          }
        }
        function Ri(e2, t2) {
          const i2 = Math.pow(2, t2.tileID.overscaledZ), o2 = t2.tileSize * Math.pow(2, e2.transform.tileZoom) / i2, r3 = o2 * (t2.tileID.canonical.x + t2.tileID.wrap * i2), n2 = o2 * t2.tileID.canonical.y;
          return { u_image: 0, u_texsize: t2.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / P(t2, 1, e2.transform.tileZoom), u_pixel_coord_upper: [r3 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r3, 65535 & n2] };
        }
        const Oi = e.create(), Bi = (t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2) => {
          const _2 = i2.style.light, d2 = _2.properties.get("position"), p2 = [d2.x, d2.y, d2.z], m2 = e.create$1();
          "viewport" === _2.properties.get("anchor") && (e.fromRotation(m2, -i2.transform.angle), e.transformMat3(p2, p2, m2));
          const f2 = _2.properties.get("color"), g2 = i2.transform, v2 = { u_matrix: t2, u_lightpos: p2, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f2.r, f2.g, f2.b], u_vertical_gradient: +o2, u_opacity: r3, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Oi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n2, u_edge_radius: s2 };
          return "globe" === g2.projection.name && (v2.u_tile_id = [a2.canonical.x, a2.canonical.y, 1 << a2.canonical.z], v2.u_zoom_transition = c2, v2.u_inv_rot_matrix = u2, v2.u_merc_center = h2, v2.u_up_dir = g2.projection.upVector(new e.CanonicalTileID(0, 0, 0), h2[0] * e.EXTENT, h2[1] * e.EXTENT), v2.u_height_lift = l2), v2;
        }, ki = (t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2) => {
          const d2 = Bi(t2, i2, o2, r3, n2, s2, a2, c2, h2, u2, _2), p2 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l2.tileSize / 8 };
          return e.extend(d2, Ri(i2, l2), p2);
        }, Fi = (e2) => ({ u_matrix: e2 }), Ui = (t2, i2, o2) => e.extend(Fi(t2), Ri(i2, o2)), Ni = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), Gi = (t2, i2, o2, r3) => e.extend(Ui(t2, i2, o2), { u_world: r3 }), ji = e.create(), Zi = (t2, i2, o2, r3, n2, s2) => {
          const a2 = t2.transform, l2 = "globe" === a2.projection.name;
          let c2;
          if ("map" === s2.paint.get("circle-pitch-alignment")) if (l2) {
            const t3 = e.globePixelsToTileUnits(a2.zoom, i2.canonical) * a2._pixelsPerMercatorPixel;
            c2 = Float32Array.from([t3, 0, 0, t3]);
          } else c2 = a2.calculatePixelsToTileUnitsMatrix(o2);
          else c2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
          const h2 = { u_camera_to_center_distance: a2.cameraToCenterDistance, u_matrix: t2.translatePosMatrix(i2.projMatrix, o2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c2, u_inv_rot_matrix: ji, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (l2) {
            h2.u_inv_rot_matrix = r3, h2.u_merc_center = n2, h2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], h2.u_zoom_transition = e.globeToMercatorTransition(a2.zoom);
            const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
            h2.u_up_dir = a2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
          }
          return h2;
        }, Vi = (e2) => {
          const t2 = [];
          return "map" === e2.paint.get("circle-pitch-alignment") && t2.push("PITCH_WITH_MAP"), "map" === e2.paint.get("circle-pitch-scale") && t2.push("SCALE_WITH_MAP"), t2;
        }, Wi = (t2, i2, o2, r3) => {
          const n2 = e.EXTENT / o2.tileSize;
          return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r3), u_extrude_scale: [i2.pixelsToGLUnits[0] / n2, i2.pixelsToGLUnits[1] / n2] };
        }, Xi = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), qi = e.create(), $i = (t2, i2, o2, r3, n2, s2, a2) => {
          const l2 = t2.transform, c2 = "globe" === l2.projection.name, h2 = c2 ? e.globePixelsToTileUnits(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : P(o2, 1, s2), u2 = { u_matrix: i2.projMatrix, u_extrude_scale: h2, u_intensity: a2, u_inv_rot_matrix: qi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c2) {
            u2.u_inv_rot_matrix = r3, u2.u_merc_center = n2, u2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u2.u_zoom_transition = e.globeToMercatorTransition(l2.zoom);
            const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
            u2.u_up_dir = l2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
          }
          return u2;
        }, Hi = (e2, t2, i2, o2, r3, n2, s2) => {
          const a2 = e2.transform, l2 = a2.calculatePixelsToTileUnitsMatrix(t2);
          return { u_matrix: Ji(e2, t2, i2, o2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: n2, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r3, u_texsize: Qi(i2) ? t2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ki(t2, e2.transform), u_alpha_discard_threshold: 0, u_trim_offset: s2 };
        }, Yi = (e2, t2, i2, o2, r3) => {
          const n2 = e2.transform;
          return { u_matrix: Ji(e2, t2, i2, o2), u_texsize: t2.imageAtlasTexture.size, u_pixels_to_tile_units: n2.calculatePixelsToTileUnitsMatrix(t2), u_device_pixel_ratio: r3, u_image: 0, u_tile_units_to_pixels: Ki(t2, n2), u_units_to_pixels: [1 / n2.pixelsToGLUnits[0], 1 / n2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };
        function Ki(e2, t2) {
          return 1 / P(e2, 1, t2.tileZoom);
        }
        function Ji(e2, t2, i2, o2) {
          return e2.translatePosMatrix(o2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        function Qi(e2) {
          const t2 = e2.paint.get("line-dasharray").value;
          return t2.value || "constant" !== t2.kind;
        }
        const eo = (e2, t2, i2, o2, r3, n2) => {
          return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_fade_t: o2.mix, u_opacity: o2.opacity * r3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get("raster-brightness-min"), u_brightness_high: r3.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = r3.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (s2 = r3.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: to(r3.paint.get("raster-hue-rotate")), u_perspective_transform: n2 };
          var s2, a2;
        };
        function to(e2) {
          e2 *= Math.PI / 180;
          const t2 = Math.sin(e2), i2 = Math.cos(e2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
        }
        const io = e.create(), oo = (t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2) => {
          const g2 = n2.transform, v2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: g2.cameraToCenterDistance, u_rotate_symbol: +o2, u_aspect_ratio: g2.width / g2.height, u_fade_change: n2.options.fadeDuration ? n2.symbolFadeChange : 1, u_matrix: s2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +c2, u_pitch_with_map: +r3, u_texsize: h2, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: io, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: io, u_up_vector: [0, -1, 0] };
          return "globe" === f2.name && (v2.u_tile_id = [u2.canonical.x, u2.canonical.y, 1 << u2.canonical.z], v2.u_zoom_transition = _2, v2.u_inv_rot_matrix = p2, v2.u_merc_center = d2, v2.u_camera_forward = g2._camera.forward(), v2.u_ecef_origin = e.globeECEFOrigin(g2.globeMatrix, u2.toUnwrapped()), v2.u_tile_matrix = Float32Array.from(g2.globeMatrix), v2.u_up_vector = m2), v2;
        }, ro = (t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2, g2) => e.extend(oo(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, _2, d2, p2, m2, f2, g2), { u_gamma_scale: r3 ? n2.transform.cameraToCenterDistance * Math.cos(n2.terrain ? 0 : n2.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u2 }), no = (t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2, d2, p2, m2, f2) => e.extend(ro(t2, i2, o2, r3, n2, s2, a2, l2, true, c2, true, u2, _2, d2, p2, m2, f2), { u_texsize_icon: h2, u_texture_icon: 1 }), so = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), ao = (t2, i2, o2, r3, n2) => e.extend(function(e2, t3, i3) {
          const o3 = t3.imageManager.getPattern(e2.toString()), { width: r4, height: n3 } = t3.imageManager.getPixelSize(), s2 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / s2, l2 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * s2), c2 = a2 * i3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [r4, n3], u_pattern_size: o3.displaySize, u_tile_units_to_pixels: 1 / P(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [l2 >> 16, c2 >> 16], u_pixel_coord_lower: [65535 & l2, 65535 & c2] };
        }(r3, o2, n2), { u_matrix: t2, u_opacity: i2 }), lo = { fillExtrusion: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_height_factor: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2) }), fill: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), fillPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), fillOutline: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), circle: (t2) => ({ u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), collisionBox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.Uniform2f(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_inv_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_viewport_size: new e.Uniform2f(t2) }), debug: (t2) => ({ u_color: new e.UniformColor(t2), u_matrix: new e.UniformMatrix4f(t2), u_overlay: new e.Uniform1i(t2), u_overlay_scale: new e.Uniform1f(t2) }), clippingMask: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.Uniform1f(t2), u_intensity: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), heatmapTexture: (t2) => ({ u_image: new e.Uniform1i(t2), u_color_ramp: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2) }), hillshade: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_latrange: new e.Uniform2f(t2), u_light: new e.Uniform2f(t2), u_shadow: new e.UniformColor(t2), u_highlight: new e.UniformColor(t2), u_accent: new e.UniformColor(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_dimension: new e.Uniform2f(t2), u_zoom: new e.Uniform1f(t2), u_unpack: new e.Uniform4f(t2) }), line: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_units_to_pixels: new e.Uniform2f(t2), u_dash_image: new e.Uniform1i(t2), u_gradient_image: new e.Uniform1i(t2), u_image_height: new e.Uniform1f(t2), u_texsize: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2), u_trim_offset: new e.Uniform2f(t2) }), linePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_texsize: new e.Uniform2f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_units_to_pixels: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2) }), raster: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_tl_parent: new e.Uniform2f(t2), u_scale_parent: new e.Uniform1f(t2), u_fade_t: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_image0: new e.Uniform1i(t2), u_image1: new e.Uniform1i(t2), u_brightness_low: new e.Uniform1f(t2), u_brightness_high: new e.Uniform1f(t2), u_saturation_factor: new e.Uniform1f(t2), u_contrast_factor: new e.Uniform1f(t2), u_spin_weights: new e.Uniform3f(t2), u_perspective_transform: new e.Uniform2f(t2) }), symbolIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_texture: new e.Uniform1i(t2) }), symbolSDF: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_is_halo: new e.Uniform1i(t2) }), symbolTextAndIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texsize_icon: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_texture_icon: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_is_halo: new e.Uniform1i(t2) }), background: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_color: new e.UniformColor(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_pattern_tl: new e.Uniform2f(t2), u_pattern_br: new e.Uniform2f(t2), u_texsize: new e.Uniform2f(t2), u_pattern_size: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), terrainRaster: xi, terrainDepth: xi, skybox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_sun_direction: new e.Uniform3f(t2), u_cubemap: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_color_ramp: new e.Uniform1i(t2), u_center_direction: new e.Uniform3f(t2), u_radius: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.UniformMatrix3f(t2), u_sun_direction: new e.Uniform3f(t2), u_sun_intensity: new e.Uniform1f(t2), u_color_tint_r: new e.Uniform4f(t2), u_color_tint_m: new e.Uniform4f(t2), u_luminance: new e.Uniform1f(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.UniformMatrix4f(t2), u_globe_matrix: new e.UniformMatrix4f(t2), u_normalize_matrix: new e.UniformMatrix4f(t2), u_merc_matrix: new e.UniformMatrix4f(t2), u_zoom_transition: new e.Uniform1f(t2), u_merc_center: new e.Uniform2f(t2), u_image0: new e.Uniform1i(t2), u_grid_matrix: new e.UniformMatrix3f(t2), u_skirt_height: new e.Uniform1f(t2), u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_globe_pos: new e.Uniform3f(t2), u_globe_radius: new e.Uniform1f(t2), u_viewport: new e.Uniform2f(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_horizon: new e.Uniform1f(t2), u_transition: new e.Uniform1f(t2), u_fadeout_range: new e.Uniform1f(t2), u_color: new e.Uniform4f(t2), u_high_color: new e.Uniform4f(t2), u_space_color: new e.Uniform4f(t2), u_star_intensity: new e.Uniform1f(t2), u_star_density: new e.Uniform1f(t2), u_star_size: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2), u_horizon_angle: new e.Uniform1f(t2), u_rotation_matrix: new e.UniformMatrix4f(t2) }) };
        let co;
        function ho(t2, i2, o2, r3, n2, s2, a2) {
          const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, u2 = t2.useProgram("collisionBox"), _2 = [];
          let d2 = 0, p2 = 0;
          for (let m3 = 0; m3 < r3.length; m3++) {
            const f3 = r3[m3], g3 = i2.getTile(f3), v3 = g3.getBucket(o2);
            if (!v3) continue;
            const x3 = yt(f3, v3, h2);
            let y3 = x3;
            0 === n2[0] && 0 === n2[1] || (y3 = t2.translatePosMatrix(x3, g3, n2, s2));
            const b2 = a2 ? v3.textCollisionBox : v3.iconCollisionBox, w2 = v3.collisionCircleArray;
            if (w2.length > 0) {
              const t3 = e.create(), i3 = y3;
              e.mul(t3, v3.placementInvProjMatrix, h2.glCoordMatrix), e.mul(t3, t3, v3.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p2, transform: i3, invTransform: t3, projection: v3.getProjection() }), d2 += w2.length / 4, p2 = d2;
            }
            b2 && (t2.terrain && t2.terrain.setupElevationDraw(g3, u2), u2.draw(l2, c2.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi(y3, h2, g3, v3.getProjection()), o2.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, null, h2.zoom, null, [b2.collisionVertexBuffer, b2.collisionVertexBufferExt]));
          }
          if (!a2 || !_2.length) return;
          const m2 = t2.useProgram("collisionCircle"), f2 = new e.StructArrayLayout2f1f2i16();
          f2.resize(4 * d2), f2._trim();
          let g2 = 0;
          for (const e2 of _2) for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r4 = e2.circleArray[i3 + 1], n3 = e2.circleArray[i3 + 2], s3 = e2.circleArray[i3 + 3];
            f2.emplace(g2++, o3, r4, n3, s3, 0), f2.emplace(g2++, o3, r4, n3, s3, 1), f2.emplace(g2++, o3, r4, n3, s3, 2), f2.emplace(g2++, o3, r4, n3, s3, 3);
          }
          (!co || co.length < 2 * d2) && (co = function(t3) {
            const i3 = 2 * t3, o3 = new e.StructArrayLayout3ui6();
            o3.resize(i3), o3._trim();
            for (let e2 = 0; e2 < i3; e2++) {
              const t4 = 6 * e2;
              o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
            }
            return o3;
          }(d2));
          const v2 = l2.createIndexBuffer(co, true), x2 = l2.createVertexBuffer(f2, e.collisionCircleLayout.members, true);
          for (const i3 of _2) {
            const r4 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h2).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
            m2.draw(l2, c2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, r4, o2.id, x2, v2, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h2.zoom);
          }
          var y2;
          x2.destroy(), v2.destroy();
        }
        const uo = e.create();
        function _o({ width: t2, height: i2, anchor: o2, textOffset: r3, textScale: n2 }, s2) {
          const { horizontalAlign: a2, verticalAlign: l2 } = e.getAnchorAlignment(o2), c2 = -(a2 - 0.5) * t2, h2 = -(l2 - 0.5) * i2, u2 = e.evaluateVariableOffset(o2, r3);
          return new e.pointGeometry((c2 / n2 + u2[0]) * s2, (h2 / n2 + u2[1]) * s2);
        }
        function po(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2) {
          const _2 = t2.text.placedSymbolArray, d2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {}, f2 = t2.getProjection(), g2 = bt(l2, f2, s2), v2 = s2.elevation, x2 = f2.upVectorScale(l2.canonical, s2.center.lat, s2.worldSize).metersToTile;
          d2.clear();
          for (let p3 = 0; p3 < _2.length; p3++) {
            const y2 = _2.get(p3), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y2, E2 = t2.allowVerticalPlacement && !y2.placedOrientation, C2 = y2.hidden || !y2.crossTileID || E2 ? null : r3[y2.crossTileID];
            if (C2) {
              let r4 = 0, _3 = 0, p4 = 0;
              if (v2) {
                const e2 = v2 ? v2.getAtTileOffset(l2, b2, w2) : 0, [t3, i3, o3] = f2.upVector(l2.canonical, b2, w2);
                r4 = e2 * t3 * x2, _3 = e2 * i3 * x2, p4 = e2 * o3 * x2;
              }
              let [E3, M2, I2, S2] = nt(y2.projectedAnchorX + r4, y2.projectedAnchorY + _3, y2.projectedAnchorZ + p4, o2 ? g2 : a2);
              const D2 = st(s2.getCameraToCenterDistance(f2), S2);
              let L2 = n2.evaluateSizeForFeature(t2.textSizeData, h2, y2) * D2 / e.ONE_EM;
              o2 && (L2 *= t2.tilePixelRatio / c2);
              const A2 = _o(C2, L2);
              o2 ? ({ x: E3, y: M2, z: I2 } = f2.projectTilePoint(b2 + A2.x, w2 + A2.y, l2.canonical), [E3, M2, I2] = nt(E3 + r4, M2 + _3, I2 + p4, a2)) : (i2 && A2._rotate(-s2.angle), E3 += A2.x, M2 += A2.y, I2 = 0);
              const z2 = t2.allowVerticalPlacement && y2.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let t3 = 0; t3 < T2; t3++) e.addDynamicAttributes(d2, E3, M2, I2, z2);
              u2 && y2.associatedIconIndex >= 0 && (m2[y2.associatedIconIndex] = { x: E3, y: M2, z: I2, angle: z2 });
            } else mt(T2, d2);
          }
          if (u2) {
            p2.clear();
            const i3 = t2.icon.placedSymbolArray;
            for (let t3 = 0; t3 < i3.length; t3++) {
              const o3 = i3.get(t3), { numGlyphs: r4 } = o3, n3 = m2[t3];
              if (o3.hidden || !n3) mt(r4, p2);
              else {
                const { x: t4, y: i4, z: o4, angle: s3 } = n3;
                for (let n4 = 0; n4 < r4; n4++) e.addDynamicAttributes(p2, t4, i4, o4, s3);
              }
            }
            t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
          }
          t2.text.dynamicLayoutVertexBuffer.updateData(d2);
        }
        function mo(e2, t2, i2) {
          return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
        }
        function fo(t2, i2, o2, r3, n2, s2, a2, l2, c2, h2, u2, _2) {
          const d2 = t2.context, p2 = d2.gl, m2 = t2.transform, f2 = "map" === l2, g2 = "map" === c2, v2 = f2 && "point" !== o2.layout.get("symbol-placement"), x2 = f2 && !g2 && !v2, y2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
          let b2 = false;
          const w2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), T2 = [e.mercatorXfromLng(m2.center.lng), e.mercatorYfromLat(m2.center.lat)], E2 = o2.layout.get("text-variable-anchor"), C2 = "globe" === m2.projection.name, M2 = [], I2 = [0, -1, 0];
          let S2 = I2;
          !C2 && !m2.mercatorFromTransition || f2 || (S2 = function(t3) {
            const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e.multiply([], i3, t3.globeMatrix);
            e.invert(o3, o3);
            const r4 = [0, 0, 0], n3 = [0, 1, 0, 0];
            return e.transformMat4$1(n3, n3, o3), r4[0] = n3[0], r4[1] = n3[1], r4[2] = n3[2], e.normalize(r4, r4), r4;
          }(m2));
          for (const l3 of r3) {
            const r4 = i2.getTile(l3), c3 = r4.getBucket(o2);
            if (!c3) continue;
            if ("mercator" === c3.projection.name && C2) continue;
            const u3 = n2 ? c3.text : c3.icon;
            if (!u3 || c3.fullyClipped || !u3.segments.get().length) continue;
            const _3 = u3.programConfigurations.get(o2.id), d3 = n2 || c3.sdfIcons, w3 = n2 ? c3.textSizeData : c3.iconSizeData, D2 = g2 || 0 !== m2.pitch, L2 = e.evaluateSizeForZoom(w3, m2.zoom);
            let A2, z2, P2, R2, O2 = [0, 0], B2 = null;
            if (n2) {
              if (z2 = r4.glyphAtlasTexture, P2 = p2.LINEAR, A2 = r4.glyphAtlasTexture.size, c3.iconsInText) {
                O2 = r4.imageAtlasTexture.size, B2 = r4.imageAtlasTexture;
                const e2 = "composite" === w3.kind || "camera" === w3.kind;
                R2 = D2 || t2.options.rotating || t2.options.zooming || e2 ? p2.LINEAR : p2.NEAREST;
              }
            } else {
              const e2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
              z2 = r4.imageAtlasTexture, P2 = d3 || t2.options.rotating || t2.options.zooming || e2 || D2 ? p2.LINEAR : p2.NEAREST, A2 = r4.imageAtlasTexture.size;
            }
            const k2 = "globe" === c3.projection.name, F2 = k2 ? S2 : I2, U2 = k2 ? e.globeToMercatorTransition(m2.zoom) : 0, N2 = bt(l3, c3.getProjection(), m2), G2 = m2.calculatePixelsToTileUnitsMatrix(r4), j2 = it(N2, r4.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), Z2 = t2.terrain && g2 && v2 ? e.invert(e.create(), j2) : uo, V2 = rt(N2, r4.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), W2 = E2 && c3.hasTextData(), X2 = "none" !== o2.layout.get("icon-text-fit") && W2 && c3.hasIconData();
            if (v2) {
              const e2 = m2.elevation, i3 = e2 ? e2.getAtTileOffsetFunc(l3, m2.center.lat, m2.worldSize, c3.getProjection()) : null, o3 = ot(N2, r4.tileID.canonical, g2, f2, m2, c3.getProjection(), G2);
              lt(c3, N2, t2, n2, o3, V2, g2, h2, i3, l3);
            }
            const q2 = v2 || n2 && E2 || X2, $2 = t2.translatePosMatrix(N2, r4, s2, a2), H2 = q2 ? uo : j2, Y2 = t2.translatePosMatrix(V2, r4, s2, a2, true), K2 = c3.getProjection().createInversionMatrix(m2, l3.canonical), J2 = [];
            t2.terrainRenderModeElevated() && g2 && J2.push("PITCH_WITH_MAP_TERRAIN"), k2 && J2.push("PROJECTION_GLOBE_VIEW"), q2 && J2.push("PROJECTED_POS_ON_VIEWPORT");
            const Q2 = d3 && 0 !== o2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let ee2;
            ee2 = d3 ? c3.iconsInText ? no(w3.kind, L2, x2, g2, t2, $2, H2, Y2, A2, O2, l3, U2, T2, K2, F2, c3.getProjection()) : ro(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, true, l3, U2, T2, K2, F2, c3.getProjection()) : oo(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, l3, U2, T2, K2, F2, c3.getProjection());
            const te2 = { program: t2.useProgram(mo(d3, n2, c3), _3, J2), buffers: u3, uniformValues: ee2, atlasTexture: z2, atlasTextureIcon: B2, atlasInterpolation: P2, atlasInterpolationIcon: R2, isSDF: d3, hasHalo: Q2, tile: r4, labelPlaneMatrixInv: Z2 };
            if (y2 && c3.canOverlap) {
              b2 = true;
              const t3 = u3.segments.get();
              for (const i3 of t3) M2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: te2 });
            } else M2.push({ segments: u3.segments, sortKey: 0, state: te2 });
          }
          b2 && M2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          for (const e2 of M2) {
            const i3 = e2.state;
            if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: !C2, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), d2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (d2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
              const r4 = i3.uniformValues;
              i3.hasHalo && (r4.u_is_halo = 1, go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, r4)), r4.u_is_halo = 0;
            }
            go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, i3.uniformValues);
          }
        }
        function go(t2, i2, o2, r3, n2, s2, a2, l2, c2) {
          const h2 = r3.context, u2 = [t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer, t2.globeExtVertexBuffer];
          n2.draw(h2, h2.gl.TRIANGLES, s2, a2, l2, e.CullFaceMode.disabled, c2, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r3.transform.zoom, t2.programConfigurations.get(o2.id), u2);
        }
        function vo(t2, i2, o2, r3, n2, s2, a2) {
          const l2 = t2.context.gl, c2 = o2.paint.get("fill-pattern"), h2 = c2 && c2.constantOr(1);
          let u2, _2, d2, p2, m2;
          a2 ? (_2 = h2 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = l2.LINES) : (_2 = h2 ? "fillPattern" : "fill", u2 = l2.TRIANGLES);
          for (const f2 of r3) {
            const r4 = i2.getTile(f2);
            if (h2 && !r4.patternsLoaded()) continue;
            const g2 = r4.getBucket(o2);
            if (!g2) continue;
            t2.prepareDrawTile();
            const v2 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram(_2, v2);
            h2 && (t2.context.activeTexture.set(l2.TEXTURE0), r4.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePaintBuffers());
            const y2 = c2.constantOr(null);
            if (y2 && r4.imageAtlas) {
              const e2 = r4.imageAtlas.patternPositions[y2.toString()];
              e2 && v2.setConstantPatternPositions(e2);
            }
            const b2 = t2.translatePosMatrix(f2.projMatrix, r4, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
            if (a2) {
              p2 = g2.indexBuffer2, m2 = g2.segments2;
              const e2 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
              d2 = "fillOutlinePattern" === _2 && h2 ? Gi(b2, t2, r4, e2) : Ni(b2, e2);
            } else p2 = g2.indexBuffer, m2 = g2.segments, d2 = h2 ? Ui(b2, t2, r4) : Fi(b2);
            t2.prepareDrawProgram(t2.context, x2, f2.toUnwrapped()), x2.draw(t2.context, u2, n2, t2.stencilModeForClipping(f2), s2, e.CullFaceMode.disabled, d2, o2.id, g2.layoutVertexBuffer, p2, m2, o2.paint, t2.transform.zoom, v2);
          }
        }
        function xo(t2, i2, o2, r3, n2, s2, a2) {
          const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, u2 = o2.paint.get("fill-extrusion-pattern"), _2 = u2.constantOr(1), d2 = o2.paint.get("fill-extrusion-opacity"), p2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), o2.paint.get("fill-extrusion-ambient-occlusion-radius")], m2 = o2.layout.get("fill-extrusion-edge-radius"), f2 = "globe" === h2.projection.name ? e.fillExtrusionHeightLift() : 0, g2 = "globe" === h2.projection.name, v2 = g2 ? e.globeToMercatorTransition(h2.zoom) : 0, x2 = [e.mercatorXfromLng(h2.center.lng), e.mercatorYfromLat(h2.center.lat)], y2 = [];
          g2 && y2.push("PROJECTION_GLOBE_VIEW"), p2[0] > 0 && y2.push("FAUX_AO");
          for (const b2 of r3) {
            const r4 = i2.getTile(b2), w2 = r4.getBucket(o2);
            if (!w2 || w2.projection.name !== h2.projection.name) continue;
            const T2 = w2.programConfigurations.get(o2.id), E2 = t2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", T2, y2);
            if (t2.terrain) {
              const e2 = t2.terrain;
              if (t2.style.terrainSetForDrapingOnly()) e2.setupElevationDraw(r4, E2, { useMeterToDem: true });
              else {
                if (!w2.enableTerrain) continue;
                if (e2.setupElevationDraw(r4, E2, { useMeterToDem: true }), yo(l2, i2, b2, w2, o2, e2), !w2.centroidVertexBuffer) {
                  const e3 = E2.attributes.a_centroid_pos;
                  void 0 !== e3 && c2.vertexAttrib2f(e3, 0, 0);
                }
              }
            }
            _2 && (t2.context.activeTexture.set(c2.TEXTURE0), r4.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), T2.updatePaintBuffers());
            const C2 = u2.constantOr(null);
            if (C2 && r4.imageAtlas) {
              const e2 = r4.imageAtlas.patternPositions[C2.toString()];
              e2 && T2.setConstantPatternPositions(e2);
            }
            const M2 = t2.translatePosMatrix(b2.projMatrix, r4, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), I2 = h2.projection.createInversionMatrix(h2, b2.canonical), S2 = o2.paint.get("fill-extrusion-vertical-gradient"), D2 = _2 ? ki(M2, t2, S2, d2, p2, m2, b2, r4, f2, v2, x2, I2) : Bi(M2, t2, S2, d2, p2, m2, b2, f2, v2, x2, I2);
            t2.prepareDrawProgram(l2, E2, b2.toUnwrapped());
            const L2 = [];
            t2.terrain && L2.push(w2.centroidVertexBuffer), g2 && L2.push(w2.layoutVertexExtBuffer), E2.draw(l2, l2.gl.TRIANGLES, n2, s2, a2, e.CullFaceMode.backCCW, D2, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, t2.transform.zoom, T2, L2);
          }
        }
        function yo(t2, i2, o2, r3, n2, s2) {
          const a2 = [(t3) => {
            let i3 = t3.canonical.x - 1, o3 = t3.wrap;
            return i3 < 0 && (i3 = (1 << t3.canonical.z) - 1, o3--), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
          }, (t3) => {
            let i3 = t3.canonical.x + 1, o3 = t3.wrap;
            return i3 === 1 << t3.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
          }, (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (0 === t3.canonical.y ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)], l2 = (e2) => {
            const t3 = i2.getSource().minzoom, o3 = (e3) => {
              const t4 = i2.getTileByID(e3);
              if (t4 && t4.hasData()) return t4.getBucket(n2);
            }, r4 = [0, -1, 1];
            for (const i3 of r4) {
              if (e2.overscaledZ + i3 < t3) continue;
              const r5 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
              if (r5) return r5;
            }
          }, c2 = [0, 0, 0], h2 = (t3, i3) => (c2[0] = Math.min(t3.min.y, i3.min.y), c2[1] = Math.max(t3.max.y, i3.max.y), c2[2] = e.EXTENT - i3.min.x > t3.max.x ? i3.min.x - e.EXTENT : t3.max.x, c2), u2 = (t3, i3) => (c2[0] = Math.min(t3.min.x, i3.min.x), c2[1] = Math.max(t3.max.x, i3.max.x), c2[2] = e.EXTENT - i3.min.y > t3.max.y ? i3.min.y - e.EXTENT : t3.max.y, c2), _2 = [(e2, t3) => h2(e2, t3), (e2, t3) => h2(t3, e2), (e2, t3) => u2(e2, t3), (e2, t3) => u2(t3, e2)], d2 = new e.pointGeometry(0, 0);
          let p2, m2, f2;
          const g2 = (t3, i3, r4, n3, a3) => {
            const l3 = [[n3 ? r4 : t3, n3 ? t3 : r4, 0], [n3 ? r4 : i3, n3 ? i3 : r4, 0]], c3 = a3 < 0 ? e.EXTENT + a3 : a3, h3 = [n3 ? c3 : (t3 + i3) / 2, n3 ? (t3 + i3) / 2 : c3, 0];
            return 0 === r4 && a3 < 0 || 0 !== r4 && a3 > 0 ? s2.getForTilePoints(f2, [h3], true, m2) : l3.push(h3), s2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h3[2]) / s2.exaggeration();
          };
          for (let t3 = 0; t3 < 4; t3++) {
            const i3 = (t3 < 2 ? 1 : 5) - t3, n3 = r3.borders[t3];
            if (0 === n3.length) continue;
            const c3 = f2 = a2[t3](o2), h3 = l2(c3);
            if (!(h3 && h3 instanceof e.FillExtrusionBucket && h3.enableTerrain)) continue;
            if (r3.borderDoneWithNeighborZ[t3] === h3.canonical.z && h3.borderDoneWithNeighborZ[i3] === r3.canonical.z) continue;
            if (m2 = s2.findDEMTileFor(c3), !m2 || !m2.dem) continue;
            if (!p2) {
              const e2 = s2.findDEMTileFor(o2);
              if (!e2 || !e2.dem) return;
              p2 = e2;
            }
            const u3 = h3.borders[i3];
            let v2 = 0;
            const x2 = h3.borderDoneWithNeighborZ[i3] !== r3.canonical.z;
            if (r3.canonical.z === h3.canonical.z) {
              for (let o3 = 0; o3 < n3.length; o3++) {
                const s3 = r3.featuresOnBorder[n3[o3]], a3 = s3.borders[t3];
                let l3;
                for (; v2 < u3.length && (l3 = h3.featuresOnBorder[u3[v2]], !(l3.borders[i3][1] > a3[0] + 3)); ) x2 && h3.encodeCentroid(void 0, l3, false), v2++;
                if (l3 && v2 < u3.length) {
                  const o4 = v2;
                  let n4 = 0;
                  for (; !(l3.borders[i3][0] > a3[1] - 3) && (n4++, ++v2 !== u3.length); ) l3 = h3.featuresOnBorder[u3[v2]];
                  if (l3 = h3.featuresOnBorder[u3[o4]], s3.intersectsCount() > 1 || l3.intersectsCount() > 1 || 1 !== n4) {
                    1 !== n4 && (v2 = o4), r3.encodeCentroid(void 0, s3, false), x2 && h3.encodeCentroid(void 0, l3, false);
                    continue;
                  }
                  const c4 = _2[t3](s3, l3), p3 = t3 % 2 ? e.EXTENT - 1 : 0;
                  d2.x = g2(c4[0], Math.min(e.EXTENT - 1, c4[1]), p3, t3 < 2, c4[2]), d2.y = 0, r3.encodeCentroid(d2, s3, false), x2 && h3.encodeCentroid(d2, l3, false);
                } else r3.encodeCentroid(void 0, s3, false);
              }
              r3.borderDoneWithNeighborZ[t3] = h3.canonical.z, r3.needsCentroidUpdate = true, x2 && (h3.borderDoneWithNeighborZ[i3] = r3.canonical.z, h3.needsCentroidUpdate = true);
            } else {
              for (const e2 of n3) r3.encodeCentroid(void 0, r3.featuresOnBorder[e2], false);
              if (x2) {
                for (const e2 of u3) h3.encodeCentroid(void 0, h3.featuresOnBorder[e2], false);
                h3.borderDoneWithNeighborZ[i3] = r3.canonical.z, h3.needsCentroidUpdate = true;
              }
              r3.borderDoneWithNeighborZ[t3] = h3.canonical.z, r3.needsCentroidUpdate = true;
            }
          }
          (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && 0 !== r3.centroidVertexArray.length) && r3.uploadCentroid(t2);
        }
        const bo = new e.Color(1, 0, 0, 1), wo = new e.Color(0, 1, 0, 1), To = new e.Color(0, 0, 1, 1), Eo = new e.Color(1, 0, 1, 1), Co = new e.Color(0, 1, 1, 1);
        function Mo(t2, i2, o2) {
          const r3 = t2.context, n2 = t2.transform, s2 = r3.gl, a2 = "globe" === n2.projection.name, l2 = a2 ? ["PROJECTION_GLOBE_VIEW"] : null;
          let c2 = o2.projMatrix;
          if (a2 && e.globeToMercatorTransition(n2.zoom) > 0) {
            const t3 = e.transitionTileAABBinECEF(o2.canonical, n2), i3 = e.globeDenormalizeECEF(t3);
            c2 = e.multiply(new Float32Array(16), n2.globeMatrix, i3), e.multiply(c2, n2.projMatrix, c2);
          }
          const h2 = t2.useProgram("debug", null, l2), u2 = i2.getTileByID(o2.key);
          t2.terrain && t2.terrain.setupElevationDraw(u2, h2);
          const _2 = e.DepthMode.disabled, d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = "$debug";
          r3.activeTexture.set(s2.TEXTURE0), t2.emptyTexture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), a2 ? u2._makeGlobeTileDebugBuffers(t2.context, n2) : u2._makeDebugTileBoundsBuffers(t2.context, n2.projection);
          const f2 = u2._tileDebugBuffer || t2.debugBuffer, g2 = u2._tileDebugIndexBuffer || t2.debugIndexBuffer, v2 = u2._tileDebugSegments || t2.debugSegments;
          h2.draw(r3, s2.LINE_STRIP, _2, d2, p2, e.CullFaceMode.disabled, Xi(c2, e.Color.red), m2, f2, g2, v2, null, null, null, [u2._globeTileDebugBorderBuffer]);
          const x2 = u2.latestRawTileData, y2 = Math.floor((x2 && x2.byteLength || 0) / 1024), b2 = i2.getTile(o2).tileSize, w2 = 512 / Math.min(b2, 512) * (o2.overscaledZ / n2.zoom) * 0.5;
          let T2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (T2 += ` => ${o2.overscaledZ}`), T2 += ` ${y2}kb`, function(e2, t3) {
            e2.initDebugOverlayCanvas();
            const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r4 = e2.debugOverlayCanvas.getContext("2d");
            r4.clearRect(0, 0, i3.width, i3.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t3, 5, 5), r4.strokeText(t3, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(t2, T2);
          const E2 = u2._tileDebugTextBuffer || t2.debugBuffer, C2 = u2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, M2 = u2._tileDebugTextSegments || t2.debugSegments;
          h2.draw(r3, s2.TRIANGLES, _2, d2, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi(c2, e.Color.transparent, w2), m2, E2, C2, M2, null, null, null, [u2._globeTileDebugTextBuffer]);
        }
        function Io(e2, t2, i2, o2) {
          Do(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
        }
        function So(e2, t2, i2, o2) {
          Do(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
        }
        function Do(t2, i2, o2, r3, n2, s2) {
          const a2 = t2.context, l2 = a2.gl;
          l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r3 * e.exported.devicePixelRatio, n2 * e.exported.devicePixelRatio), a2.clear({ color: s2 }), l2.disable(l2.SCISSOR_TEST);
        }
        const Lo = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Ao } = Lo;
        function zo(e2, t2, i2, o2) {
          e2.emplaceBack(t2, i2, o2);
        }
        class Po {
          constructor(t2) {
            this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
          }
        }
        function Ro(t2, i2, o2, r3, n2, s2) {
          const a2 = t2.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e2, t3, i3, o3, r4) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r4.r, r4.g, r4.b, r4.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r3), n2, h2, l2, c2);
          a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + s2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
        }
        const Oo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Bo {
          constructor(t2) {
            const i2 = new e.StructArrayLayout5f20();
            i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
            const o2 = new e.StructArrayLayout3ui6();
            o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, Oo.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const ko = { symbol: function(t2, i2, o2, r3, n2) {
          if ("translucent" !== t2.renderPass) return;
          const s2 = e.StencilMode.disabled, a2 = t2.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r4, n3, s3, a3) {
            const l2 = i3.transform, c2 = "map" === n3, h2 = "map" === s3;
            for (const i4 of t3) {
              const t4 = r4.getTile(i4), n4 = t4.getBucket(o3);
              if (!n4 || !n4.text || !n4.text.segments.get().length) continue;
              const s4 = e.evaluateSizeForZoom(n4.textSizeData, l2.zoom), u2 = bt(i4, n4.getProjection(), l2), _2 = l2.calculatePixelsToTileUnitsMatrix(t4), d2 = it(u2, t4.tileID.canonical, h2, c2, l2, n4.getProjection(), _2), p2 = "none" !== o3.layout.get("icon-text-fit") && n4.hasIconData();
              if (s4) {
                const o4 = Math.pow(2, l2.zoom - t4.tileID.overscaledZ);
                po(n4, c2, h2, a3, e.symbolSize, l2, d2, i4, o4, s4, p2);
              }
            }
          }(r3, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && fo(t2, i2, o2, r3, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s2, a2), 0 !== o2.paint.get("text-opacity").constantOr(1) && fo(t2, i2, o2, r3, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s2, a2), i2.map.showCollisionBoxes && (ho(t2, i2, o2, r3, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), ho(t2, i2, o2, r3, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }, circle: function(t2, i2, o2, r3) {
          if ("translucent" !== t2.renderPass) return;
          const n2 = o2.paint.get("circle-opacity"), s2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
          if (0 === n2.constantOr(1) && (0 === s2.constantOr(1) || 0 === a2.constantOr(1))) return;
          const c2 = t2.context, h2 = c2.gl, u2 = t2.transform, _2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = "globe" === u2.projection.name, f2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], g2 = [];
          for (let n3 = 0; n3 < r3.length; n3++) {
            const s3 = r3[n3], a3 = i2.getTile(s3), c3 = a3.getBucket(o2);
            if (!c3 || c3.projection.name !== u2.projection.name) continue;
            const h3 = c3.programConfigurations.get(o2.id), _3 = Vi(o2);
            m2 && _3.push("PROJECTION_GLOBE_VIEW");
            const d3 = t2.useProgram("circle", h3, _3), p3 = c3.layoutVertexBuffer, v3 = c3.globeExtVertexBuffer, x2 = c3.indexBuffer, y2 = u2.projection.createInversionMatrix(u2, s3.canonical), b2 = { programConfiguration: h3, program: d3, layoutVertexBuffer: p3, globeExtVertexBuffer: v3, indexBuffer: x2, uniformValues: Zi(t2, s3, a3, y2, f2, o2), tile: a3 };
            if (l2) {
              const t3 = c3.segments.get();
              for (const i3 of t3) g2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: b2 });
            } else g2.push({ segments: c3.segments, sortKey: 0, state: b2 });
          }
          l2 && g2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          const v2 = { useDepthForOcclusion: !m2 };
          for (const i3 of g2) {
            const { programConfiguration: r4, program: n3, layoutVertexBuffer: s3, globeExtVertexBuffer: a3, indexBuffer: l3, uniformValues: m3, tile: f3 } = i3.state, g3 = i3.segments;
            t2.terrain && t2.terrain.setupElevationDraw(f3, n3, v2), t2.prepareDrawProgram(c2, n3, f3.tileID.toUnwrapped()), n3.draw(c2, h2.TRIANGLES, _2, d2, p2, e.CullFaceMode.disabled, m3, o2.id, s3, l3, g3, o2.paint, u2.zoom, r4, [a3]);
          }
        }, heatmap: function(t2, i2, o2, r3) {
          if (0 !== o2.paint.get("heatmap-opacity")) if ("offscreen" === t2.renderPass) {
            const n2 = t2.context, s2 = n2.gl, a2 = e.StencilMode.disabled, l2 = new e.ColorMode([s2.ONE, s2.ONE], e.Color.transparent, [true, true, true, true]);
            !function(e2, t3, i3, o3) {
              const r4 = e2.gl, n3 = t3.width * o3, s3 = t3.height * o3;
              e2.activeTexture.set(r4.TEXTURE1), e2.viewport.set([0, 0, n3, s3]);
              let a3 = i3.heatmapFbo;
              if (!a3 || a3 && (a3.width !== n3 || a3.height !== s3)) {
                a3 && a3.destroy();
                const t4 = r4.createTexture();
                r4.bindTexture(r4.TEXTURE_2D, t4), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_S, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_T, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MIN_FILTER, r4.LINEAR), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MAG_FILTER, r4.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(n3, s3, false), function(e3, t5, i4, o4, r5, n4) {
                  const s4 = e3.gl;
                  s4.texImage2D(s4.TEXTURE_2D, 0, e3.isWebGL2 && e3.extRenderToTextureHalfFloat ? s4.RGBA16F : s4.RGBA, r5, n4, 0, s4.RGBA, e3.extRenderToTextureHalfFloat ? e3.isWebGL2 ? s4.HALF_FLOAT : e3.extTextureHalfFloat.HALF_FLOAT_OES : s4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e2, 0, t4, a3, n3, s3);
              } else r4.bindTexture(r4.TEXTURE_2D, a3.colorAttachment.get()), e2.bindFramebuffer.set(a3.framebuffer);
            }(n2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), n2.clear({ color: e.Color.transparent });
            const c2 = t2.transform, h2 = "globe" === c2.projection.name, u2 = h2 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h2 ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, d2 = [e.mercatorXfromLng(c2.center.lng), e.mercatorYfromLat(c2.center.lat)];
            for (let p2 = 0; p2 < r3.length; p2++) {
              const m2 = r3[p2];
              if (i2.hasRenderableParent(m2)) continue;
              const f2 = i2.getTile(m2), g2 = f2.getBucket(o2);
              if (!g2 || g2.projection.name !== c2.projection.name) continue;
              const v2 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram("heatmap", v2, u2), { zoom: y2 } = t2.transform;
              t2.terrain && t2.terrain.setupElevationDraw(f2, x2), t2.prepareDrawProgram(n2, x2, m2.toUnwrapped());
              const b2 = c2.projection.createInversionMatrix(c2, m2.canonical);
              x2.draw(n2, s2.TRIANGLES, e.DepthMode.disabled, a2, l2, _2, $i(t2, m2, f2, b2, d2, y2, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t2.transform.zoom, v2, h2 ? [g2.globeExtVertexBuffer] : null);
            }
            n2.viewport.set([0, 0, t2.width, t2.height]);
          } else "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
            const o3 = t3.context, r4 = o3.gl, n2 = i3.heatmapFbo;
            if (!n2) return;
            o3.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, n2.colorAttachment.get()), o3.activeTexture.set(r4.TEXTURE1);
            let s2 = i3.colorRampTexture;
            s2 || (s2 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r4.RGBA)), s2.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), t3.useProgram("heatmapTexture").draw(o3, r4.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
          }(t2, o2));
        }, line: function(t2, i2, o2, r3) {
          if ("translucent" !== t2.renderPass) return;
          const n2 = o2.paint.get("line-opacity"), s2 = o2.paint.get("line-width");
          if (0 === n2.constantOr(1) || 0 === s2.constantOr(1)) return;
          const a2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), l2 = t2.colorModeForRenderPass(), c2 = t2.terrain && t2.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, h2 = o2.paint.get("line-dasharray"), u2 = h2.constantOr(1), _2 = o2.layout.get("line-cap"), d2 = o2.paint.get("line-pattern"), p2 = d2.constantOr(1), m2 = o2.paint.get("line-gradient"), f2 = p2 ? "linePattern" : "line", g2 = t2.context, v2 = g2.gl, x2 = ((e2) => {
            const t3 = [];
            Qi(e2) && t3.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
            const i3 = e2.paint.get("line-trim-offset");
            0 === i3[0] && 0 === i3[1] || t3.push("RENDER_LINE_TRIM_OFFSET");
            const o3 = e2.paint.get("line-pattern").constantOr(1), r4 = 1 !== e2.paint.get("line-opacity").constantOr(1);
            return !o3 && r4 && t3.push("RENDER_LINE_ALPHA_DISCARD"), t3;
          })(o2);
          let y2 = x2.includes("RENDER_LINE_ALPHA_DISCARD");
          t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (y2 = false);
          for (const n3 of r3) {
            const r4 = i2.getTile(n3);
            if (p2 && !r4.patternsLoaded()) continue;
            const s3 = r4.getBucket(o2);
            if (!s3) continue;
            t2.prepareDrawTile();
            const b2 = s3.programConfigurations.get(o2.id), w2 = t2.useProgram(f2, b2, x2), T2 = d2.constantOr(null);
            if (T2 && r4.imageAtlas) {
              const e2 = r4.imageAtlas.patternPositions[T2.toString()];
              e2 && b2.setConstantPatternPositions(e2);
            }
            const E2 = h2.constantOr(null), C2 = _2.constantOr(null);
            if (!p2 && E2 && C2 && r4.lineAtlas) {
              const e2 = r4.lineAtlas.getDash(E2, C2);
              e2 && b2.setConstantPatternPositions(e2);
            }
            let [M2, I2] = o2.paint.get("line-trim-offset");
            if ("round" === C2 || "square" === C2) {
              const e2 = 1;
              M2 !== I2 && (0 === M2 && (M2 -= e2), 1 === I2 && (I2 += e2));
            }
            const S2 = t2.terrain ? n3.projMatrix : null, D2 = p2 ? Yi(t2, r4, o2, S2, c2) : Hi(t2, r4, o2, S2, s3.lineClipsArray.length, c2, [M2, I2]);
            if (m2) {
              const r5 = s3.gradients[o2.id];
              let a3 = r5.texture;
              if (o2.gradientVersion !== r5.version) {
                let l3 = 256;
                if (o2.stepInterpolant) {
                  const o3 = i2.getSource().maxzoom, r6 = n3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - n3.canonical.z) : 1;
                  l3 = e.clamp(e.nextPowerOfTwo(s3.maxLineLength / e.EXTENT * 1024 * r6), 256, g2.maxTextureSize);
                }
                r5.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r5.gradient || void 0, clips: s3.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new e.Texture(g2, r5.gradient, v2.RGBA), r5.version = o2.gradientVersion, a3 = r5.texture;
              }
              g2.activeTexture.set(v2.TEXTURE1), a3.bind(o2.stepInterpolant ? v2.NEAREST : v2.LINEAR, v2.CLAMP_TO_EDGE);
            }
            u2 && (g2.activeTexture.set(v2.TEXTURE0), r4.lineAtlasTexture.bind(v2.LINEAR, v2.REPEAT), b2.updatePaintBuffers()), p2 && (g2.activeTexture.set(v2.TEXTURE0), r4.imageAtlasTexture.bind(v2.LINEAR, v2.CLAMP_TO_EDGE), b2.updatePaintBuffers()), t2.prepareDrawProgram(g2, w2, n3.toUnwrapped());
            const L2 = (i3) => {
              w2.draw(g2, v2.TRIANGLES, a2, i3, l2, e.CullFaceMode.disabled, D2, o2.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, o2.paint, t2.transform.zoom, b2, [s3.layoutVertexBuffer2]);
            };
            if (y2) {
              const i3 = t2.stencilModeForClipping(n3).ref;
              0 === i3 && t2.terrain && g2.clear({ stencil: 0 });
              const o3 = { func: v2.EQUAL, mask: 255 };
              D2.u_alpha_discard_threshold = 0.8, L2(new e.StencilMode(o3, i3, 255, v2.KEEP, v2.KEEP, v2.INVERT)), D2.u_alpha_discard_threshold = 0, L2(new e.StencilMode(o3, i3, 255, v2.KEEP, v2.KEEP, v2.KEEP));
            } else L2(t2.stencilModeForClipping(n3));
          }
          y2 && (t2.resetStencilClippingMasks(), t2.terrain && g2.clear({ stencil: 0 }));
        }, fill: function(t2, i2, o2, r3) {
          const n2 = o2.paint.get("fill-color"), s2 = o2.paint.get("fill-opacity");
          if (0 === s2.constantOr(1)) return;
          const a2 = t2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = t2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === n2.constantOr(e.Color.transparent).a && 1 === s2.constantOr(0) ? "opaque" : "translucent";
          if (t2.renderPass === c2) {
            const n3 = t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
            vo(t2, i2, o2, r3, n3, a2, false);
          }
          if ("translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
            const n3 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
            vo(t2, i2, o2, r3, n3, a2, true);
          }
        }, "fill-extrusion": function(t2, i2, o2, r3) {
          const n2 = o2.paint.get("fill-extrusion-opacity");
          if (0 !== n2 && "translucent" === t2.renderPass) {
            const s2 = new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D);
            if (1 !== n2 || o2.paint.get("fill-extrusion-pattern").constantOr(1)) xo(t2, i2, o2, r3, s2, e.StencilMode.disabled, e.ColorMode.disabled), xo(t2, i2, o2, r3, s2, t2.stencilModeFor3D(), t2.colorModeForRenderPass()), t2.resetStencilClippingMasks();
            else {
              const n3 = t2.colorModeForRenderPass();
              xo(t2, i2, o2, r3, s2, e.StencilMode.disabled, n3);
            }
          }
        }, hillshade: function(t2, i2, o2, r3) {
          if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass) return;
          const n2 = t2.context, s2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), a2 = t2.colorModeForRenderPass(), l2 = t2.terrain && t2.terrain.renderingToTexture, [c2, h2] = "translucent" !== t2.renderPass || l2 ? [{}, r3] : t2.stencilConfigForOverlap(r3);
          for (const r4 of h2) {
            const n3 = i2.getTile(r4);
            if (n3.needsHillshadePrepare && "offscreen" === t2.renderPass) vi(t2, n3, o2, s2, e.StencilMode.disabled, a2);
            else if ("translucent" === t2.renderPass) {
              const e2 = l2 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r4) : c2[r4.overscaledZ];
              fi(t2, r4, n3, o2, s2, e2, a2);
            }
          }
          n2.viewport.set([0, 0, t2.width, t2.height]), t2.resetStencilClippingMasks();
        }, raster: function(t2, i2, o2, r3, n2, s2) {
          if ("translucent" !== t2.renderPass) return;
          if (0 === o2.paint.get("raster-opacity")) return;
          if (!r3.length) return;
          const a2 = t2.context, l2 = a2.gl, c2 = i2.getSource(), h2 = t2.useProgram("raster"), u2 = t2.colorModeForRenderPass(), _2 = t2.terrain && t2.terrain.renderingToTexture, [d2, p2] = c2 instanceof Ae || _2 ? [{}, r3] : t2.stencilConfigForOverlap(r3), m2 = p2[p2.length - 1].overscaledZ, f2 = !t2.options.moving;
          for (const r4 of p2) {
            const n3 = _2 ? e.DepthMode.disabled : t2.depthModeForSublayer(r4.overscaledZ - m2, 1 === o2.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l2.LESS), p3 = r4.toUnwrapped(), g2 = i2.getTile(r4);
            if (_2 && (!g2 || !g2.hasData())) continue;
            const v2 = _2 ? r4.projMatrix : t2.transform.calculateProjMatrix(p3, f2), x2 = t2.terrain && _2 ? t2.terrain.stencilModeForRTTOverlap(r4) : d2[r4.overscaledZ], y2 = s2 ? 0 : o2.paint.get("raster-fade-duration");
            g2.registerFadeDuration(y2);
            const b2 = i2.findLoadedParent(r4, 0), w2 = Si(g2, b2, i2, t2.transform, y2);
            let T2, E2;
            t2.terrain && t2.terrain.prepareDrawTile();
            const C2 = "nearest" === o2.paint.get("raster-resampling") ? l2.NEAREST : l2.LINEAR;
            a2.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE), a2.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE), g2.texture.useMipmap && a2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && l2.texParameterf(l2.TEXTURE_2D, a2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a2.extTextureFilterAnisotropicMax);
            const M2 = eo(v2, E2 || [0, 0], T2 || 1, w2, o2, c2 instanceof Ae ? c2.perspectiveTransform : [0, 0]);
            if (t2.prepareDrawProgram(a2, h2, p3), c2 instanceof Ae) c2.boundsBuffer && c2.boundsSegments && h2.draw(a2, l2.TRIANGLES, n3, e.StencilMode.disabled, u2, e.CullFaceMode.disabled, M2, o2.id, c2.boundsBuffer, t2.quadTriangleIndexBuffer, c2.boundsSegments);
            else {
              const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r5, tileBoundsSegments: s3 } = t2.getTileBoundsBuffers(g2);
              h2.draw(a2, l2.TRIANGLES, n3, x2, u2, e.CullFaceMode.disabled, M2, o2.id, i3, r5, s3);
            }
          }
          t2.resetStencilClippingMasks();
        }, background: function(t2, i2, o2, r3) {
          const n2 = o2.paint.get("background-color"), s2 = o2.paint.get("background-opacity");
          if (0 === s2) return;
          const a2 = t2.context, l2 = a2.gl, c2 = t2.transform, h2 = c2.tileSize, u2 = o2.paint.get("background-pattern");
          if (t2.isPatternMissing(u2)) return;
          const _2 = !u2 && 1 === n2.a && 1 === s2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t2.renderPass !== _2) return;
          const d2 = e.StencilMode.disabled, p2 = t2.depthModeForSublayer(0, "opaque" === _2 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m2 = t2.colorModeForRenderPass(), f2 = t2.useProgram(u2 ? "backgroundPattern" : "background");
          let g2, v2 = r3;
          v2 || (g2 = t2.getBackgroundTiles(), v2 = Object.values(g2).map((e2) => e2.tileID)), u2 && (a2.activeTexture.set(l2.TEXTURE0), t2.imageManager.bind(t2.context));
          for (const _3 of v2) {
            const v3 = _3.toUnwrapped(), x2 = r3 ? _3.projMatrix : t2.transform.calculateProjMatrix(v3);
            t2.prepareDrawTile();
            const y2 = i2 ? i2.getTile(_3) : g2 ? g2[_3.key] : new e.Tile(_3, h2, c2.zoom, t2), b2 = u2 ? ao(x2, s2, t2, u2, { tileID: _3, tileSize: h2 }) : so(x2, s2, n2);
            t2.prepareDrawProgram(a2, f2, v3);
            const { tileBoundsBuffer: w2, tileBoundsIndexBuffer: T2, tileBoundsSegments: E2 } = t2.getTileBoundsBuffers(y2);
            f2.draw(a2, l2.TRIANGLES, p2, d2, m2, e.CullFaceMode.disabled, b2, o2.id, w2, T2, E2);
          }
        }, sky: function(t2, i2, o2) {
          const r3 = t2.transform, n2 = "mercator" === r3.projection.name || "globe" === r3.projection.name ? 1 : e.smoothstep(7, 8, r3.zoom), s2 = o2.paint.get("sky-opacity") * n2;
          if (0 === s2) return;
          const a2 = t2.context, l2 = o2.paint.get("sky-type"), c2 = new e.DepthMode(a2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), h2 = t2.frameCounter / 1e3 % 1;
          "atmosphere" === l2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r4) {
            const n3 = t3.context, s3 = n3.gl;
            let a3 = i3.skyboxFbo;
            if (!a3) {
              a3 = i3.skyboxFbo = n3.createFramebuffer(32, 32, false), i3.skyboxGeometry = new Po(n3), i3.skyboxTexture = n3.gl.createTexture(), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MAG_FILTER, s3.LINEAR);
              for (let e2 = 0; e2 < 6; ++e2) s3.texImage2D(s3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, s3.RGBA, 32, 32, 0, s3.RGBA, s3.UNSIGNED_BYTE, null);
            }
            n3.bindFramebuffer.set(a3.framebuffer), n3.viewport.set([0, 0, 32, 32]);
            const l3 = i3.getCenter(t3, true), c3 = t3.useProgram("skyboxCapture"), h3 = new Float64Array(16);
            e.identity(h3), e.rotateY(h3, h3, 0.5 * -Math.PI), Ro(n3, i3, c3, h3, l3, 0), e.identity(h3), e.rotateY(h3, h3, 0.5 * Math.PI), Ro(n3, i3, c3, h3, l3, 1), e.identity(h3), e.rotateX(h3, h3, 0.5 * -Math.PI), Ro(n3, i3, c3, h3, l3, 2), e.identity(h3), e.rotateX(h3, h3, 0.5 * Math.PI), Ro(n3, i3, c3, h3, l3, 3), e.identity(h3), Ro(n3, i3, c3, h3, l3, 4), e.identity(h3), e.rotateY(h3, h3, Math.PI), Ro(n3, i3, c3, h3, l3, 5), n3.viewport.set([0, 0, t3.width, t3.height]);
          }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(t3, i3, o3, r4, n3) {
            const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skybox");
            s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
            const h3 = /* @__PURE__ */ ((e2, t4, i4, o4, r5) => ({ u_matrix: e2, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r5 }))(l3.skyboxMatrix, i3.getCenter(t3, false), 0, r4, n3);
            t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, h3, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
          }(t2, o2, c2, s2, h2) : "gradient" === l2 && "sky" === t2.renderPass && function(t3, i3, o3, r4, n3) {
            const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skyboxGradient");
            i3.skyboxGeometry || (i3.skyboxGeometry = new Po(s3)), s3.activeTexture.set(a3.TEXTURE0);
            let h3 = i3.colorRampTexture;
            h3 || (h3 = i3.colorRampTexture = new e.Texture(s3, i3.colorRamp, a3.RGBA)), h3.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
            const u2 = ((t4, i4, o4, r5, n4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r5, u_temporal_offset: n4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r4, n3);
            t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, u2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
          }(t2, o2, c2, s2, h2);
        }, debug: function(e2, t2, i2) {
          for (let o2 = 0; o2 < i2.length; o2++) Mo(e2, t2, i2[o2]);
        }, custom: function(t2, i2, o2, r3) {
          const n2 = t2.context, s2 = o2.implementation;
          if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isLayerDraped()) {
            if ("offscreen" === t2.renderPass) {
              const i3 = s2.prerender;
              if (i3) {
                if (t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                  const o3 = t2.transform.pointMerc;
                  i3.call(s2, n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                } else i3.call(s2, n2.gl, t2.transform.customLayerMatrix());
                n2.setDirty(), t2.setBaseState();
              }
            } else if ("translucent" === t2.renderPass) {
              if (t2.terrain && t2.terrain.renderingToTexture) {
                const i4 = s2.renderToTile;
                if (i4) {
                  const o3 = r3[0].canonical, a2 = new e.MercatorCoordinate(o3.x + r3[0].wrap * (1 << o3.z), o3.y, o3.z);
                  n2.setDepthMode(e.DepthMode.disabled), n2.setStencilMode(e.StencilMode.disabled), n2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(s2, n2.gl, a2), n2.setDirty(), t2.setBaseState();
                }
                return;
              }
              t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), n2.setStencilMode(e.StencilMode.disabled);
              const i3 = "3d" === s2.renderingMode ? new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.DepthMode.ReadOnly);
              if (n2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                const i4 = t2.transform.pointMerc;
                s2.render(n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
              } else s2.render(n2.gl, t2.transform.customLayerMatrix());
              n2.setDirty(), t2.setBaseState(), n2.bindFramebuffer.set(null);
            }
          } else e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        } };
        class Fo {
          constructor(t2, i2, o2 = false) {
            this.context = new Me(t2, o2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
          }
          updateTerrain(e2, t2) {
            const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
            if (!(i2 || this._terrain && this._terrain.enabled)) return;
            this._terrain || (this._terrain = new zi(this, e2));
            const o2 = this._terrain;
            this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2);
          }
          _updateFog(e2) {
            const t2 = e2.fog;
            if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
            const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
            if (i2 > o2) return void (this.transform.fogCullDistSq = null);
            const r3 = i2 + 0.78 * (o2 - i2);
            this.transform.fogCullDistSq = r3 * r3;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          resize(t2, i2) {
            if (this.width = t2 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e2 of this.style.order) this.style._layers[e2].resize();
          }
          setup() {
            const t2 = this.context, i2 = new e.StructArrayLayout2i4();
            i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const o2 = new e.StructArrayLayout2i4();
            o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t2.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
            const r3 = new e.StructArrayLayout2i4();
            r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(-1, 1), r3.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r3, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const n2 = new e.StructArrayLayout4i8();
            n2.emplaceBack(0, 0, 0, 0), n2.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n2.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n2.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t2.createVertexBuffer(n2, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const s2 = new e.StructArrayLayout3ui6();
            s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s2);
            const a2 = new e.StructArrayLayout1ui2();
            for (const e2 of [0, 1, 3, 2, 0]) a2.emplaceBack(e2);
            this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.Texture(t2, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = e.create();
            const l2 = this.context.gl;
            this.stencilClearMode = new e.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e2) {
            return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t2 = this.context, i2 = t2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t2, i2, o2) {
            if (!i2 || this.currentStencilSource === i2.id || !t2.isTileClipped() || !o2 || 0 === o2.length) return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e2 = false;
              for (const t3 of o2) if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                e2 = true;
                break;
              }
              if (!e2) return;
            }
            this.currentStencilSource = i2.id;
            const r3 = this.context, n2 = r3.gl;
            this.nextStencilID + o2.length > 256 && this.clearStencil(), r3.setColorMode(e.ColorMode.disabled), r3.setDepthMode(e.DepthMode.disabled);
            const s2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t3 of o2) {
              const o3 = i2.getTile(t3), a2 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, { tileBoundsBuffer: l2, tileBoundsIndexBuffer: c2, tileBoundsSegments: h2 } = this.getTileBoundsBuffers(o3);
              s2.draw(r3, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, a2, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(t3.projMatrix), "$clipping", l2, c2, h2);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t2 = this.nextStencilID++, i2 = this.context.gl;
            return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
          }
          stencilModeForClipping(t2) {
            if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t2);
            const i2 = this.context.gl;
            return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            const i2 = this.context.gl, o2 = t2.sort((e2, t3) => t3.overscaledZ - e2.overscaledZ), r3 = o2[o2.length - 1].overscaledZ, n2 = o2[0].overscaledZ - r3 + 1;
            if (n2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
              const t3 = {};
              for (let o3 = 0; o3 < n2; o3++) t3[o3 + r3] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
              return this.nextStencilID += n2, [t3, o2];
            }
            return [{ [r3]: e.StencilMode.disabled }, o2];
          }
          colorModeForRenderPass() {
            const t2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new e.ColorMode([t2.CONSTANT_COLOR, t2.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
          }
          depthModeForSublayer(t2, i2, o2) {
            if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;
            const r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r3, r3]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t2, i2) {
            this.style = t2, this.options = i2, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
            const o2 = this.style.order, r3 = this.style._sourceCaches;
            for (const e2 in r3) {
              const t3 = r3[e2];
              t3.used && t3.prepare(this.context);
            }
            const n2 = {}, s2 = {}, a2 = {};
            for (const e2 in r3) {
              const t3 = r3[e2];
              n2[e2] = t3.getVisibleCoordinates(), s2[e2] = n2[e2].slice().reverse(), a2[e2] = t3.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e2 = 0; e2 < o2.length; e2++) if (this.style._layers[o2[e2]].is3D()) {
              this.opaquePassCutoff = e2;
              break;
            }
            if (this.terrain && (this.terrain.updateTileBinding(a2), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl)) return;
            this.renderPass = "offscreen";
            for (const e2 of o2) {
              const i3 = this.style._layers[e2], o3 = t2._getLayerSourceCache(i3);
              if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom)) continue;
              const r4 = o3 ? s2[o3.id] : void 0;
              ("custom" === i3.type || i3.isSky() || r4 && r4.length) && this.renderLayer(this, o3, i3, r4);
            }
            this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon];
            const l2 = this.terrain;
            if (l2 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l2.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky()) continue;
              const r4 = i3 ? s2[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, r4), this.renderLayer(this, i3, e2, r4);
            }
            if (this.style.fog && this.transform.projection.supportsFog && function(t3, i3) {
              const o3 = t3.context, r4 = o3.gl, n3 = t3.transform, s3 = new e.DepthMode(r4.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), a3 = t3.useProgram("globeAtmosphere", null, "globe" === n3.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l3 = e.globeToMercatorTransition(n3.zoom), c2 = i3.properties.get("color").toArray01(), h2 = i3.properties.get("high-color").toArray01(), u2 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e.identity$1([]);
              e.rotateY$1(_2, _2, -e.degToRad(n3._center.lng)), e.rotateX$1(_2, _2, e.degToRad(n3._center.lat)), e.rotateZ$1(_2, _2, n3.angle), e.rotateX$1(_2, _2, -n3._pitch);
              const d2 = e.fromQuat(new Float32Array(16), _2), p2 = e.mapValue(i3.properties.get("star-intensity"), 0, 1, 0, 0.25), m2 = 5e-4, f2 = e.mapValue(i3.properties.get("horizon-blend"), 0, 1, m2, 0.25), g2 = e.globeUseCustomAntiAliasing(t3, o3, n3) && f2 === m2 ? n3.worldSize / (2 * Math.PI * 1.025) - 1 : n3.globeRadius, v2 = t3.frameCounter / 1e3 % 1, x2 = e.length(n3.globeCenterInViewSpace), y2 = Math.sqrt(Math.pow(x2, 2) - Math.pow(g2, 2)), b2 = Math.acos(y2 / x2), w2 = ((t4, i4, o4, r5, n4, s4, a4, l4, c3, h3, u3, _3, d3, p3) => ({ u_frustum_tl: t4, u_frustum_tr: i4, u_frustum_br: o4, u_frustum_bl: r5, u_horizon: n4, u_transition: s4, u_fadeout_range: a4, u_color: l4, u_high_color: c3, u_space_color: h3, u_star_intensity: u3, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d3, u_rotation_matrix: p3 }))(n3.frustumCorners.TL, n3.frustumCorners.TR, n3.frustumCorners.BR, n3.frustumCorners.BL, n3.frustumCorners.horizon, l3, f2, c2, h2, u2, p2, v2, b2, d2);
              t3.prepareDrawProgram(o3, a3);
              const T2 = t3.atmosphereBuffer;
              T2 && a3.draw(o3, r4.TRIANGLES, s3, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w2, "skybox", T2.vertexBuffer, T2.indexBuffer, T2.segments);
            }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              e2.isSky() && this.renderLayer(this, i3, e2, i3 ? s2[i3.id] : void 0);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r4 = i3 ? ("symbol" === e2.type ? a2 : s2)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, i3 ? n2[i3.id] : void 0), this.renderLayer(this, i3, e2, r4), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i3 = null;
              e.values(this.style._layers).forEach((e2) => {
                const o3 = t2._getLayerSourceCache(e2);
                o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
              }), i3 && this.options.showTileBoundaries && ko.debug(this, i3, i3.getVisibleCoordinates());
            }
            this.options.showPadding && function(e2) {
              const t3 = e2.transform.padding;
              Io(e2, e2.transform.height - (t3.top || 0), 3, bo), Io(e2, t3.bottom || 0, 3, wo), So(e2, t3.left || 0, 3, To), So(e2, e2.transform.width - (t3.right || 0), 3, Eo);
              const i3 = e2.transform.centerPoint;
              !function(e3, t4, i4, o3) {
                Do(e3, t4 - 1, i4 - 10, 2, 20, o3), Do(e3, t4 - 10, i4 - 1, 20, 2, o3);
              }(e2, i3.x, e2.transform.height - i3.y, Co);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
          }
          renderLayer(e2, t2, i2, o2) {
            i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), (!e2.transform.projection.unsupportedLayers || !e2.transform.projection.unsupportedLayers.includes(i2.type) || e2.terrain && "custom" === i2.type) && ko[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e2) {
            if (!this.options.gpuTiming) return;
            const t2 = this.context.extTimerQuery;
            let i2 = this.gpuTimers[e2.id];
            i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e2 = this.context.extTimerQuery, t2 = e2.createQueryEXT();
              this.deferredRenderGpuTimeQueries.push(t2), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t2);
            }
          }
          gpuTimingDeferredRenderEnd() {
            if (!this.options.gpuTimingDeferredRender) return;
            const e2 = this.context.extTimerQuery;
            e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming) return;
            const e2 = this.context.extTimerQuery;
            e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e2 = this.gpuTimers;
            return this.gpuTimers = {}, e2;
          }
          collectDeferredRenderGpuQueries() {
            const e2 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e2;
          }
          queryGpuTimers(e2) {
            const t2 = {};
            for (const i2 in e2) {
              const o2 = e2[i2], r3 = this.context.extTimerQuery, n2 = r3.getQueryObjectEXT(o2.query, r3.QUERY_RESULT_EXT) / 1e6;
              r3.deleteQueryEXT(o2.query), t2[i2] = n2;
            }
            return t2;
          }
          queryGpuTimeDeferredRender(e2) {
            if (!this.options.gpuTimingDeferredRender) return 0;
            const t2 = this.context.extTimerQuery;
            let i2 = 0;
            for (const o2 of e2) i2 += t2.getQueryObjectEXT(o2, t2.QUERY_RESULT_EXT) / 1e6, t2.deleteQueryEXT(o2);
            return i2;
          }
          translatePosMatrix(t2, i2, o2, r3, n2) {
            if (!o2[0] && !o2[1]) return t2;
            const s2 = n2 ? "map" === r3 ? this.transform.angle : 0 : "viewport" === r3 ? -this.transform.angle : 0;
            if (s2) {
              const e2 = Math.sin(s2), t3 = Math.cos(s2);
              o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
            }
            const a2 = [n2 ? o2[0] : P(i2, o2[0], this.transform.zoom), n2 ? o2[1] : P(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return e.translate(l2, t2, a2), l2;
          }
          saveTileTexture(e2) {
            const t2 = this._tileTextures[e2.size[0]];
            t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
          }
          getTileTexture(e2) {
            const t2 = this._tileTextures[e2];
            return t2 && t2.length > 0 ? t2.pop() : null;
          }
          isPatternMissing(e2) {
            return null === e2 || void 0 !== e2 && !this.imageManager.getPattern(e2.toString());
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
          }
          currentGlobalDefines() {
            const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.terrain && 0 === this.terrain.exaggeration(), i2 = this.style && this.style.fog, o2 = [];
            return this.terrainRenderModeElevated() && o2.push("TERRAIN"), "globe" === this.transform.projection.name && o2.push("GLOBE"), t2 && o2.push("ZERO_EXAGGERATION"), i2 && !e2 && 0 !== i2.getOpacity(this.transform.pitch) && o2.push("FOG"), e2 && o2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o2.push("OVERDRAW_INSPECTOR"), o2;
          }
          useProgram(e2, t2, i2) {
            this.cache = this.cache || {};
            const o2 = i2 || [], r3 = this.currentGlobalDefines().concat(o2), n2 = Pi.cacheKey(ui[e2], e2, r3, t2);
            return this.cache[n2] || (this.cache[n2] = new Pi(this.context, e2, ui[e2], t2, lo[e2], r3)), this.cache[n2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          prepareDrawProgram(t2, i2, o2) {
            if (this.terrain && this.terrain.renderingToTexture) return;
            const r3 = this.style.fog;
            if (r3) {
              const n2 = r3.getOpacity(this.transform.pitch), s2 = ((t3, i3, o3, r4, n3, s3, a2, l2, c2, h2, u2) => {
                const _2 = t3.transform, d2 = i3.properties.get("color").toArray01();
                d2[3] = r4;
                const p2 = t3.frameCounter / 1e3 % 1;
                return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: d2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_temporal_offset: p2, u_frustum_tl: n3, u_frustum_tr: s3, u_frustum_br: a2, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h2, u_viewport: u2, u_globe_transition: e.globeToMercatorTransition(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
              })(this, r3, o2, n2, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
              i2.setFogUniformValues(t2, s2);
            }
          }
          setTileLoadedFlag(e2) {
            this.tileLoaded = e2;
          }
          saveCanvasCopy() {
            const e2 = this.canvasCopy();
            e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
          }
          canvasCopy() {
            const e2 = this.context.gl, t2 = e2.createTexture();
            return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation) return false;
            const e2 = this.style && this.style.fog;
            return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const t2 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
            for (const r3 of o2) i2[r3.key] = t2[r3.key] || new e.Tile(r3, 512, this.transform.tileZoom, this);
            return i2;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
        }
        class Uo {
          constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
            if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
          }
          interpolate(t2, i2, o2) {
            return null != i2.top && null != t2.top && (this.top = e.number(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.number(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.number(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.number(t2.right, i2.right, o2)), this;
          }
          getCenter(t2, i2) {
            const o2 = e.clamp((this.left + t2 - this.right) / 2, 0, t2), r3 = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
            return new e.pointGeometry(o2, r3);
          }
          equals(e2) {
            return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
          }
          clone() {
            return new Uo(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function No(t2, i2) {
          const o2 = e.getColumn(t2, 3);
          e.fromQuat(t2, i2), e.setColumn(t2, 3, o2);
        }
        function Go(t2, i2) {
          const o2 = e.identity$1([]);
          return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t2), o2;
        }
        function jo(t2, i2) {
          const o2 = [t2[0], t2[1], 0], r3 = [i2[0], i2[1], 0];
          if (e.length(o2) >= 1e-15) {
            const t3 = e.normalize([], o2);
            e.scale$2(r3, t3, e.dot(r3, t3)), i2[0] = r3[0], i2[1] = r3[1];
          }
          const n2 = e.cross([], i2, t2);
          if (e.len(n2) < 1e-15) return null;
          const s2 = Math.atan2(-n2[1], n2[0]);
          return Go(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), s2);
        }
        class Zo {
          constructor(e2, t2) {
            this.position = e2, this.orientation = t2;
          }
          get position() {
            return this._position;
          }
          set position(t2) {
            if (t2) {
              const i2 = t2 instanceof e.MercatorCoordinate ? t2 : new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
              this._renderWorldCopies && (i2.x = e.wrap(i2.x, 0, 1)), this._position = i2;
            } else this._position = null;
          }
          lookAtPoint(t2, i2) {
            if (this.orientation = null, !this.position) return;
            const o2 = this.position, r3 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t2)) : 0, n2 = e.MercatorCoordinate.fromLngLat(t2, r3), s2 = [n2.x - o2.x, n2.y - o2.y, n2.z - o2.z];
            i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = jo(s2, i2);
          }
          setPitchBearing(t2, i2) {
            this.orientation = Go(e.degToRad(t2), e.degToRad(-i2));
          }
        }
        class Vo {
          constructor(t2, i2) {
            this._transform = e.identity([]), this.orientation = i2, this.position = t2;
          }
          get mercatorPosition() {
            const t2 = this.position;
            return new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
          }
          get position() {
            const t2 = e.getColumn(this._transform, 3);
            return [t2[0], t2[1], t2[2]];
          }
          set position(t2) {
            var i2;
            t2 && e.setColumn(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t2) {
            this._orientation = t2 || e.identity$1([]), t2 && No(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e2 = this.forward(), t2 = this.right();
            return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
          }
          setPitchBearing(e2, t2) {
            this._orientation = Go(e2, t2), No(this._transform, this._orientation);
          }
          forward() {
            const t2 = e.getColumn(this._transform, 2);
            return [-t2[0], -t2[1], -t2[2]];
          }
          up() {
            const t2 = e.getColumn(this._transform, 1);
            return [-t2[0], -t2[1], -t2[2]];
          }
          right() {
            const t2 = e.getColumn(this._transform, 0);
            return [t2[0], t2[1], t2[2]];
          }
          getCameraToWorld(t2, i2) {
            const o2 = new Float64Array(16);
            return e.invert(o2, this.getWorldToCamera(t2, i2)), o2;
          }
          getWorldToCameraPosition(t2, i2, o2) {
            const r3 = this.position;
            e.scale$2(r3, r3, -t2);
            const n2 = new Float64Array(16);
            return e.fromScaling(n2, [o2, o2, o2]), e.translate(n2, n2, r3), n2[10] *= i2, n2;
          }
          getWorldToCamera(t2, i2) {
            const o2 = new Float64Array(16), r3 = new Float64Array(4), n2 = this.position;
            return e.conjugate(r3, this._orientation), e.scale$2(n2, n2, -t2), e.fromQuat(o2, r3), e.translate(o2, o2, n2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
          }
          getCameraToClipPerspective(t2, i2, o2, r3) {
            const n2 = new Float64Array(16);
            return e.perspective(n2, t2, i2, o2, r3), n2;
          }
          getDistanceToElevation(t2, i2 = false) {
            const o2 = 0 === t2 ? 0 : e.mercatorZfromAltitude(t2, i2 ? e.latFromMercatorY(this.position[1]) : this.position[1]), r3 = this.forward();
            return (o2 - this.position[2]) / r3[2];
          }
          clone() {
            return new Vo([...this.position], [...this.orientation]);
          }
        }
        function Wo(t2, i2) {
          const o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r3 = function(t3, i3, o3, r4, n3) {
            const s2 = new e.LngLat(o3.lng - 180 * $o, o3.lat), a2 = new e.LngLat(o3.lng + 180 * $o, o3.lat), l2 = t3.project(s2.lng, s2.lat), c2 = t3.project(a2.lng, a2.lat), h2 = -Math.atan2(c2.y - l2.y, c2.x - l2.x), u2 = e.MercatorCoordinate.fromLngLat(o3);
            u2.y = e.clamp(u2.y, -0.999975, 0.999975);
            const _2 = u2.toLngLat(), d2 = t3.project(_2.lng, _2.lat), p2 = e.MercatorCoordinate.fromLngLat(_2);
            p2.x += $o;
            const m2 = p2.toLngLat(), f2 = t3.project(m2.lng, m2.lat), g2 = Yo(f2.x - d2.x, f2.y - d2.y, h2), v2 = e.MercatorCoordinate.fromLngLat(_2);
            v2.y += $o;
            const x2 = v2.toLngLat(), y2 = t3.project(x2.lng, x2.lat), b2 = Yo(y2.x - d2.x, y2.y - d2.y, h2), w2 = Math.abs(g2.x) / Math.abs(b2.y), T2 = e.identity([]);
            e.rotateZ(T2, T2, -h2 * (1 - (n3 ? 0 : r4)));
            const E2 = e.identity([]);
            return e.scale(E2, E2, [1, 1 - (1 - w2) * r4, 1]), E2[4] = -b2.x / b2.y * r4, e.rotateZ(E2, E2, h2), e.multiply(E2, T2, E2), E2;
          }(t2.projection, 0, t2.center, o2, i2), n2 = Xo(t2);
          return e.scale(r3, r3, [n2, n2, 1]), r3;
        }
        function Xo(t2) {
          const i2 = t2.projection, o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r3 = Ho(i2, t2.center), n2 = Ho(i2, e.LngLat.convert(i2.center));
          return Math.pow(2, r3 * o2 + (1 - o2) * n2);
        }
        function qo(t2, i2, o2, r3, n2 = 1 / 0) {
          const s2 = t2.range;
          if (!s2) return 0;
          const a2 = Math.min(n2, Math.max(o2, r3)), l2 = Math.log(a2 / 1024) / Math.LN2;
          return e.smoothstep(s2[0] + l2, s2[1] + l2, i2);
        }
        const $o = 1 / 4e4;
        function Ho(t2, i2) {
          const o2 = e.clamp(i2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), r3 = new e.LngLat(i2.lng - 180 * $o, o2), n2 = new e.LngLat(i2.lng + 180 * $o, o2), s2 = t2.project(r3.lng, o2), a2 = t2.project(n2.lng, o2), l2 = e.MercatorCoordinate.fromLngLat(r3), c2 = e.MercatorCoordinate.fromLngLat(n2), h2 = a2.x - s2.x, u2 = a2.y - s2.y, _2 = c2.x - l2.x, d2 = c2.y - l2.y, p2 = Math.sqrt((_2 * _2 + d2 * d2) / (h2 * h2 + u2 * u2));
          return Math.log(p2) / Math.LN2;
        }
        function Yo(e2, t2, i2) {
          const o2 = Math.cos(i2), r3 = Math.sin(i2);
          return { x: e2 * o2 - t2 * r3, y: e2 * r3 + t2 * o2 };
        }
        class Ko {
          constructor(t2, i2, o2, r3, n2, s2, a2) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === n2 || n2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r3 ? 60 : r3, this.setProjection(s2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
          }
          clone() {
            const e2 = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e2) {
            this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          updateElevation(e2, t2 = false) {
            const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
          }
          getProjection() {
            return e.pick(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(i2) {
            this.projectionOptions = i2 || { name: "mercator" };
            const o2 = this.projection ? this.getProjection() : void 0;
            this.projection = e.getProjection(this.projectionOptions);
            const r3 = !t(o2, this.getProjection());
            return r3 && this._calcMatrices(), this.mercatorFromTransition = false, r3;
          }
          setMercatorFromTransition() {
            const t2 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });
            const i2 = t2 !== this.projection.name;
            return i2 && this._calcMatrices(), i2;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e2) {
            this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e2) {
            this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e2) {
            this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e2) {
            this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e2) {
            void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get cameraWorldSize() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.pointGeometry(this.width, this.height);
          }
          get bearing() {
            return e.wrap(this.rotation, -180, 180);
          }
          set bearing(e2) {
            this.rotation = e2;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t2) {
            const i2 = -t2 * Math.PI / 180;
            var o2;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t3, i3) {
              var o3 = t3[0], r3 = t3[1], n2 = t3[2], s2 = t3[3], a2 = Math.sin(i3), l2 = Math.cos(i3);
              e2[0] = o3 * l2 + n2 * a2, e2[1] = r3 * l2 + s2 * a2, e2[2] = o3 * -a2 + n2 * l2, e2[3] = r3 * -a2 + s2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t2) {
            const i2 = e.clamp(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e2 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e2);
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.degToRad(t2), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e2) {
            this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e2) {
            const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
            this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e2) {
            this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
          }
          _updateCameraOnTerrain() {
            if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const e2 = this._elevation;
            this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation) return 0;
            const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
            let r3 = 0, n2 = 0;
            for (let s2 = 0; s2 < i2.length; s2++) {
              const a2 = new e.pointGeometry(i2[s2][0] * this.width, o2 + i2[s2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
              if (!l2) continue;
              const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
              r3 += l2[3] * c2, n2 += c2;
            }
            return 0 === n2 ? NaN : r3 / n2;
          }
          get center() {
            return this._center;
          }
          set center(e2) {
            e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation) return;
            const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), r3 = this._mercatorZfromZoom(this._maxZoom), n2 = Math.max(o2 - i2, r3);
            this._setZoom(this._zoomFromMercatorZ(n2));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e2) {
            this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t2) {
            const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
            let o2;
            o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
            const r3 = e.length(e.sub([], this._camera.position, o2));
            return e.clamp(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t2) {
            if (!this.height) return;
            if (!t2.position && !t2.orientation) return;
            this._updateCameraState();
            let i2 = false;
            if (t2.orientation && !e.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
              const o2 = [t2.position.x, t2.position.y, t2.position.z];
              e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
            }
            i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t2 = this._camera.position, i2 = new Zo();
            return i2.position = new e.MercatorCoordinate(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
          }
          _setCameraOrientation(t2) {
            if (!e.length$1(t2)) return false;
            e.normalize$1(t2, t2);
            const i2 = e.transformQuat([], [0, 0, -1], t2), o2 = e.transformQuat([], [0, -1, 0], t2);
            if (o2[2] < 0) return false;
            const r3 = jo(i2, o2);
            return !!r3 && (this._camera.orientation = r3, true);
          }
          _setCameraPosition(t2) {
            const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
            t2[2] = e.clamp(t2[2], r3 / o2, r3 / i2), this._camera.position = t2;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e2) {
            return this._edgeInsets.equals(e2);
          }
          interpolatePadding(e2, t2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e2) {
            const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
            return Math.max(0, t2);
          }
          getVisibleUnwrappedCoordinates(t2) {
            const i2 = [new e.UnwrappedTileID(0, t2)];
            if (this.renderWorldCopies) {
              const o2 = this.pointCoordinate(new e.pointGeometry(0, 0)), r3 = this.pointCoordinate(new e.pointGeometry(this.width, 0)), n2 = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), s2 = this.pointCoordinate(new e.pointGeometry(0, this.height)), a2 = Math.floor(Math.min(o2.x, r3.x, n2.x, s2.x)), l2 = Math.floor(Math.max(o2.x, r3.x, n2.x, s2.x)), c2 = 1;
              for (let o3 = a2 - c2; o3 <= l2 + c2; o3++) 0 !== o3 && i2.push(new e.UnwrappedTileID(o3, t2));
            }
            return i2;
          }
          coveringTiles(t2) {
            let i2 = this.coveringZoomLevel(t2);
            const o2 = i2, r3 = this.elevation && !t2.isTerrainDEM, n2 = "mercator" === this.projection.name;
            if (void 0 !== t2.minzoom && i2 < t2.minzoom) return [];
            void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
            const s2 = this.locationCoordinate(this.center), a2 = this.center.lat, l2 = 1 << i2, c2 = [l2 * s2.x, l2 * s2.y, 0], h2 = "globe" === this.projection.name, u2 = !h2, _2 = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u2), d2 = h2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p2 = l2 * e.mercatorZfromAltitude(1, this.center.lat), m2 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), f2 = [l2 * d2.x, l2 * d2.y, m2 * (u2 ? 1 : p2)], g2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), v2 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i2 : 0, x2 = t2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y2 = t2.isTerrainDEM ? -x2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? Xo(this) : 1, w2 = (t3) => {
              const i3 = 1 / 4e4, o3 = new e.MercatorCoordinate(t3.x + i3, t3.y, t3.z), r4 = new e.MercatorCoordinate(t3.x, t3.y + i3, t3.z), n3 = t3.toLngLat(), s3 = o3.toLngLat(), a3 = r4.toLngLat(), l3 = this.locationCoordinate(n3), c3 = this.locationCoordinate(s3), h3 = this.locationCoordinate(a3), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), _3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
              return Math.sqrt(u3 * _3) * b2 / i3;
            }, T2 = (t3) => {
              const i3 = x2, o3 = y2;
              return { aabb: e.tileAABB(this, l2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
            }, E2 = [];
            let C2 = [];
            const M2 = i2, I2 = t2.reparseOverscaled ? o2 : i2, S2 = (e2) => e2 * e2, D2 = S2((m2 - this._centerAltitude) * p2), L2 = (e2) => {
              if (!this._elevation || !e2.tileID || !n2) return;
              const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
              t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = A2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
            }, A2 = (t3) => {
              if (t3.zoom < v2) return true;
              if (t3.zoom === M2) return false;
              if (null != t3.shouldSplit) return t3.shouldSplit;
              const i3 = t3.aabb.distanceX(f2), n3 = t3.aabb.distanceY(f2);
              let s3 = D2, l3 = 1;
              if (h2) {
                s3 = S2(t3.aabb.distanceZ(f2));
                const i4 = Math.pow(2, t3.zoom), o3 = e.latFromMercatorY((t3.y + 1) / i4), r4 = e.latFromMercatorY(t3.y / i4), n4 = Math.min(Math.max(a2, o3), r4), c4 = e.circumferenceAtLatitude(n4) / e.circumferenceAtLatitude(a2);
                if (l3 = n4 === a2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c4 / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t3.zoom === M2 - 1 && c4 >= 0.9) return true;
              } else if (r3 && (s3 = S2(t3.aabb.distanceZ(f2) * p2)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                const i4 = Math.pow(2, t3.zoom), o3 = w2(new e.MercatorCoordinate((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                l3 = o3 > 0.85 ? 1 : o3;
              }
              const c3 = i3 * i3 + n3 * n3 + s3, u3 = S2((1 << M2 - t3.zoom) * g2 * l3 * ((e2, t4) => {
                if (t4 * S2(0.707) < e2) return 1;
                const i4 = Math.sqrt(t4 / e2);
                return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(s3, D2), c3));
              return c3 < u3;
            };
            if (this.renderWorldCopies) for (let e2 = 1; e2 <= 3; e2++) E2.push(T2(-e2)), E2.push(T2(e2));
            for (E2.push(T2(0)); E2.length > 0; ) {
              const o3 = E2.pop(), s3 = o3.x, a3 = o3.y;
              let u3 = o3.fullyVisible;
              if (!u3) {
                const e2 = o3.aabb.intersects(_2);
                if (0 === e2) continue;
                u3 = 2 === e2;
              }
              if (o3.zoom !== M2 && A2(o3)) for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (s3 << 1) + t3 % 2, c3 = (a3 << 1) + (t3 >> 1), _3 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.tileAABB(this, l2, o3.zoom + 1, i3, c3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: c3, wrap: o3.wrap, fullyVisible: u3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                r3 && !h2 && (_3.tileID = new e.OverscaledTileID(o3.zoom + 1 === M2 ? I2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, c3), L2(_3)), E2.push(_3);
              }
              else {
                const r4 = o3.zoom === M2 ? I2 : o3.zoom;
                if (t2.minzoom && t2.minzoom > r4) continue;
                const n3 = c2[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), l3 = c2[1] - 0.5 - a3, h3 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r4, o3.wrap, o3.zoom, s3, a3);
                C2.push({ tileID: h3, distanceSq: n3 * n3 + l3 * l3 });
              }
            }
            if (this.fogCullDistSq) {
              const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
              C2 = C2.filter((r4) => {
                const n3 = [0, 0, 0, 1], s3 = [e.EXTENT, e.EXTENT, 0, 1], a3 = this.calculateFogTileMatrix(r4.tileID.toUnwrapped());
                e.transformMat4$1(n3, n3, a3), e.transformMat4$1(s3, s3, a3);
                const l3 = e.getAABBPointSquareDist(n3, s3);
                if (0 === l3) return true;
                let c3 = false;
                const h3 = this._elevation;
                if (h3 && l3 > i3 && 0 !== o3) {
                  const i4 = this.calculateProjMatrix(r4.tileID.toUnwrapped());
                  let n4;
                  t2.isTerrainDEM || (n4 = h3.getMinMaxForTile(r4.tileID)), n4 || (n4 = { min: y2, max: x2 });
                  const s4 = e.furthestTileCorner(this.rotation), a4 = [s4[0] * e.EXTENT, s4[1] * e.EXTENT, n4.max];
                  e.transformMat4(a4, a4, i4), c3 = (1 - a4[1]) * this.height * 0.5 < o3;
                }
                return l3 < i3 || c3;
              });
            }
            return C2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
          }
          resize(e2, t2) {
            this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e2) {
            return Math.pow(2, e2);
          }
          scaleZoom(e2) {
            return Math.log(e2) / Math.LN2;
          }
          project(t2) {
            const i2 = e.clamp(t2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t2.lng, i2);
            return new e.pointGeometry(o2.x * this.worldSize, o2.y * this.worldSize);
          }
          unproject(e2) {
            return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t2, i2) {
            let o2, r3;
            const n2 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e2 = this.worldSize;
              o2 = (i2.x - n2.x) / e2, r3 = (i2.y - n2.y) / e2;
            } else {
              const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(n2);
              o2 = e2.x - t3.x, r3 = e2.y - t3.y;
            }
            const s2 = this.locationCoordinate(t2);
            this.setLocation(new e.MercatorCoordinate(s2.x - o2, s2.y - r3));
          }
          setLocation(e2) {
            this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e2) {
            return this.projection.locationPoint(this, e2);
          }
          locationPoint3D(e2) {
            return this.projection.locationPoint(this, e2, true);
          }
          pointLocation(e2) {
            return this.coordinateLocation(this.pointCoordinate(e2));
          }
          pointLocation3D(e2) {
            return this.coordinateLocation(this.pointCoordinate3D(e2));
          }
          locationCoordinate(t2, i2) {
            const o2 = i2 ? e.mercatorZfromAltitude(i2, t2.lat) : void 0, r3 = this.projection.project(t2.lng, t2.lat);
            return new e.MercatorCoordinate(r3.x, r3.y, o2);
          }
          coordinateLocation(e2) {
            return this.projection.unproject(e2.x, e2.y);
          }
          pointRayIntersection(t2, i2) {
            const o2 = null != i2 ? i2 : this._centerAltitude, r3 = [t2.x, t2.y, 0, 1], n2 = [t2.x, t2.y, 1, 1];
            e.transformMat4$1(r3, r3, this.pixelMatrixInverse), e.transformMat4$1(n2, n2, this.pixelMatrixInverse);
            const s2 = n2[3];
            e.scale$1(r3, r3, 1 / r3[3]), e.scale$1(n2, n2, 1 / s2);
            const a2 = r3[2], l2 = n2[2];
            return { p0: r3, p1: n2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
          }
          screenPointToMercatorRay(t2) {
            const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
            return e.transformMat4$1(i2, i2, this.pixelMatrixInverse), e.transformMat4$1(o2, o2, this.pixelMatrixInverse), e.scale$1(i2, i2, 1 / i2[3]), e.scale$1(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$1(i2, i2, 1 / this.worldSize), e.scale$1(o2, o2, 1 / this.worldSize), new e.Ray([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
          }
          rayIntersectionCoordinate(t2) {
            const { p0: i2, p1: o2, t: r3 } = t2, n2 = e.mercatorZfromAltitude(i2[2], this._center.lat), s2 = e.mercatorZfromAltitude(o2[2], this._center.lat);
            return new e.MercatorCoordinate(e.number(i2[0], o2[0], r3) / this.worldSize, e.number(i2[1], o2[1], r3) / this.worldSize, e.number(n2, s2, r3));
          }
          pointCoordinate(e2, t2 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
          }
          pointCoordinate3D(t2) {
            if (!this.elevation) return this.pointCoordinate(t2);
            let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
            if (i2) return new e.MercatorCoordinate(i2[0], i2[1], i2[2]);
            let o2 = 0, r3 = this.horizonLineFromTop();
            if (t2.y > r3) return this.pointCoordinate(t2);
            const n2 = 0.02 * r3, s2 = t2.clone();
            for (let t3 = 0; t3 < 10 && r3 - o2 > n2; t3++) {
              s2.y = e.number(o2, r3, 0.66);
              const t4 = this.projection.pointCoordinate3D(this, s2.x, s2.y);
              t4 ? (r3 = s2.y, i2 = t4) : o2 = s2.y;
            }
            return i2 ? new e.MercatorCoordinate(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
          }
          isPointAboveHorizon(e2) {
            return this.projection.isPointAboveHorizon(this, e2);
          }
          _coordinatePoint(t2, i2) {
            const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r3 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
            return e.transformMat4$1(r3, r3, this.pixelMatrix), r3[3] > 0 ? new e.pointGeometry(r3[0] / r3[3], r3[1] / r3[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r3 = this.width - this._edgeInsets.right, n2 = this.pointLocation3D(new e.pointGeometry(i2, t2)), s2 = this.pointLocation3D(new e.pointGeometry(r3, t2)), a2 = this.pointLocation3D(new e.pointGeometry(r3, o2)), l2 = this.pointLocation3D(new e.pointGeometry(i2, o2));
            let c2 = Math.min(n2.lng, s2.lng, a2.lng, l2.lng), h2 = Math.max(n2.lng, s2.lng, a2.lng, l2.lng), u2 = Math.min(n2.lat, s2.lat, a2.lat, l2.lat), _2 = Math.max(n2.lat, s2.lat, a2.lat, l2.lat);
            const d2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, m2 = (t3, i3, o3, r4, n3) => {
              const s3 = (t3 + o3) / 2, a3 = (i3 + r4) / 2, l3 = new e.pointGeometry(s3, a3), { lng: f2, lat: g2 } = this.pointLocation3D(l3), v2 = Math.max(0, c2 - f2, u2 - g2, f2 - h2, g2 - _2);
              c2 = Math.min(c2, f2), h2 = Math.max(h2, f2), u2 = Math.min(u2, g2), _2 = Math.max(_2, g2), (n3 < p2 || v2 > d2) && (m2(t3, i3, s3, a3, n3 + 1), m2(s3, a3, o3, r4, n3 + 1));
            };
            if (m2(i2, t2, r3, t2, 1), m2(r3, t2, r3, o2, 1), m2(r3, o2, i2, o2, 1), m2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
              const [t3, i3] = e.polesInViewport(this);
              t3 ? (_2 = 90, h2 = 180, c2 = -180) : i3 && (u2 = -90, h2 = 180, c2 = -180);
            }
            return new e.LngLatBounds(new e.LngLat(c2, u2), new e.LngLat(h2, _2));
          }
          _getBoundsRectangular(t2, i2) {
            const { top: o2, left: r3 } = this._edgeInsets, n2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, a2 = new e.pointGeometry(r3, o2), l2 = new e.pointGeometry(s2, o2), c2 = new e.pointGeometry(s2, n2), h2 = new e.pointGeometry(r3, n2);
            let u2 = this.pointCoordinate(a2, t2), _2 = this.pointCoordinate(l2, t2);
            const d2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h2, i2), m2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
            return u2.y > 1 && _2.y >= 0 ? u2 = new e.MercatorCoordinate((1 - p2.y) / m2(p2, u2) + p2.x, 1) : u2.y < 0 && _2.y <= 1 && (u2 = new e.MercatorCoordinate(-p2.y / m2(p2, u2) + p2.x, 0)), _2.y > 1 && u2.y >= 0 ? _2 = new e.MercatorCoordinate((1 - d2.y) / m2(d2, _2) + d2.x, 1) : _2.y < 0 && u2.y <= 1 && (_2 = new e.MercatorCoordinate(-d2.y / m2(d2, _2) + d2.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u2)).extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(d2));
          }
          _getBoundsRectangularTerrain() {
            const e2 = this.elevation;
            if (!e2.visibleDemTiles.length || e2.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
            const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
              if (t3.dem) {
                const i2 = t3.dem.tree;
                e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
              }
              return e3;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e2 = true) {
            const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
            return e2 ? Math.max(0, i2) : i2;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t2) {
            this.maxBounds = t2, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e2, t2) {
            return this.projection.createTileMatrix(this, t2, e2);
          }
          calculateDistanceTileData(t2) {
            const i2 = t2.key, o2 = this._distanceTileDataCache;
            if (o2[i2]) return o2[i2];
            const r3 = t2.canonical, n2 = 1 / this.height, s2 = this.cameraWorldSize, a2 = s2 / this.zoomScale(r3.z), l2 = (r3.x + Math.pow(2, r3.z) * t2.wrap) * a2, c2 = r3.y * a2, h2 = this.point;
            h2.x *= s2 / this.worldSize, h2.y *= s2 / this.worldSize;
            const u2 = this.angle, _2 = Math.sin(-u2), d2 = -Math.cos(-u2);
            return o2[i2] = { bearing: [_2, d2], center: [(h2.x - l2) * n2, (h2.y - c2) * n2], scale: a2 / e.EXTENT * n2 }, o2[i2];
          }
          calculateFogTileMatrix(t2) {
            const i2 = t2.key, o2 = this._fogTileMatrixCache;
            if (o2[i2]) return o2[i2];
            const r3 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
            return e.multiply(r3, this.worldToFogMatrix, r3), o2[i2] = new Float32Array(r3), o2[i2];
          }
          calculateProjMatrix(t2, i2 = false) {
            const o2 = t2.key, r3 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
            if (r3[o2]) return r3[o2];
            const n2 = this.calculatePosMatrix(t2, this.worldSize);
            return e.multiply(n2, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, n2), r3[o2] = new Float32Array(n2), r3[o2];
          }
          calculatePixelsToTileUnitsMatrix(t2) {
            const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
            if (o2[i2]) return o2[i2];
            const r3 = function(t3, i3) {
              const { scale: o3 } = t3.tileTransform, r4 = o3 * e.EXTENT / (t3.tileSize * Math.pow(2, i3.zoom - t3.tileID.overscaledZ + t3.tileID.canonical.z));
              return n2 = new Float32Array(4), l2 = (s2 = i3.inverseAdjustmentMatrix)[1], c2 = s2[2], h2 = s2[3], _2 = (a2 = [r4, r4])[1], n2[0] = s2[0] * (u2 = a2[0]), n2[1] = l2 * u2, n2[2] = c2 * _2, n2[3] = h2 * _2, n2;
              var n2, s2, a2, l2, c2, h2, u2, _2;
            }(t2, this);
            return o2[i2] = r3, o2[i2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t2 = 1 / this.worldSize, i2 = e.fromScaling([], [t2, t2, t2]);
              return e.multiply(i2, i2, this.globeMatrix), i2;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name) return;
            const t2 = this._elevation;
            this._updateCameraState();
            const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r3 = this._camera.forward(), n2 = e.mercatorZfromAltitude(1, this._center.lat);
            o2[2] /= n2, r3[2] /= n2, e.normalize(r3, r3);
            const s2 = t2.raycast(o2, r3, t2.exaggeration());
            if (s2) {
              const t3 = e.scaleAndAdd([], o2, r3, s2), i3 = new e.MercatorCoordinate(t3[0], t3[1], e.mercatorZfromAltitude(t3[2], e.latFromMercatorY(t3[1]))), a2 = (i3.z + e.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * n2])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t2 = false) {
            if (!this._elevation) return;
            const i2 = this._elevation, o2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r3 = this._computeCameraPosition(o2), n2 = i2.getAtPointOrZero(new e.MercatorCoordinate(...r3)), s2 = this.pixelsPerMeter / this.worldSize * n2, a2 = this._minimumHeightOverTerrain(), l2 = r3[2] - s2;
            if (l2 <= a2) if (l2 < 0 || t2) {
              const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r3[0], r3[1], t3.z - r3[2]], o3 = e.length(i3);
              i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
              const n3 = e.length(i3);
              if (0 === n3) return;
              e.scale$2(i3, i3, o3 / n3 * this._pixelsPerMercatorPixel), this._camera.position = [r3[0], r3[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
            } else this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = true;
            const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t2) {
              const i3 = this.center;
              return i3.lat = e.clamp(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.clamp(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
            }
            const i2 = this._unmodified, { x: o2, y: r3 } = this.point;
            let n2 = 0, s2 = o2, a2 = r3;
            const l2 = this.width / 2, c2 = this.height / 2, h2 = this.worldMinY * this.scale, u2 = this.worldMaxY * this.scale;
            if (r3 - c2 < h2 && (a2 = h2 + c2), r3 + c2 > u2 && (a2 = u2 - c2), u2 - h2 < this.height && (n2 = Math.max(n2, this.height / (u2 - h2)), a2 = (u2 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
              s2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, s2 - l2 < e2 && (s2 = e2 + l2), s2 + l2 > t3 && (s2 = t3 - l2), t3 - e2 < this.width && (n2 = Math.max(n2, this.width / (t3 - e2)), s2 = (t3 + e2) / 2);
            }
            s2 === o2 && a2 === r3 || (this.center = this.unproject(new e.pointGeometry(s2, a2))), n2 && (this.zoom += this.scaleZoom(n2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
          }
          _minZoomForBounds() {
            let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height) return;
            const t2 = this.centerOffset, i2 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
            const o2 = qo(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const r3 = "meters" === this.projection.zAxisUnit ? i2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, r3), s2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height;
            let a2 = e.mul([], s2, n2);
            if (this.projection.isReprojectedInTileSpace) {
              const t3 = this.locationCoordinate(this.center), i3 = e.identity([]);
              e.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.multiply(i3, i3, Wo(this)), e.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.multiply(a2, a2, i3), this.inverseAdjustmentMatrix = function(e2) {
                const t4 = Wo(e2, true);
                return v([], [t4[0], t4[1], t4[4], t4[5]]);
              }(this);
            } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            this.mercatorMatrix = e.scale([], a2, [this.worldSize, this.worldSize, this.worldSize / r3, 1]), this.projMatrix = a2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
            const l2 = e.invert([], s2);
            this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l2, this.horizonLineFromTop(), this.height);
            const c2 = new Float32Array(16);
            e.identity(c2), e.scale(c2, c2, [1, -1, 1]), e.rotateX(c2, c2, this._pitch), e.rotateZ(c2, c2, this.angle);
            const h2 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            h2[8] = 2 * -t2.x / this.width, h2[9] = 2 * (t2.y + u2) / this.height, this.skyboxMatrix = e.multiply(c2, h2, c2);
            const _2 = this.point, d2 = _2.x, p2 = _2.y, m2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = d2 - Math.round(d2) + g2 * m2 + x2 * f2, b2 = p2 - Math.round(p2) + g2 * f2 + x2 * m2, w2 = new Float64Array(a2);
            if (e.translate(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedProjMatrix = w2, a2 = e.create(), e.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), e.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.create(), e.scale(a2, a2, [1, -1, 1]), e.translate(a2, a2, [-1, -1, 0]), e.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a2 = e.invert(new Float64Array(16), this.pixelMatrix), !a2) throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = a2, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e.calculateGlobeMatrix(this);
              const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e.transformMat4(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else this.globeMatrix = a2;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r3 = 1 / this.height / this._pixelsPerMercatorPixel, n2 = [t2, t2, i2];
            e.scale$2(n2, n2, r3), e.scale$2(o2, o2, -1), e.multiply$2(o2, o2, n2);
            const s2 = e.create();
            e.translate(s2, s2, o2), e.scale(s2, s2, n2), this.mercatorFogMatrix = s2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r3);
          }
          _computeCameraPosition(e2) {
            const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r3 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
            return [o2.x / this.worldSize - i2[0] * r3, o2.y / this.worldSize - i2[1] * r3, e2 / this.worldSize * this._centerAltitude - i2[2] * r3];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t2) {
            const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r3 = t2[2];
            let n2 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), r3 > 0 && (n2 = Math.min((i2 - o2) / r3, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t2, n2), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r3 } = this._camera.getPitchBearing(), n2 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), a2 = Math.max((t2[2] - n2) / Math.cos(o2), s2), l2 = this._zoomFromMercatorZ(a2);
            e.scaleAndAdd(t2, t2, i2, a2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r3, -Math.PI, Math.PI), this._setZoom(e.clamp(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e2) {
            return Math.pow(2, e2) * this.tileSize;
          }
          _mercatorZfromZoom(e2) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
          }
          _minimumHeightOverTerrain() {
            const e2 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
            return this._mercatorZfromZoom(e2);
          }
          _zoomFromMercatorZ(e2) {
            return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t2) {
            let i2 = 0, o2 = e.GLOBE_ZOOM_THRESHOLD_MAX, r3 = 0, n2 = 1 / 0;
            for (; o2 - i2 > 1e-6 && o2 > i2; ) {
              const e2 = i2 + 0.5 * (o2 - i2), s2 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, s2), l2 = this.scaleZoom(a2 / (t2 * this.tileSize)), c2 = Math.abs(e2 - l2);
              c2 < n2 && (n2 = c2, r3 = e2), e2 < l2 ? i2 = e2 : o2 = e2;
            }
            return r3;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t2, i2) {
            const o2 = Math.min(t2.x, i2.x), r3 = Math.max(t2.x, i2.x), n2 = Math.min(t2.y, i2.y), s2 = Math.max(t2.y, i2.y);
            if (n2 < this.horizonLineFromTop(false)) return true;
            if ("mercator" !== this.projection.name) return false;
            const a2 = [new e.pointGeometry(o2, n2), new e.pointGeometry(r3, s2), new e.pointGeometry(o2, s2), new e.pointGeometry(r3, n2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
            for (const e2 of a2) {
              const t3 = this.pointRayIntersection(e2);
              if (t3.t < 0) return true;
              const i3 = this.rayIntersectionCoordinate(t3);
              if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1) return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
          }
          zoomDeltaToMovement(t2, i2) {
            const o2 = e.length(e.sub([], this._camera.position, t2)), r3 = this._zoomFromMercatorZ(o2) + i2;
            return o2 - this._mercatorZfromZoom(r3);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t2 = function([t3, i2, o2], r3) {
                const n2 = [t3, i2, o2, 1];
                e.transformMat4$1(n2, n2, r3);
                const s2 = n2[3] = Math.max(n2[3], 1e-6);
                return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e.pointGeometry(t2[0], t2[1]);
            }
            {
              const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e.pointGeometry(0, t2));
            }
          }
          getCameraToCenterDistance(e2, t2 = this.zoom, i2 = this.worldSize) {
            const o2 = qo(e2, t2, this.width, this.height, 1024), r3 = e2.pixelSpaceConversion(this.center.lat, i2, o2);
            return 0.5 / Math.tan(0.5 * this._fov) * this.height * r3;
          }
          getWorldToCameraMatrix() {
            const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e.multiply(t2, t2, this.globeMatrix), t2;
          }
        }
        function Jo(e2, t2) {
          let i2 = false, o2 = null;
          const r3 = () => {
            o2 = null, i2 && (e2(), o2 = setTimeout(r3, t2), i2 = false);
          };
          return () => (i2 = true, o2 || r3(), o2);
        }
        class Qo {
          constructor(t2) {
            this._hashName = t2 && encodeURIComponent(t2), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t2) {
            return this._map = t2, e.window.addEventListener("hashchange", this._onHashChange, false), t2.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const t2 = this._map;
            if (!t2) return "";
            const i2 = er(t2);
            if (this._hashName) {
              const t3 = this._hashName;
              let o2 = false;
              const r3 = e.window.location.hash.slice(1).split("&").map((e2) => {
                const r4 = e2.split("=")[0];
                return r4 === t3 ? (o2 = true, `${r4}=${i2}`) : e2;
              }).filter((e2) => e2);
              return o2 || r3.push(`${t3}=${i2}`), `#${r3.join("&")}`;
            }
            return `#${i2}`;
          }
          _getCurrentHash() {
            const t2 = e.window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
                t3[0] === this._hashName && (e2 = t3);
              }), (e2 && e2[1] || "").split("/");
            }
            return t2.split("/");
          }
          _onHashChange() {
            const e2 = this._map;
            if (!e2) return false;
            const t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
              const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
              return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            const t2 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
            e.window.history.replaceState(e.window.history.state, null, t2);
          }
        }
        function er(e2, t2) {
          const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r3 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n2 = Math.pow(10, r3), s2 = Math.round(i2.lng * n2) / n2, a2 = Math.round(i2.lat * n2) / n2, l2 = e2.getBearing(), c2 = e2.getPitch();
          let h2 = t2 ? `/${s2}/${a2}/${o2}` : `${o2}/${a2}/${s2}`;
          return (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), h2;
        }
        const tr = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, ir = e.extend({ deceleration: 2500, maxSpeed: 1400 }, tr), or = e.extend({ deceleration: 20, maxSpeed: 1400 }, tr), rr = e.extend({ deceleration: 1e3, maxSpeed: 360 }, tr), nr = e.extend({ deceleration: 1e3, maxSpeed: 90 }, tr);
        class sr {
          constructor(e2) {
            this._map = e2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t2 });
          }
          _drainInertiaBuffer() {
            const t2 = this._inertiaBuffer, i2 = e.exported.now();
            for (; t2.length > 0 && i2 - t2[0].time > 160; ) t2.shift();
          }
          _onMoveEnd(t2) {
            if (e.exported.prefersReducedMotion) return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e2 } of this._inertiaBuffer) i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
            const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
            if (i2.pan.mag()) {
              const n2 = lr(i2.pan.mag(), o2, e.extend({}, ir, t2 || {}));
              r3.offset = i2.pan.mult(n2.amount / i2.pan.mag()), r3.center = this._map.transform.center, ar(r3, n2);
            }
            if (i2.zoom) {
              const e2 = lr(i2.zoom, o2, or);
              r3.zoom = this._map.transform.zoom + e2.amount, ar(r3, e2);
            }
            if (i2.bearing) {
              const t3 = lr(i2.bearing, o2, rr);
              r3.bearing = this._map.transform.bearing + e.clamp(t3.amount, -179, 179), ar(r3, t3);
            }
            if (i2.pitch) {
              const e2 = lr(i2.pitch, o2, nr);
              r3.pitch = this._map.transform.pitch + e2.amount, ar(r3, e2);
            }
            if (r3.zoom || r3.bearing) {
              const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              r3.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
            }
            return this.clear(), r3.noMoveStart = true, r3;
          }
        }
        function ar(e2, t2) {
          (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
        }
        function lr(t2, i2, o2) {
          const { maxSpeed: r3, linearity: n2, deceleration: s2 } = o2, a2 = e.clamp(t2 * n2 / (i2 / 1e3), -r3, r3), l2 = Math.abs(a2) / (s2 * n2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
        }
        class cr extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, o2, r3 = {}) {
            const n2 = p(i2.getCanvasContainer(), o2), s2 = i2.unproject(n2);
            super(t2, e.extend({ point: n2, lngLat: s2, originalEvent: o2 }, r3)), this._defaultPrevented = false, this.target = i2;
          }
        }
        class hr extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, o2) {
            const r3 = "touchend" === t2 ? o2.changedTouches : o2.touches, n2 = m(i2.getCanvasContainer(), r3), s2 = n2.map((e2) => i2.unproject(e2)), a2 = n2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.pointGeometry(0, 0));
            super(t2, { points: n2, point: a2, lngLats: s2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
          }
        }
        class ur extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, t2, i2) {
            super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
        }
        class _r {
          constructor(e2, t2) {
            this._map = e2, this._clickTolerance = t2.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e2) {
            return this._firePreventable(new ur(e2.type, this._map, e2));
          }
          mousedown(e2, t2) {
            return this._mousedownPos = t2, this._firePreventable(new cr(e2.type, this._map, e2));
          }
          mouseup(e2) {
            this._map.fire(new cr(e2.type, this._map, e2));
          }
          preclick(t2) {
            const i2 = e.extend({}, t2);
            i2.type = "preclick", this._map.fire(new cr(i2.type, this._map, i2));
          }
          click(e2, t2) {
            this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new cr(e2.type, this._map, e2)));
          }
          dblclick(e2) {
            return this._firePreventable(new cr(e2.type, this._map, e2));
          }
          mouseover(e2) {
            this._map.fire(new cr(e2.type, this._map, e2));
          }
          mouseout(e2) {
            this._map.fire(new cr(e2.type, this._map, e2));
          }
          touchstart(e2) {
            return this._firePreventable(new hr(e2.type, this._map, e2));
          }
          touchmove(e2) {
            this._map.fire(new hr(e2.type, this._map, e2));
          }
          touchend(e2) {
            this._map.fire(new hr(e2.type, this._map, e2));
          }
          touchcancel(e2) {
            this._map.fire(new hr(e2.type, this._map, e2));
          }
          _firePreventable(e2) {
            if (this._map.fire(e2), e2.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class dr {
          constructor(e2) {
            this._map = e2;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e2) {
            this._map.fire(new cr(e2.type, this._map, e2));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e2) {
            this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new cr(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class pr {
          constructor(e2, t2) {
            this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e2, t2) {
            this.isEnabled() && e2.shiftKey && 0 === e2.button && (h(), this._startPos = this._lastPos = t2, this._active = true);
          }
          mousemoveWindow(e2, t2) {
            if (!this._active) return;
            const i2 = t2, o2 = this._startPos, r3 = this._lastPos;
            if (!o2 || !r3 || r3.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance) return;
            this._lastPos = i2, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
            const s2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), l2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${s2}px,${l2}px)`, this._box.style.width = a2 - s2 + "px", this._box.style.height = c2 - l2 + "px");
            });
          }
          mouseupWindow(t2, i2) {
            if (!this._active) return;
            const o2 = this._startPos, r3 = i2;
            if (o2 && 0 === t2.button) {
              if (this.reset(), d(), o2.x !== r3.x || o2.y !== r3.y) return this._map.fire(new e.Event("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r3, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t2);
            }
          }
          keydown(e2) {
            this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t2, i2) {
            return this._map.fire(new e.Event(t2, { originalEvent: i2 }));
          }
        }
        function mr(e2, t2) {
          const i2 = {};
          for (let o2 = 0; o2 < e2.length; o2++) i2[e2[o2].identifier] = t2[o2];
          return i2;
        }
        class fr {
          constructor(e2) {
            this.reset(), this.numTouches = e2.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t2, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
              const i3 = new e.pointGeometry(0, 0);
              for (const e2 of t3) i3._add(e2);
              return i3.div(t3.length);
            }(i2), this.touches = mr(o2, i2)));
          }
          touchmove(e2, t2, i2) {
            if (this.aborted || !this.centroid) return;
            const o2 = mr(i2, t2);
            for (const e3 in this.touches) {
              const t3 = this.touches[e3], i3 = o2[e3];
              (!i3 || i3.dist(t3) > 30) && (this.aborted = true);
            }
          }
          touchend(e2, t2, i2) {
            if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const e3 = !this.aborted && this.centroid;
              if (this.reset(), e3) return e3;
            }
          }
        }
        class gr {
          constructor(e2) {
            this.singleTap = new fr(e2), this.numTaps = e2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e2, t2, i2) {
            this.singleTap.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this.singleTap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this.singleTap.touchend(e2, t2, i2);
            if (o2) {
              const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps) return this.reset(), o2;
            }
          }
        }
        class vr {
          constructor() {
            this._zoomIn = new gr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gr({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e2, t2, i2) {
            this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this._zoomIn.touchend(e2, t2, i2), r3 = this._zoomOut.touchend(e2, t2, i2);
            return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r3 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r3) }, { originalEvent: e2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const xr = { 0: 1, 2: 2 };
        class yr {
          constructor(e2) {
            this.reset(), this._clickTolerance = e2.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e2, t2) {
            return false;
          }
          _move(e2, t2) {
            return {};
          }
          mousedown(e2, t2) {
            if (this._lastPoint) return;
            const i2 = f(e2);
            this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
          }
          mousemoveWindow(e2, t2) {
            const i2 = this._lastPoint;
            if (i2) {
              if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                const i3 = xr[t3];
                return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
              }(e2, this._eventButton)) this.reset();
              else if (this._moved || !(t2.dist(i2) < this._clickTolerance)) return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
            }
          }
          mouseupWindow(e2) {
            this._lastPoint && f(e2) === this._eventButton && (this._moved && d(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class br extends yr {
          mousedown(e2, t2) {
            super.mousedown(e2, t2), this._lastPoint && (this._active = true);
          }
          _correctButton(e2, t2) {
            return 0 === t2 && !e2.ctrlKey;
          }
          _move(e2, t2) {
            return { around: t2, panDelta: t2.sub(e2) };
          }
        }
        class wr extends yr {
          _correctButton(e2, t2) {
            return 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = 0.8 * (t2.x - e2.x);
            if (i2) return this._active = true, { bearingDelta: i2 };
          }
          contextmenu(e2) {
            e2.preventDefault();
          }
        }
        class Tr extends yr {
          _correctButton(e2, t2) {
            return 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = -0.5 * (t2.y - e2.y);
            if (i2) return this._active = true, { pitchDelta: i2 };
          }
          contextmenu(e2) {
            e2.preventDefault();
          }
        }
        class Er {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
          }
          touchstart(e2, t2, i2) {
            return this._calculateTransform(e2, t2, i2);
          }
          touchmove(t2, i2, o2) {
            if (this._active && !(o2.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o2.length && !e.isFullscreen()) return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
            }
          }
          touchend(e2, t2, i2) {
            this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t2, i2, o2) {
            o2.length > 0 && (this._active = true);
            const r3 = mr(o2, i2), n2 = new e.pointGeometry(0, 0), s2 = new e.pointGeometry(0, 0);
            let a2 = 0;
            for (const e2 in r3) {
              const t3 = r3[e2], i3 = this._touches[e2];
              i3 && (n2._add(t3), s2._add(t3.sub(i3)), a2++, r3[e2] = t3);
            }
            if (this._touches = r3, a2 < this._minTouches || !s2.mag()) return;
            const l2 = s2.div(a2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(a2), panDelta: l2 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 500);
          }
        }
        class Cr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e2) {
          }
          _move(e2, t2, i2) {
            return {};
          }
          touchstart(e2, t2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
          }
          touchmove(e2, t2, i2) {
            const o2 = this._firstTwoTouches;
            if (!o2) return;
            e2.preventDefault();
            const [r3, n2] = o2, s2 = Mr(i2, t2, r3), a2 = Mr(i2, t2, n2);
            if (!s2 || !a2) return;
            const l2 = this._aroundCenter ? null : s2.add(a2).div(2);
            return this._move([s2, a2], l2, e2);
          }
          touchend(e2, t2, i2) {
            if (!this._firstTwoTouches) return;
            const [o2, r3] = this._firstTwoTouches, n2 = Mr(i2, t2, o2), s2 = Mr(i2, t2, r3);
            n2 && s2 || (this._active && d(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e2) {
            this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Mr(e2, t2, i2) {
          for (let o2 = 0; o2 < e2.length; o2++) if (e2[o2].identifier === i2) return t2[o2];
        }
        function Ir(e2, t2) {
          return Math.log(e2 / t2) / Math.LN2;
        }
        class Sr extends Cr {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e2) {
            this._startDistance = this._distance = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._distance;
            if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Ir(this._distance, i2), pinchAround: t2 };
          }
        }
        function Dr(e2, t2) {
          return 180 * e2.angleWith(t2) / Math.PI;
        }
        class Lr extends Cr {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e2) {
            this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._vector;
            if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: Dr(this._vector, i2), pinchAround: t2 };
          }
          _isBelowThreshold(e2) {
            this._minDiameter = Math.min(this._minDiameter, e2.mag());
            const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
            if (!i2) return false;
            const o2 = Dr(e2, i2);
            return Math.abs(o2) < t2;
          }
        }
        function Ar(e2) {
          return Math.abs(e2.y) > Math.abs(e2.x);
        }
        class zr extends Cr {
          constructor(e2) {
            super(), this._map = e2;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e2) {
            this._lastPoints = e2, Ar(e2[0].sub(e2[1])) && (this._valid = false);
          }
          _move(t2, i2, o2) {
            const r3 = this._lastPoints;
            if (!r3) return;
            const n2 = t2[0].sub(r3[0]), s2 = t2[1].sub(r3[1]);
            return this._map._cooperativeGestures && !e.isFullscreen() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n2, s2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (n2.y + s2.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e2, t2, i2) {
            if (void 0 !== this._valid) return this._valid;
            const o2 = e2.mag() >= 2, r3 = t2.mag() >= 2;
            if (!o2 && !r3) return;
            if (!o2 || !r3) return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const n2 = e2.y > 0 == t2.y > 0;
            return Ar(e2) && Ar(t2) && n2;
          }
        }
        const Pr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Rr {
          constructor() {
            const e2 = Pr;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e2) {
            if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
            let t2 = 0, i2 = 0, o2 = 0, r3 = 0, n2 = 0;
            switch (e2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t2 = -1;
                break;
              case 37:
                e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r3 = -1);
                break;
              case 39:
                e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r3 = 1);
                break;
              case 38:
                e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n2 = -1);
                break;
              case 40:
                e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s2) => {
              const a2 = s2.getZoom();
              s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Or, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + o2 * this._pitchStep, offset: [-r3 * this._panStep, -n2 * this._panStep], center: s2.getCenter() }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Or(e2) {
          return e2 * (2 - e2);
        }
        const Br = 4.000244140625;
        class kr {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e2) {
            this._defaultZoomRate = e2;
          }
          setWheelZoomRate(e2) {
            this._wheelZoomRate = e2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t2) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.isFullscreen())) return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i2 = t2.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
            const o2 = e.exported.now(), r3 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i2 && i2 % Br == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r3 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r3 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
          }
          _onTimeout(e2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
          }
          _start(e2) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t2 = p(this._el, e2);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const t2 = this._map.transform;
            "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
            if (0 !== this._delta) {
              const e2 = "wheel" === this._type && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
              let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
              this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
              const r4 = i2(), n3 = Math.pow(2, r4), s3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : n3;
              this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(s3 * o3))), "wheel" === this._type && (this._startZoom = r4, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r3 = this._startZoom, n2 = this._easing;
            let s2, a2 = false;
            if ("wheel" === this._type && r3 && n2) {
              const t3 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n2(t3);
              s2 = e.number(r3, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
            } else s2 = o2, a2 = true;
            return this._active = true, a2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !a2, zoomDelta: s2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t2) {
            let i2 = e.ease;
            if (this._prevEase) {
              const t3 = this._prevEase, o2 = (e.exported.now() - t3.start) / t3.duration, r3 = t3.easing(o2 + 0.01) - t3.easing(o2), n2 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
              i2 = e.bezier(n2, s2, 0.25, 1);
            }
            return this._prevEase = { start: e.exported.now(), duration: t2, easing: i2 }, i2;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 200);
          }
        }
        class Fr {
          constructor(e2, t2) {
            this._clickZoom = e2, this._tapZoom = t2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Ur {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e2, t2) {
            return e2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Nr {
          constructor() {
            this._tap = new gr({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e2, t2, i2) {
            this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
          }
          touchmove(e2, t2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch) return;
                const o2 = t2[0], r3 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r3 / 128 };
              }
            } else this._tap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Gr {
          constructor(e2, t2, i2) {
            this._el = e2, this._mousePan = t2, this._touchPan = i2;
          }
          enable(e2) {
            this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class jr {
          constructor(e2, t2, i2) {
            this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Zr {
          constructor(e2, t2, i2, o2) {
            this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e2) {
            this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Vr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
        class Wr extends e.Event {
        }
        class Xr {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t2, i2) {
            const o2 = e.sub([], i2, t2);
            this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
          }
          projectRay(t2) {
            e.div(t2, t2, this.constants), e.normalize(t2, t2), e.mul$1(t2, t2, this.constants);
            const i2 = e.scale$2([], t2, this.radius);
            if (i2[2] > 0) {
              const t3 = e.scale$2([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale$2([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r3 = e.add([], i2, e.scale$2([], e.sub([], e.add([], o2, t3), i2), 2));
              i2[0] = r3[0], i2[1] = r3[1];
            }
            return i2;
          }
        }
        function qr(e2) {
          return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
        }
        class $r {
          constructor(t2, i2) {
            this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
            const o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
            for (const [t3, i3, o3] of this._listeners) t3.addEventListener(i3, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
          }
          destroy() {
            for (const [t2, i2, o2] of this._listeners) t2.removeEventListener(i2, t2 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
          }
          _addDefaultHandlers(e2) {
            const t2 = this._map, i2 = t2.getCanvasContainer();
            this._add("mapEvent", new _r(t2, e2));
            const o2 = t2.boxZoom = new pr(t2, e2);
            this._add("boxZoom", o2);
            const r3 = new vr(), n2 = new Ur();
            t2.doubleClickZoom = new Fr(n2, r3), this._add("tapZoom", r3), this._add("clickZoom", n2);
            const s2 = new Nr();
            this._add("tapDragZoom", s2);
            const a2 = t2.touchPitch = new zr(t2);
            this._add("touchPitch", a2);
            const l2 = new wr(e2), c2 = new Tr(e2);
            t2.dragRotate = new jr(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            const h2 = new br(e2), u2 = new Er(t2, e2);
            t2.dragPan = new Gr(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
            const _2 = new Lr(), d2 = new Sr();
            t2.touchZoomRotate = new Zr(i2, d2, _2, s2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t2));
            const p2 = t2.scrollZoom = new kr(t2, this);
            this._add("scrollZoom", p2, ["mousePan"]);
            const m2 = t2.keyboard = new Rr();
            this._add("keyboard", m2);
            for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
          }
          _add(e2, t2, i2) {
            this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
          }
          stop(e2) {
            if (!this._updatingCamera) {
              for (const { handler: e3 } of this._handlers) e3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Vr(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e2, t2, i2) {
            for (const o2 in e2) if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0)) return true;
            return false;
          }
          handleWindowEvent(e2) {
            this.handleEvent(e2, `${e2.type}Window`);
          }
          _getMapTouches(e2) {
            const t2 = [];
            for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
            return t2;
          }
          handleEvent(e2, t2) {
            this._updatingCamera = true;
            const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, r3 = { needsRenderFrame: false }, n2 = {}, s2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? m(this._el, a2) : i2 ? void 0 : p(this._el, e2);
            for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
              if (!c3.isEnabled()) continue;
              let u2;
              this._blockedByActive(s2, h3, i3) ? c3.reset() : c3[t2 || e2.type] && (u2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(r3, n2, u2, i3, o2), u2 && u2.needsRenderFrame && this._triggerRenderFrame()), (u2 || c3.isActive()) && (s2[i3] = c3);
            }
            const c2 = {};
            for (const e3 in this._previousActiveHandlers) s2[e3] || (c2[e3] = o2);
            this._previousActiveHandlers = s2, (Object.keys(c2).length || qr(r3)) && (this._changes.push([r3, n2, c2]), this._triggerRenderFrame()), (Object.keys(s2).length || qr(r3)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h2 } = r3;
            h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
          }
          mergeHandlerResult(t2, i2, o2, r3, n2) {
            if (!o2) return;
            e.extend(t2, o2);
            const s2 = { handlerName: r3, originalEvent: o2.originalEvent || n2 };
            void 0 !== o2.zoomDelta && (i2.zoom = s2), void 0 !== o2.panDelta && (i2.drag = s2), void 0 !== o2.pitchDelta && (i2.pitch = s2), void 0 !== o2.bearingDelta && (i2.rotate = s2);
          }
          _applyChanges() {
            const t2 = {}, i2 = {}, o2 = {};
            for (const [r3, n2, s2] of this._changes) r3.panDelta && (t2.panDelta = (t2.panDelta || new e.pointGeometry(0, 0))._add(r3.panDelta)), r3.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r3.pitchDelta), void 0 !== r3.around && (t2.around = r3.around), void 0 !== r3.aroundCoord && (t2.aroundCoord = r3.aroundCoord), void 0 !== r3.pinchAround && (t2.pinchAround = r3.pinchAround), r3.noInertia && (t2.noInertia = r3.noInertia), e.extend(i2, n2), e.extend(o2, s2);
            this._updateMapTransform(t2, i2, o2), this._changes = [];
          }
          _updateMapTransform(t2, i2, o2) {
            const r3 = this._map, n2 = r3.transform, s2 = (e2) => [e2.x, e2.y, e2.z];
            if (((e2) => {
              const t3 = this._eventsInProgress.drag;
              return t3 && !this._handlersById[t3.handlerName].isActive();
            })() && !qr(t2)) {
              const e2 = n2.zoom;
              n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e2 !== n2.zoom && this._map._update(true);
            }
            if (n2._isCameraConstrained && r3._stop(true), !qr(t2)) return void this._fireEvents(i2, o2, true);
            let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, aroundCoord: _2, pinchAround: d2 } = t2;
            n2._isCameraConstrained && (l2 > 0 && (l2 = 0), n2._isCameraConstrained = false), void 0 !== d2 && (u2 = d2), (l2 || ((e2) => i2.drag && !this._eventsInProgress.drag)()) && u2 && (this._dragOrigin = s2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r3._stop(true), u2 = u2 || r3.transform.centerPoint, c2 && (n2.bearing += c2), h2 && (n2.pitch += h2), n2._updateCameraState();
            const p2 = [0, 0, 0];
            if (a2) if ("mercator" === n2.projection.name) {
              const e2 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2).dir), t3 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2.sub(a2)).dir);
              p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
            } else {
              const t3 = n2.pointCoordinate(u2);
              if ("globe" === n2.projection.name) {
                a2 = a2.rotate(-n2.angle);
                const i3 = n2._pixelsPerMercatorPixel / n2.worldSize;
                p2[0] = -a2.x * e.mercatorScale(e.latFromMercatorY(t3.y)) * i3, p2[1] = -a2.y * e.mercatorScale(n2.center.lat) * i3;
              } else {
                const e2 = n2.pointCoordinate(u2.sub(a2));
                t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
              }
            }
            const m2 = n2.zoom, f2 = [0, 0, 0];
            if (l2) {
              const t3 = s2(_2 || n2.pointCoordinate3D(u2)), i3 = { dir: e.normalize([], e.sub([], t3, n2._camera.position)) };
              if (i3.dir[2] < 0) {
                const o3 = n2.zoomDeltaToMovement(t3, l2);
                e.scale$2(f2, i3.dir, o3);
              }
            }
            const g2 = e.add(p2, p2, f2);
            n2._translateCameraConstrained(g2), l2 && Math.abs(n2.zoom - m2) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
          }
          _fireEvents(t2, i2, o2) {
            const r3 = Vr(this._eventsInProgress), n2 = Vr(t2), s2 = {};
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._eventsInProgress[e2] || (s2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
            }
            !r3 && n2 && this._fireEvent("movestart", n2.originalEvent);
            for (const e2 in s2) this._fireEvent(e2, s2[e2]);
            n2 && this._fireEvent("move", n2.originalEvent);
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._fireEvent(e2, i3);
            }
            const a2 = {};
            let l2;
            for (const e2 in this._eventsInProgress) {
              const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
              this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, a2[`${e2}end`] = l2);
            }
            for (const e2 in a2) this._fireEvent(e2, a2[e2]);
            const c2 = Vr(this._eventsInProgress);
            if (o2 && (r3 || n2) && !c2) {
              this._updatingCamera = true;
              const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
              t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t2, i2) {
            this._map.fire(new e.Event(t2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
              this._frameId = void 0, this.handleEvent(new Wr("renderFrame", { timeStamp: e2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Yr extends e.Evented {
          constructor(t2, i2) {
            super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e2, t2) {
            return this.jumpTo({ center: e2 }, t2);
          }
          panBy(t2, i2, o2) {
            return t2 = e.pointGeometry.convert(t2).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t2 }, i2), o2);
          }
          panTo(t2, i2, o2) {
            return this.easeTo(e.extend({ center: t2 }, i2), o2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e2, t2) {
            return this.jumpTo({ zoom: e2 }, t2), this;
          }
          zoomTo(t2, i2, o2) {
            return this.easeTo(e.extend({ zoom: t2 }, i2), o2);
          }
          zoomIn(e2, t2) {
            return this.zoomTo(this.getZoom() + 1, e2, t2), this;
          }
          zoomOut(e2, t2) {
            return this.zoomTo(this.getZoom() - 1, e2, t2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e2, t2) {
            return this.jumpTo({ bearing: e2 }, t2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e2, t2) {
            return this.jumpTo({ padding: e2 }, t2), this;
          }
          rotateTo(t2, i2, o2) {
            return this.easeTo(e.extend({ bearing: t2 }, i2), o2);
          }
          resetNorth(t2, i2) {
            return this.rotateTo(0, e.extend({ duration: 1e3 }, t2), i2), this;
          }
          resetNorthPitch(t2, i2) {
            return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
          }
          snapToNorth(e2, t2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e2, t2) {
            return this.jumpTo({ pitch: e2 }, t2), this;
          }
          cameraForBounds(t2, i2) {
            t2 = e.LngLatBounds.convert(t2);
            const o2 = i2 && i2.bearing || 0, r3 = i2 && i2.pitch || 0, n2 = t2.getNorthWest(), s2 = t2.getSouthEast();
            return this._cameraForBounds(this.transform, n2, s2, o2, r3, i2);
          }
          _extendCameraOptions(t2) {
            const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (t2 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding) {
              const e2 = t2.padding;
              t2.padding = { top: e2, bottom: e2, right: e2, left: e2 };
            }
            return t2.padding = e.extend(i2, t2.padding), t2;
          }
          _minimumAABBFrustumDistance(e2, t2) {
            const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
            return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
          }
          _cameraForBoundsOnGlobe(t2, i2, o2, r3, n2, s2) {
            const a2 = t2.clone(), l2 = this._extendCameraOptions(s2);
            a2.bearing = r3, a2.pitch = n2;
            const c2 = e.LngLat.convert(i2), h2 = e.LngLat.convert(o2), u2 = 0.5 * (c2.lat + h2.lat), _2 = 0.5 * (c2.lng + h2.lng), d2 = e.latLngToECEF(u2, _2), p2 = e.normalize([], d2), m2 = e.normalize([], e.cross([], p2, [0, 1, 0])), f2 = e.cross([], m2, p2), g2 = [m2[0], m2[1], m2[2], 0, f2[0], f2[1], f2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v2 = [d2, e.latLngToECEF(c2.lat, c2.lng), e.latLngToECEF(h2.lat, c2.lng), e.latLngToECEF(h2.lat, h2.lng), e.latLngToECEF(c2.lat, h2.lng), e.latLngToECEF(u2, c2.lng), e.latLngToECEF(u2, h2.lng), e.latLngToECEF(c2.lat, _2), e.latLngToECEF(h2.lat, _2)];
            let x2 = e.Aabb.fromPoints(v2.map((t3) => [e.dot(m2, t3), e.dot(f2, t3), e.dot(p2, t3)]));
            const y2 = e.transformMat4([], x2.center, g2);
            0 === e.squaredLength(y2) && e.set(y2, 0, 0, 1), e.normalize(y2, y2), e.scale$2(y2, y2, e.GLOBE_RADIUS), a2.center = e.ecefToLatLng(y2);
            const b2 = a2.getWorldToCameraMatrix(), w2 = e.invert(new Float64Array(16), b2);
            x2 = e.Aabb.applyTransform(x2, e.multiply([], b2, g2)), e.transformMat4(y2, y2, b2);
            const T2 = 0.5 * (x2.max[2] - x2.min[2]), E2 = this._minimumAABBFrustumDistance(a2, x2), C2 = e.scale$2([], [0, 0, 1], T2), M2 = e.add(C2, y2, C2), I2 = E2 + (0 === a2.pitch ? 0 : e.distance(y2, M2)), S2 = a2.globeCenterInViewSpace, D2 = e.sub([], y2, [S2[0], S2[1], S2[2]]);
            e.normalize(D2, D2), e.scale$2(D2, D2, I2);
            const L2 = e.add([], y2, D2);
            e.transformMat4(L2, L2, w2);
            const A2 = e.earthRadius / e.GLOBE_RADIUS, z2 = e.length(L2), P2 = e.mercatorZfromAltitude(Math.max(z2 * A2 - e.earthRadius, Number.EPSILON), 0), R2 = Math.min(a2.zoomFromMercatorZAdjusted(P2), l2.maxZoom);
            return R2 > 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "mercator" }), a2.zoom = R2, this._cameraForBounds(a2, i2, o2, r3, n2, s2)) : { center: a2.center, zoom: R2, bearing: r3, pitch: n2 };
          }
          queryTerrainElevation(t2, i2) {
            const o2 = this.transform.elevation;
            return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t2), null, i2.exaggerated)) : null;
          }
          _cameraForBounds(t2, i2, o2, r3, n2, s2) {
            if ("globe" === t2.projection.name) return this._cameraForBoundsOnGlobe(t2, i2, o2, r3, n2, s2);
            const a2 = t2.clone(), l2 = this._extendCameraOptions(s2), c2 = a2.padding;
            a2.bearing = r3, a2.pitch = n2;
            const h2 = e.LngLat.convert(i2), u2 = e.LngLat.convert(o2), _2 = new e.LngLat(h2.lng, u2.lat), d2 = new e.LngLat(u2.lng, h2.lat), p2 = a2.project(h2), m2 = a2.project(u2), f2 = this.queryTerrainElevation(h2), g2 = this.queryTerrainElevation(u2), v2 = this.queryTerrainElevation(_2), x2 = this.queryTerrainElevation(d2), y2 = [[p2.x, p2.y, Math.min(f2 || 0, g2 || 0, v2 || 0, x2 || 0)], [m2.x, m2.y, Math.max(f2 || 0, g2 || 0, v2 || 0, x2 || 0)]];
            let b2 = e.Aabb.fromPoints(y2);
            const w2 = a2.getWorldToCameraMatrix(), T2 = e.invert(new Float64Array(16), w2);
            b2 = e.Aabb.applyTransform(b2, w2);
            const E2 = e.sub([], b2.max, b2.min), C2 = c2.left || 0, M2 = c2.right || 0, I2 = c2.bottom || 0, S2 = c2.top || 0, { left: D2, right: L2, top: A2, bottom: z2 } = l2.padding, P2 = 0.5 * (C2 + M2), R2 = 0.5 * (S2 + I2), O2 = Math.min(a2.scaleZoom(a2.scale * Math.min((a2.width - (C2 + M2 + D2 + L2)) / E2[0], (a2.height - (I2 + S2 + z2 + A2)) / E2[1])), l2.maxZoom), B2 = a2.scale / a2.zoomScale(O2);
            b2 = new e.Aabb([b2.min[0] - (D2 + P2) * B2, b2.min[1] - (z2 + R2) * B2, b2.min[2]], [b2.max[0] + (L2 + P2) * B2, b2.max[1] + (A2 + R2) * B2, b2.max[2]]);
            const k2 = 0.5 * E2[2], F2 = this._minimumAABBFrustumDistance(a2, b2), U2 = [0, 0, 1, 0];
            e.transformMat4$1(U2, U2, w2), e.normalize$2(U2, U2);
            const N2 = e.scale$2([], U2, F2 + k2), G2 = e.add([], b2.center, N2), j2 = ("number" == typeof l2.offset.x && "number" == typeof l2.offset.y ? new e.pointGeometry(l2.offset.x, l2.offset.y) : e.pointGeometry.convert(l2.offset)).rotate(-e.degToRad(r3));
            b2.center[0] -= j2.x * B2, b2.center[1] += j2.y * B2, e.transformMat4(b2.center, b2.center, T2), e.transformMat4(G2, G2, T2);
            const Z2 = [b2.center[0], b2.center[1], G2[2] * a2.pixelsPerMeter];
            e.scale$2(Z2, Z2, 1 / a2.worldSize);
            const V2 = e.lngFromMercatorX(Z2[0]), W2 = e.latFromMercatorY(Z2[1]), X2 = Math.min(a2._zoomFromMercatorZ(Z2[2]), l2.maxZoom), q2 = new e.LngLat(V2, W2);
            return a2.mercatorFromTransition && X2 < 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "globe" }), a2.zoom = X2, this._cameraForBounds(a2, i2, o2, r3, n2, s2)) : { center: q2, zoom: X2, bearing: r3, pitch: n2 };
          }
          fitBounds(e2, t2, i2) {
            const o2 = this.cameraForBounds(e2, t2);
            return this._fitInternal(o2, t2, i2);
          }
          fitScreenCoordinates(t2, i2, o2, r3, n2) {
            const s2 = e.pointGeometry.convert(t2), a2 = e.pointGeometry.convert(i2), l2 = new e.pointGeometry(Math.min(s2.x, a2.x), Math.min(s2.y, a2.y)), c2 = new e.pointGeometry(Math.max(s2.x, a2.x), Math.max(s2.y, a2.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s2, a2)) return this;
            const h2 = this.transform.pointLocation3D(l2), u2 = this.transform.pointLocation3D(c2), _2 = this.transform.pointLocation3D(new e.pointGeometry(l2.x, c2.y)), d2 = this.transform.pointLocation3D(new e.pointGeometry(c2.x, l2.y)), p2 = [Math.min(h2.lng, u2.lng, _2.lng, d2.lng), Math.min(h2.lat, u2.lat, _2.lat, d2.lat)], m2 = [Math.max(h2.lng, u2.lng, _2.lng, d2.lng), Math.max(h2.lat, u2.lat, _2.lat, d2.lat)], f2 = r3 && r3.pitch ? r3.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, m2, o2, f2, r3);
            return this._fitInternal(g2, r3, n2);
          }
          _fitInternal(t2, i2, o2) {
            return t2 ? (delete (i2 = e.extend(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
          }
          jumpTo(t2, i2) {
            this.stop();
            const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
            let r3 = false, n2 = false, s2 = false;
            return "zoom" in t2 && o2.zoom !== +t2.zoom && (r3 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.LngLat.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (n2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (s2 = true, o2.pitch = +t2.pitch), null == t2.padding || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r3 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), s2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t2, i2) {
            const o2 = this.transform;
            if (!o2.projection.supportsFreeCamera) return e.warnOnce(Hr), this;
            this.stop();
            const r3 = o2.zoom, n2 = o2.pitch, s2 = o2.bearing;
            o2.setFreeCameraOptions(t2);
            const a2 = r3 !== o2.zoom, l2 = n2 !== o2.pitch, c2 = s2 !== o2.bearing;
            return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), a2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
          }
          easeTo(t2, i2) {
            this._stop(false, t2.easeId), (false === (t2 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t2)).animate || !t2.essential && e.exported.prefersReducedMotion) && (t2.duration = 0);
            const o2 = this.transform, r3 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r3, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = e.pointGeometry.convert(t2.offset);
            let d2, p2, m2;
            if ("globe" === o2.projection.name) {
              const i3 = e.MercatorCoordinate.fromLngLat(o2.center), r4 = _2.rotate(-o2.angle);
              i3.x += r4.x / o2.worldSize, i3.y += r4.y / o2.worldSize;
              const n3 = i3.toLngLat(), s3 = e.LngLat.convert(t2.center || n3);
              this._normalizeCenter(s3), d2 = o2.centerPoint.add(r4), p2 = new e.pointGeometry(i3.x, i3.y).mult(o2.worldSize), m2 = new e.pointGeometry(e.mercatorXfromLng(s3.lng), e.mercatorYfromLat(s3.lat)).mult(o2.worldSize).sub(p2);
            } else {
              d2 = o2.centerPoint.add(_2);
              const i3 = o2.pointLocation(d2), r4 = e.LngLat.convert(t2.center || i3);
              this._normalizeCenter(r4), p2 = o2.project(i3), m2 = o2.project(r4).sub(p2);
            }
            const f2 = o2.zoomScale(l2 - r3);
            let g2, v2;
            t2.around && (g2 = e.LngLat.convert(t2.around), v2 = o2.locationPoint(g2));
            const x2 = this._zooming || l2 !== r3, y2 = this._rotating || n2 !== c2, b2 = this._pitching || h2 !== s2, w2 = !o2.isPaddingEqual(u2), T2 = (o3) => (T3) => {
              if (x2 && (o3.zoom = e.number(r3, l2, T3)), y2 && (o3.bearing = e.number(n2, c2, T3)), b2 && (o3.pitch = e.number(s2, h2, T3)), w2 && (o3.interpolatePadding(a2, u2, T3), d2 = o3.centerPoint.add(_2)), g2) o3.setLocationAtPoint(g2, v2);
              else {
                const e2 = o3.zoomScale(o3.zoom - r3), t3 = l2 > r3 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - T3), n3 = o3.unproject(p2.add(m2.mult(T3 * i3)).mult(e2));
                o3.setLocationAtPoint(o3.renderWorldCopies ? n3.wrap() : n3, d2);
              }
              return t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(T2, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = x2, this._rotating = y2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, E2), this._ease(T2(o2), (e2) => {
              o2.recenterOnTerrain(), this._afterEase(i2, e2);
            }, t2), this;
          }
          _prepareEase(t2, i2, o2 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t2));
          }
          _fireMoveEvents(t2) {
            this.fire(new e.Event("move", t2)), this._zooming && this.fire(new e.Event("zoom", t2)), this._rotating && this.fire(new e.Event("rotate", t2)), this._pitching && this.fire(new e.Event("pitch", t2));
          }
          _afterEase(t2, i2) {
            if (this._easeId && i2 && this._easeId === i2) return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o2 = this._zooming, r3 = this._rotating, n2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t2)), r3 && this.fire(new e.Event("rotateend", t2)), n2 && this.fire(new e.Event("pitchend", t2)), this.fire(new e.Event("moveend", t2));
          }
          flyTo(t2, i2) {
            if (!t2.essential && e.exported.prefersReducedMotion) {
              const o3 = e.pick(t2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o3, i2);
            }
            this.stop(), t2 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t2);
            const o2 = this.transform, r3 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? e.clamp(+t2.zoom, o2.minZoom, o2.maxZoom) : r3, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = o2.zoomScale(l2 - r3), d2 = e.pointGeometry.convert(t2.offset);
            let p2 = o2.centerPoint.add(d2);
            const m2 = o2.pointLocation(p2), f2 = e.LngLat.convert(t2.center || m2);
            this._normalizeCenter(f2);
            const g2 = o2.project(m2), v2 = o2.project(f2).sub(g2);
            let x2 = t2.curve;
            const y2 = Math.max(o2.width, o2.height), b2 = y2 / _2, w2 = v2.mag();
            if ("minZoom" in t2) {
              const i3 = e.clamp(Math.min(t2.minZoom, r3, l2), o2.minZoom, o2.maxZoom), n3 = y2 / o2.zoomScale(i3 - r3);
              x2 = Math.sqrt(n3 / w2 * 2);
            }
            const T2 = x2 * x2;
            function E2(e2) {
              const t3 = (b2 * b2 - y2 * y2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : y2) * T2 * w2);
              return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
            }
            function C2(e2) {
              return (Math.exp(e2) - Math.exp(-e2)) / 2;
            }
            function M2(e2) {
              return (Math.exp(e2) + Math.exp(-e2)) / 2;
            }
            const I2 = E2(0);
            let S2 = function(e2) {
              return M2(I2) / M2(I2 + x2 * e2);
            }, D2 = function(e2) {
              return y2 * ((M2(I2) * (C2(t3 = I2 + x2 * e2) / M2(t3)) - C2(I2)) / T2) / w2;
              var t3;
            }, L2 = (E2(1) - I2) / x2;
            if (Math.abs(w2) < 1e-6 || !isFinite(L2)) {
              if (Math.abs(y2 - b2) < 1e-6) return this.easeTo(t2, i2);
              const e2 = b2 < y2 ? -1 : 1;
              L2 = Math.abs(Math.log(b2 / y2)) / x2, D2 = function() {
                return 0;
              }, S2 = function(t3) {
                return Math.exp(e2 * x2 * t3);
              };
            }
            t2.duration = "duration" in t2 ? +t2.duration : 1e3 * L2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
            const A2 = n2 !== c2, z2 = h2 !== s2, P2 = !o2.isPaddingEqual(u2), R2 = (o3) => (_3) => {
              const m3 = _3 * L2, x3 = 1 / S2(m3);
              o3.zoom = 1 === _3 ? l2 : r3 + o3.scaleZoom(x3), A2 && (o3.bearing = e.number(n2, c2, _3)), z2 && (o3.pitch = e.number(s2, h2, _3)), P2 && (o3.interpolatePadding(a2, u2, _3), p2 = o3.centerPoint.add(d2));
              const y3 = 1 === _3 ? f2 : o3.unproject(g2.add(v2.mult(D2(m3))).mult(x3));
              return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(R2, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            return this._zooming = true, this._rotating = A2, this._pitching = z2, this._padding = P2, this._prepareEase(i2, false), this._ease(R2(o2), () => this._afterEase(i2), t2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e2, t2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e3 = this._onEaseEnd;
              this._onEaseEnd = void 0, e3.call(this, t2);
            }
            if (!e2) {
              const e3 = this.handlers;
              e3 && e3.stop(false);
            }
            return this;
          }
          _ease(t2, i2, o2) {
            false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t2 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
            i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t2, i2) {
            t2 = e.wrap(t2, -180, 180);
            const o2 = Math.abs(t2 - i2);
            return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
          }
          _normalizeCenter(e2) {
            const t2 = this.transform;
            if (!t2.renderWorldCopies || t2.maxBounds) return;
            const i2 = e2.lng - t2.center.lng;
            e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          _emulate(e2, t2, i2) {
            const o2 = Math.ceil(15 * t2 / 1e3), r3 = [], n2 = e2(i2.clone());
            for (let e3 = 0; e3 <= o2; e3++) {
              const t3 = n2(e3 / o2);
              r3.push(t3.clone());
            }
            return r3;
          }
        }
        class Kr {
          constructor(t2 = {}) {
            this.options = t2, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e2) {
            const t2 = this.options && this.options.compact;
            return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e2, t2) {
            const i2 = this._map._getUIString(`AttributionControl.${t2}`);
            e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t2 = this._editLink;
            t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
            if (t2) {
              const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
              t2.href = `${e.config.FEEDBACK_URL}/${o2}#${er(this._map, true)}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
            }
          }
          _updateData(e2) {
            !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e2 = [];
            if (this._map.style.stylesheet) {
              const e3 = this._map.style.stylesheet;
              this.styleOwner = e3.owner, this.styleId = e3.id;
            }
            const t2 = this._map.style._sourceCaches;
            for (const i3 in t2) {
              const o2 = t2[i3];
              if (o2.used) {
                const t3 = o2.getSource();
                t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
              }
            }
            e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
              for (let o2 = i3 + 1; o2 < e2.length; o2++) if (e2[o2].indexOf(t3) >= 0) return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
            const i2 = e2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Jr {
          constructor() {
            e.bindAll(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e2) {
            this._map = e2, this._container = n("div", "mapboxgl-ctrl");
            const t2 = n("a", "mapboxgl-ctrl-logo");
            return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e2) {
            e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style) return true;
            const e2 = this._map.style._sourceCaches;
            if (0 === Object.entries(e2).length) return true;
            for (const t2 in e2) {
              const i2 = e2[t2].getSource();
              if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo) return false;
            }
            return true;
          }
          _updateCompact() {
            const e2 = this._container.children;
            if (e2.length) {
              const t2 = e2[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
            }
          }
        }
        class Qr {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e2) {
            const t2 = ++this._id;
            return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
          }
          remove(e2) {
            const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
            for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
          }
          run(e2 = 0) {
            const t2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function en(t2, i2, o2) {
          if (t2 = new e.LngLat(t2.lng, t2.lat), i2) {
            const r3 = new e.LngLat(t2.lng - 360, t2.lat), n2 = new e.LngLat(t2.lng + 360, t2.lat), s2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
            o2.locationPoint(r3).distSqr(i2) < a2 && (l2 || Math.abs(r3.lng - o2.center.lng) < s2) ? t2 = r3 : o2.locationPoint(n2).distSqr(i2) < a2 && (l2 || Math.abs(n2.lng - o2.center.lng) < s2) && (t2 = n2);
          }
          for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
            const e2 = o2.locationPoint(t2);
            if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height) break;
            t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
          }
          return t2;
        }
        const tn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class on extends e.Evented {
          constructor(t2, i2) {
            if (super(), (t2 instanceof e.window.HTMLElement || i2) && (t2 = e.extend({ element: t2 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element) this._element = t2.element, this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = n("div");
              const i3 = 41, o3 = 27, r3 = s("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), a2 = s("radialGradient", { id: "shadowGradient" }, s("defs", {}, r3));
              s("stop", { offset: "10%", "stop-opacity": 0.4 }, a2), s("stop", { offset: "100%", "stop-opacity": 0.05 }, a2), s("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), s("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), s("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), s("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
              e2.preventDefault();
            }), this._element.addEventListener("mousedown", (e2) => {
              e2.preventDefault();
            });
            const o2 = this._element.classList;
            for (const e2 in tn) o2.remove(`mapboxgl-marker-anchor-${e2}`);
            o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
          }
          addTo(e2) {
            return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
          }
          remove() {
            const e2 = this._map;
            return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
              if (!("offset" in e2.options)) {
                const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
              }
              this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e2) {
            const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
            "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
          }
          _onMapClick(e2) {
            const t2 = e2.originalEvent.target, i2 = this._element;
            this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e2 = this._popup;
            return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e2 = this._map, t2 = this._pos;
            if (!e2 || !t2) return false;
            const i2 = e2.unproject(t2), o2 = e2.getFreeCameraOptions();
            if (!o2.position) return false;
            const r3 = o2.position.toLngLat();
            return r3.distanceTo(i2) < 0.9 * r3.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t2 = this._map;
            if (!t2) return;
            const i2 = this._pos;
            if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height) return void this._clearFadeTimer();
            const o2 = t2.unproject(i2);
            let r3;
            t2._showingGlobe() && e.isLngLatBehindGlobe(t2.transform, this._lngLat) ? r3 = 0 : (r3 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r3 *= this._occludedOpacity)), this._element.style.opacity = `${r3}`, this._element.style.pointerEvents = r3 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r3), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e2 = this._pos;
            if (!e2 || !this._map) return;
            const t2 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${tn[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
          }
          _calculateXYTransform() {
            const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
            if (!i2 || !t2 || "map" !== o2) return "";
            if (!i2._showingGlobe()) {
              const e2 = i2.getPitch();
              return e2 ? `rotateX(${e2}deg)` : "";
            }
            const r3 = e.radToDeg(e.globeTiltAtLngLat(i2.transform, this._lngLat)), n2 = t2.sub(e.globeCenterToScreenPoint(i2.transform)), s2 = Math.abs(n2.x) + Math.abs(n2.y);
            if (0 === s2) return "";
            const a2 = r3 / s2;
            return `rotateX(${-n2.y * a2}deg) rotateY(${n2.x * a2}deg)`;
          }
          _calculateZTransform() {
            const t2 = this._pos, i2 = this._map;
            if (!i2 || !t2) return "";
            let o2 = 0;
            const r3 = this.getRotationAlignment();
            if ("map" === r3) if (i2._showingGlobe()) {
              const t3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r4 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
              o2 = e.radToDeg(Math.atan2(r4.y, r4.x)) - 90;
            } else o2 = -i2.getBearing();
            else if ("horizon" === r3) {
              const r4 = e.smoothstep(4, 6, i2.getZoom()), n2 = e.globeCenterToScreenPoint(i2.transform);
              n2.y += r4 * i2.transform.height;
              const s2 = t2.sub(n2), a2 = e.radToDeg(Math.atan2(s2.y, s2.x));
              o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - r4);
            }
            return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
          }
          _update(t2) {
            e.window.cancelAnimationFrame(this._updateFrameId);
            const i2 = this._map;
            i2 && (i2.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), true === t2 ? this._updateFrameId = e.window.requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t2) {
            return this._offset = e.pointGeometry.convert(t2), this._update(), this;
          }
          _onMove(t2) {
            const i2 = this._map;
            if (!i2) return;
            const o2 = this._pointerdownPos, r3 = this._positionDelta;
            if (o2 && r3) {
              if (!this._isDragging) {
                const e2 = this._clickTolerance || i2._clickTolerance;
                if (t2.point.dist(o2) < e2) return;
                this._isDragging = true;
              }
              this._pos = t2.point.sub(r3), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t2 = this._map;
            t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(e2) {
            const t2 = this._map, i2 = this._pos;
            t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
          }
          setDraggable(e2) {
            this._draggable = !!e2;
            const t2 = this._map;
            return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e2) {
            return this._rotation = e2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e2) {
            return this._rotationAlignment = e2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e2) {
            return this._pitchAlignment = e2 || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e2) {
            return this._occludedOpacity = e2 || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const rn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, nn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function sn(t2 = new e.pointGeometry(0, 0), i2 = "bottom") {
          if ("number" == typeof t2) {
            const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
            switch (i2) {
              case "top":
                return new e.pointGeometry(0, t2);
              case "top-left":
                return new e.pointGeometry(o2, o2);
              case "top-right":
                return new e.pointGeometry(-o2, o2);
              case "bottom":
                return new e.pointGeometry(0, -t2);
              case "bottom-left":
                return new e.pointGeometry(o2, -o2);
              case "bottom-right":
                return new e.pointGeometry(-o2, -o2);
              case "left":
                return new e.pointGeometry(t2, 0);
              case "right":
                return new e.pointGeometry(-t2, 0);
            }
            return new e.pointGeometry(0, 0);
          }
          return t2 instanceof e.pointGeometry || Array.isArray(t2) ? e.pointGeometry.convert(t2) : e.pointGeometry.convert(t2[i2] || [0, 0]);
        }
        class an {
          constructor(e2) {
            this.jumpTo(e2);
          }
          getValue(t2) {
            if (t2 <= this._startTime) return this._start;
            if (t2 >= this._endTime) return this._end;
            const i2 = e.easeCubicInOut((t2 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i2) + this._end * i2;
          }
          isEasing(e2) {
            return e2 >= this._startTime && e2 <= this._endTime;
          }
          jumpTo(e2) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
          }
          easeTo(e2, t2, i2) {
            this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
          }
        }
        const ln = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, cn = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, hn = { showCompass: true, showZoom: true, visualizePitch: false };
        class un {
          constructor(t2, i2, o2 = false) {
            this._clickTolerance = 10, this.element = i2, this.mouseRotate = new wr({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new Tr({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
          }
          down(e2, t2) {
            this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), h();
          }
          move(e2, t2) {
            const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), r3 = o2 && o2.bearingDelta;
            if (r3 && i2.setBearing(i2.getBearing() + r3), this.mousePitch) {
              const o3 = this.mousePitch.mousemoveWindow(e2, t2), r4 = o3 && o3.pitchDelta;
              r4 && i2.setPitch(i2.getPitch() + r4);
            }
          }
          off() {
            const e2 = this.element;
            e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            u(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t2) {
            this.down(e.extend({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), p(this.element, t2)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e2) {
            this.move(e2, p(this.element, e2));
          }
          mouseup(e2) {
            this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
          }
          touchstart(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
          }
          touchmove(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
          }
          touchend(e2) {
            0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const _n = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, dn = { maxWidth: 100, unit: "metric" };
        function pn(e2, t2, i2) {
          const o2 = mn(t2), r3 = o2 / t2, n2 = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i2];
          this._map._requestDomTask(() => {
            this._container.style.width = e2 * r3 + "px", this._container.innerHTML = `${o2}&nbsp;${n2}`;
          });
        }
        function mn(e2) {
          const t2 = Math.pow(10, `${Math.floor(e2)}`.length - 1);
          let i2 = e2 / t2;
          return i2 = i2 >= 10 ? 10 : i2 >= 5 ? 5 : i2 >= 3 ? 3 : i2 >= 2 ? 2 : i2 >= 1 ? 1 : function(e3) {
            const t3 = Math.pow(10, Math.ceil(-Math.log(e3) / Math.LN10));
            return Math.round(e3 * t3) / t3;
          }(i2), t2 * i2;
        }
        const fn = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends Yr {
          constructor(t2) {
            if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t2 = e.extend({}, cn, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t2.minPitch && t2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != t2.maxPitch && t2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t2.antialias && e.isSafariWithAntialiasingBug(e.window) && (t2.antialias = false, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._useWebGL2 = t2.useWebGL2, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, ln, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e.RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, "string" == typeof t2.container) {
              if (this._container = e.window.document.getElementById(t2.container), !this._container) throw new Error(`Container '${t2.container}' not found.`);
            } else {
              if (!(t2.container instanceof e.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t2.container;
            }
            if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new $r(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this._hash = t2.hash && new Qo("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.extend({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), t2.attributionControl && this.addControl(new Kr({ customAttribution: t2.customAttribution })), this._logoControl = new Jr(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t3) => {
              this._update("style" === t3.dataType), this.fire(new e.Event(`${t3.dataType}data`, t3));
            }), this.on("dataloading", (t3) => {
              this.fire(new e.Event(`${t3.dataType}dataloading`, t3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t2, i2) {
            if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o2 = t2.onAdd(this);
            this._controls.push(t2);
            const r3 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? r3.insertBefore(o2, r3.firstChild) : r3.appendChild(o2), this;
          }
          removeControl(t2) {
            if (!t2 || !t2.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(t2);
            return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
          }
          hasControl(e2) {
            return this._controls.indexOf(e2) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t2) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i2 = !this._moving;
            return i2 && this.fire(new e.Event("movestart", t2)).fire(new e.Event("move", t2)), this.fire(new e.Event("resize", t2)), i2 && this.fire(new e.Event("moveend", t2)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t2) {
            return this.transform.setMaxBounds(e.LngLatBounds.convert(t2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom) return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom) return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch) return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = null == t2 ? 85 : t2) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch) return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e2) {
            return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(t2) {
            return "auto" === t2 ? e.window.navigator.language : Array.isArray(t2) ? 0 === t2.length ? void 0 : t2.map((t3) => "auto" === t3 ? e.window.navigator.language : t3) : t2;
          }
          setLanguage(e2) {
            const t2 = this._parseLanguage(e2);
            if (!this.style || t2 === this._language) return this;
            this._language = t2, this.style._reloadSources();
            for (const e3 of this._controls) e3._setLanguage && e3._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e2) {
            return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style._reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e2) {
            return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name) return;
            const t2 = this.transform, i2 = t2.projection.name;
            let o2;
            "globe" === i2 && t2.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(e2, t2) {
            return this._updateProjection(e2 || t2 || { name: "mercator" });
          }
          _updateProjection(t2) {
            let i2;
            if (i2 = "globe" === t2.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2) {
              this.painter.clearBackgroundTiles();
              for (const e2 in this.style._sourceCaches) this.style._sourceCaches[e2].clearTiles();
              this._update(true), this._forceMarkerAndPopupUpdate(true);
            }
            return this;
          }
          project(t2) {
            return this.transform.locationPoint3D(e.LngLat.convert(t2));
          }
          unproject(t2) {
            return this.transform.pointLocation3D(e.pointGeometry.convert(t2));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e2, t2, i2) {
            if ("mouseenter" === e2 || "mouseover" === e2) {
              let o2 = false;
              const r3 = (r4) => {
                const n3 = t2.filter((e3) => this.getLayer(e3)), s2 = n3.length ? this.queryRenderedFeatures(r4.point, { layers: n3 }) : [];
                s2.length ? o2 || (o2 = true, i2.call(this, new cr(e2, this, r4.originalEvent, { features: s2 }))) : o2 = false;
              }, n2 = () => {
                o2 = false;
              };
              return { layers: new Set(t2), listener: i2, delegates: { mousemove: r3, mouseout: n2 } };
            }
            if ("mouseleave" === e2 || "mouseout" === e2) {
              let o2 = false;
              const r3 = (r4) => {
                const n3 = t2.filter((e3) => this.getLayer(e3));
                (n3.length ? this.queryRenderedFeatures(r4.point, { layers: n3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new cr(e2, this, r4.originalEvent)));
              }, n2 = (t3) => {
                o2 && (o2 = false, i2.call(this, new cr(e2, this, t3.originalEvent)));
              };
              return { layers: new Set(t2), listener: i2, delegates: { mousemove: r3, mouseout: n2 } };
            }
            {
              const o2 = (e3) => {
                const o3 = t2.filter((e4) => this.getLayer(e4)), r3 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
                r3.length && (e3.features = r3, i2.call(this, e3), delete e3.features);
              };
              return { layers: new Set(t2), listener: i2, delegates: { [e2]: o2 } };
            }
          }
          on(e2, t2, i2) {
            if (void 0 === i2) return super.on(e2, t2);
            Array.isArray(t2) || (t2 = [t2]);
            const o2 = this._createDelegatedListener(e2, t2, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
            for (const e3 in o2.delegates) this.on(e3, o2.delegates[e3]);
            return this;
          }
          once(e2, t2, i2) {
            if (void 0 === i2) return super.once(e2, t2);
            Array.isArray(t2) || (t2 = [t2]);
            const o2 = this._createDelegatedListener(e2, t2, i2);
            for (const e3 in o2.delegates) this.once(e3, o2.delegates[e3]);
            return this;
          }
          off(e2, t2, i2) {
            if (void 0 === i2) return super.off(e2, t2);
            t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
            const o2 = (e3, t3) => {
              if (e3.size !== t3.size) return false;
              for (const i3 of e3) if (!t3.has(i3)) return false;
              return true;
            }, r3 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
            return r3 && ((e3) => {
              for (let r4 = 0; r4 < e3.length; r4++) {
                const n2 = e3[r4];
                if (n2.listener === i2 && o2(n2.layers, t2)) {
                  for (const e4 in n2.delegates) this.off(e4, n2.delegates[e4]);
                  return e3.splice(r4, 1), this;
                }
              }
            })(r3), this;
          }
          queryRenderedFeatures(t2, i2) {
            return this.style ? (void 0 !== i2 || void 0 === t2 || t2 instanceof e.pointGeometry || Array.isArray(t2) || (i2 = t2, t2 = void 0), this.style.queryRenderedFeatures(t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
          }
          querySourceFeatures(e2, t2) {
            return this.style.querySourceFeatures(e2, t2);
          }
          setStyle(t2, i2) {
            return false !== (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
          }
          _getUIString(e2) {
            const t2 = this._locale[e2];
            if (null == t2) throw new Error(`Missing UI string '${e2}'`);
            return t2;
          }
          _updateStyle(e2, t2) {
            return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new Qt(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t2, i2) {
            if ("string" == typeof t2) {
              const o2 = this._requestManager.normalizeStyleURL(t2), r3 = this._requestManager.transformRequest(o2, e.ResourceType.Style);
              e.getJSON(r3, (t3, o3) => {
                t3 ? this.fire(new e.ErrorEvent(t3)) : o3 && this._updateDiff(o3, i2);
              });
            } else "object" == typeof t2 && this._updateDiff(t2, i2);
          }
          _updateDiff(t2, i2) {
            try {
              this.style.setState(t2) && this._update(true);
            } catch (o2) {
              e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), false);
          }
          addSource(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
          }
          isSourceLoaded(e2) {
            return !!this.style && this.style._isSourceCacheLoaded(e2);
          }
          areTilesLoaded() {
            const e2 = this.style && this.style._sourceCaches;
            for (const t2 in e2) {
              const i2 = e2[t2]._tiles;
              for (const e3 in i2) {
                const t3 = i2[e3];
                if ("loaded" !== t3.state && "errored" !== t3.state) return false;
              }
            }
            return true;
          }
          addSourceType(e2, t2, i2) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
          }
          removeSource(e2) {
            return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
          }
          getSource(e2) {
            return this.style.getSource(e2);
          }
          addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r3 = false, stretchX: n2, stretchY: s2, content: a2 } = {}) {
            if (this._lazyInitEmptyStyle(), i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap) {
              const { width: l2, height: c2, data: h2 } = e.exported.getImageData(i2);
              this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r3, version: 0 });
            } else if (void 0 === i2.width || void 0 === i2.height) this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: l2, height: c2 } = i2, h2 = i2;
              this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2.data)), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r3, version: 0, userImage: h2 }), h2.onAdd && h2.onAdd(this, t2);
            }
          }
          updateImage(t2, i2) {
            const o2 = this.style.getImage(t2);
            if (!o2) return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r3 = i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? e.exported.getImageData(i2) : i2, { width: n2, height: s2 } = r3;
            void 0 !== n2 && void 0 !== s2 ? n2 === o2.data.width && s2 === o2.data.height ? (o2.data.replace(r3.data, !(i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap)), this.style.updateImage(t2, o2)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n2}, ${s2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          }
          hasImage(t2) {
            return t2 ? !!this.style.getImage(t2) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
          }
          removeImage(e2) {
            this.style.removeImage(e2);
          }
          loadImage(t2, i2) {
            e.getImage(this._requestManager.transformRequest(t2, e.ResourceType.Image), (t3, o2) => {
              i2(t3, o2 instanceof e.window.HTMLImageElement ? e.exported.getImageData(o2) : o2);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
          }
          moveLayer(e2, t2) {
            return this.style.moveLayer(e2, t2), this._update(true);
          }
          removeLayer(e2) {
            return this.style.removeLayer(e2), this._update(true);
          }
          getLayer(e2) {
            return this.style.getLayer(e2);
          }
          setLayerZoomRange(e2, t2, i2) {
            return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
          }
          setFilter(e2, t2, i2 = {}) {
            return this.style.setFilter(e2, t2, i2), this._update(true);
          }
          getFilter(e2) {
            return this.style.getFilter(e2);
          }
          setPaintProperty(e2, t2, i2, o2 = {}) {
            return this.style.setPaintProperty(e2, t2, i2, o2), this._update(true);
          }
          getPaintProperty(e2, t2) {
            return this.style.getPaintProperty(e2, t2);
          }
          setLayoutProperty(e2, t2, i2, o2 = {}) {
            return this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true);
          }
          getLayoutProperty(e2, t2) {
            return this.style.getLayoutProperty(e2, t2);
          }
          setLight(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setTerrain(e2) {
            return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e2) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          _queryFogOpacity(t2) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t2), this.transform) : 0;
          }
          setFeatureState(e2, t2) {
            return this.style.setFeatureState(e2, t2), this._update();
          }
          removeFeatureState(e2, t2) {
            return this.style.removeFeatureState(e2, t2), this._update();
          }
          getFeatureState(e2) {
            return this.style.getFeatureState(e2);
          }
          _updateContainerDimensions() {
            if (!this._container) return;
            const t2 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
            let o2, r3, n2, s2 = this._container;
            for (; s2 && (!r3 || !n2); ) {
              const t3 = e.window.getComputedStyle(s2).transform;
              t3 && "none" !== t3 && (o2 = t3.match(/matrix.*\((.+)\)/)[1].split(", "), o2[0] && "0" !== o2[0] && "1" !== o2[0] && (r3 = o2[0]), o2[3] && "0" !== o2[3] && "1" !== o2[3] && (n2 = o2[3])), s2 = s2.parentElement;
            }
            this._containerWidth = r3 ? Math.abs(t2 / r3) : t2, this._containerHeight = n2 ? Math.abs(i2 / n2) : i2;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e2 = this._container;
            e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
            const t2 = this._canvasContainer = n("div", "mapboxgl-canvas-container", e2);
            this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i2 = this._controlContainer = n("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
              o2[e3] = n("div", `mapboxgl-ctrl-${e3}`, i2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, i2) {
            const o2 = e.exported.devicePixelRatio || 1;
            this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
          }
          _addMarker(e2) {
            this._markers.push(e2);
          }
          _removeMarker(e2) {
            const t2 = this._markers.indexOf(e2);
            -1 !== t2 && this._markers.splice(t2, 1);
          }
          _addPopup(e2) {
            this._popups.push(e2);
          }
          _removePopup(e2) {
            const t2 = this._popups.indexOf(e2);
            -1 !== t2 && this._popups.splice(t2, 1);
          }
          _setupPainter() {
            const t2 = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._useWebGL2 && this._canvas.getContext("webgl2", t2), r3 = o2 || this._canvas.getContext("webgl", t2) || this._canvas.getContext("experimental-webgl", t2);
            r3 ? (this._useWebGL2 && !o2 && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r3, true), this.painter = new Fo(r3, this.transform, !!o2), this.on("data", (e2) => {
              "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
            }), e.exported$1.testSupport(r3)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t2) {
            t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t2 }));
          }
          _contextRestored(t2) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t2 }));
          }
          _onMapScroll(e2) {
            if (e2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e2) {
            return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e2) {
            return this._update(), this._renderTaskQueue.add(e2);
          }
          _cancelRenderFrame(e2) {
            this._renderTaskQueue.remove(e2);
          }
          _requestDomTask(e2) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
          }
          _render(t2) {
            let i2;
            const o2 = this.painter.context.extTimerQuery, r3 = e.exported.now();
            if (this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed) return;
            this._updateProjectionTransition();
            const n2 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t3 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.exported.now(), r4 = new e.EvaluationParameters(t3, { now: o3, fadeDuration: n2, pitch: i3, transition: this.style.getTransition() });
              this.style.update(r4);
            }
            this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let s2 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s2 = this._updateAverageElevation(r3), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s2 = this._updateAverageElevation(r3), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
              const t3 = e.exported.now() - r3;
              o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                const n3 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
                o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t3, gpuTime: n3 })), e.window.performance.mark("frame-gpu", { startTime: r3, detail: { gpuTime: n3 } });
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t3 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i3 = this.painter.queryGpuTimers(t3);
                this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t3 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i3 = this.painter.queryGpuTimeDeferredRender(t3);
                this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i3 }));
              }, 50);
            }
            const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty || s2;
            if (a2 || this._repaint) this.triggerRepaint();
            else {
              const t3 = !this.isMoving() && this.loaded();
              if (t3 && (s2 = this._updateAverageElevation(r3, true)), s2) this.triggerRepaint();
              else if (this._triggerFrame(false), t3 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t4 = this._calculateSpeedIndex();
                this.fire(new e.Event("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e2) {
            for (const t2 of this._markers) e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
            for (const t2 of this._popups) !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
          }
          _updateAverageElevation(e2, t2 = false) {
            const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i2(0);
            if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
              const t3 = this.transform.averageElevation;
              let o2 = this.transform.sampleAverageElevation(), r3 = false;
              this.transform.elevation && (r3 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
              const n2 = Math.abs(t3 - o2);
              if (n2 > 1) {
                if (this._isInitialLoad || r3) return this._averageElevation.jumpTo(o2), i2(o2);
                this._averageElevation.easeTo(o2, e2, 300);
              } else if (n2 > 1e-4) return this._averageElevation.jumpTo(o2), i2(o2);
            }
            return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
          }
          _authenticate() {
            e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
              if (t2 && (t2.message === e.AUTH_ERR_MSG || 401 === t2.status)) {
                const t3 = this.painter.context.gl;
                e.storeAuthState(t3, false), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _updateTerrain() {
            const e2 = this._isDragging();
            this.painter.updateTerrain(this.style, e2);
          }
          _calculateSpeedIndex() {
            const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
            t2.timeStamps.push(performance.now());
            const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
            function r3(e3) {
              i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
              const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
              return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
            }
            return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r3(e2), t2.canvasCopies.map(r3), t2.timeStamps);
          }
          _canvasPixelComparison(e2, t2, i2) {
            let o2 = i2[1] - i2[0];
            const r3 = e2.length / 4;
            for (let n2 = 0; n2 < t2.length; n2++) {
              const s2 = t2[n2];
              let a2 = 0;
              for (let t3 = 0; t3 < s2.length; t3 += 4) s2[t3] === e2[t3] && s2[t3 + 1] === e2[t3 + 1] && s2[t3 + 2] === e2[t3 + 2] && s2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
              o2 += (i2[n2 + 2] - i2[n2 + 1]) * (1 - a2 / r3);
            }
            return o2;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e2 of this._controls) e2.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, false));
            const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t2) {
            this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
              const t3 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
            }));
          }
          _preloadTiles(t2) {
            const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
            return e.asyncAll(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e2) {
            this._trackResize && this.resize({ originalEvent: e2 })._update();
          }
          _onVisibilityChange() {
            "hidden" === e.window.document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e2) {
            this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e2) {
            this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e2) {
            this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e2) {
            this._showPadding !== e2 && (this._showPadding = e2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e2) {
            this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e2) {
            this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e2) {
            this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e2) {
            this._vertices = e2, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e2) {
            this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
          }
          _setCacheLimits(t2, i2) {
            e.setCacheLimits(t2, i2);
          }
          get version() {
            return e.version;
          }
        }, NavigationControl: class {
          constructor(t2) {
            this.options = e.extend({}, hn, t2), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
              this._map && this._map.zoomIn({}, { originalEvent: e2 });
            }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
              this._map && this._map.zoomOut({}, { originalEvent: e2 });
            }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
              const t3 = this._map;
              t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
            }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e2 = this._map;
            if (!e2) return;
            const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
            this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
          }
          _rotateCompassArrow() {
            const e2 = this._map;
            if (!e2) return;
            const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
            e2._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t2);
            });
          }
          onAdd(e2) {
            return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e2, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e2 = this._map;
            e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e2, t2) {
            const i2 = n("button", e2, this._container);
            return i2.type = "button", i2.addEventListener("click", t2), i2;
          }
          _setButtonTitle(e2, t2) {
            if (!this._map) return;
            const i2 = this._map._getUIString(`NavigationControl.${t2}`);
            e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
          }
        }, GeolocateControl: class extends e.Evented {
          constructor(t2) {
            super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, _n, t2), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e2) {
            return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(t2) {
            const i2 = (e2 = !!this.options.geolocation) => {
              this._supportsGeolocation = e2, t2(e2);
            };
            void 0 !== this._supportsGeolocation ? t2(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => i2("denied" !== e2.state)).catch(() => i2()) : i2();
          }
          _isOutOfMapMaxBounds(e2) {
            const t2 = this._map.getMaxBounds(), i2 = e2.coords;
            return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t2) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t2)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t2)), this._finish();
            }
          }
          _updateCamera(t2) {
            const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r3 = this._map.getBearing(), n2 = e.extend({ bearing: r3 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o2), n2, { geolocateSource: true });
          }
          _updateMarker(t2) {
            if (t2) {
              const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t2 = this._map.transform, i2 = e.mercatorZfromAltitude(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
            this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t2) {
            if (this._map) {
              if (this.options.trackUserLocation) if (1 === t2.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t2.code && this._noTimeout) return;
                this._setErrorState();
              }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t2)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t2) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
              } else {
                const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e2) {
            this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e2;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const t2 = () => {
              e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
            };
            void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e2) => {
              "granted" === e2 && t2();
            }).catch(console.error) : t2();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Kr, ScaleControl: class {
          constructor(t2) {
            this.options = e.extend({}, dn, t2), function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), true;
              } catch (e2) {
                return false;
              }
            }() || (this._setScale = pn.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, r3 = t2.unproject([o2, i2]), n2 = t2.unproject([o2 + e2, i2]), s2 = r3.distanceTo(n2);
            if ("imperial" === this.options.unit) {
              const t3 = 3.2808 * s2;
              t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
            } else "nautical" === this.options.unit ? this._setScale(e2, s2 / 1852, "nautical-mile") : s2 >= 1e3 ? this._setScale(e2, s2 / 1e3, "kilometer") : this._setScale(e2, s2, "meter");
          }
          _setScale(e2, t2, i2) {
            const o2 = mn(t2), r3 = o2 / t2;
            this._map._requestDomTask(() => {
              this._container.style.width = e2 * r3 + "px", this._container.innerHTML = "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i2 }).format(o2) : `${o2}&nbsp;nm`;
            });
          }
          onAdd(e2) {
            return this._map = e2, this._language = e2.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e2) {
            this._language = e2, this._update();
          }
          setUnit(e2) {
            this.options.unit = e2, this._update();
          }
        }, FullscreenControl: class {
          constructor(t2) {
            this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.window.HTMLElement ? this._container = t2.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t2) {
            return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const t2 = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            n("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e.Evented {
          constructor(t2) {
            super(), this.options = e.extend(Object.create(rn), t2), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
          }
          addTo(t2) {
            return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t2 = this._map;
            return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            this._lngLat = e.LngLat.convert(t2), this._pos = null, this._trackPointer = false, this._update();
            const i2 = this._map;
            return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e2 = this._map;
            return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(e.window.document.createTextNode(t2));
          }
          setHTML(t2) {
            const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
            let r3;
            for (o2.innerHTML = t2; r3 = o2.firstChild, r3; ) i2.appendChild(r3);
            return this.setDOMContent(i2);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e2) {
            return this.options.maxWidth = e2, this._update(), this;
          }
          setDOMContent(e2) {
            let t2 = this._content;
            if (t2) for (; t2.hasChildNodes(); ) t2.firstChild && t2.removeChild(t2.firstChild);
            else t2 = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
            if (t2.appendChild(e2), this.options.closeButton) {
              const e3 = this._closeButton = n("button", "mapboxgl-popup-close-button", t2);
              e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e2) {
            return this._classList.add(e2), this._updateClassList(), this;
          }
          removeClassName(e2) {
            return this._classList.delete(e2), this._updateClassList(), this;
          }
          setOffset(e2) {
            return this.options.offset = e2, this._update(), this;
          }
          toggleClassName(e2) {
            let t2;
            return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
          }
          _onMouseEvent(e2) {
            this._update(e2.point);
          }
          _getAnchor(e2) {
            if (this.options.anchor) return this.options.anchor;
            const t2 = this._map, i2 = this._container, o2 = this._pos;
            if (!t2 || !i2 || !o2) return "bottom";
            const r3 = i2.offsetWidth, n2 = i2.offsetHeight, s2 = o2.x < r3 / 2, a2 = o2.x > t2.transform.width - r3 / 2;
            if (o2.y + e2 < n2) return s2 ? "top-left" : a2 ? "top-right" : "top";
            if (o2.y > t2.transform.height - n2) {
              if (s2) return "bottom-left";
              if (a2) return "bottom-right";
            }
            return s2 ? "left" : a2 ? "right" : "bottom";
          }
          _updateClassList() {
            const e2 = this._container;
            if (!e2) return;
            const t2 = [...this._classList];
            t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
          }
          _update(t2) {
            const i2 = this._map, o2 = this._content;
            if (!i2 || !this._lngLat && !this._trackPointer || !o2) return;
            let r3 = this._container;
            if (r3 || (r3 = this._container = n("div", "mapboxgl-popup", i2.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r3), r3.appendChild(o2)), this.options.maxWidth && r3.style.maxWidth !== this.options.maxWidth && (r3.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
              const e2 = this._pos = this._trackPointer && t2 ? t2 : i2.project(this._lngLat), o3 = sn(this.options.offset), r4 = this._anchor = this._getAnchor(o3.y), n2 = sn(this.options.offset, r4), s2 = e2.add(n2).round();
              i2._requestDomTask(() => {
                this._container && r4 && (this._container.style.transform = `${tn[r4]} translate(${s2.x}px,${s2.y}px)`);
              });
            }
            if (!this._marker && i2._showingGlobe()) {
              const t3 = e.isLngLatBehindGlobe(i2.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t3);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e2 = this._container.querySelector(nn);
            e2 && e2.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e2) {
            this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
          }
        }, Marker: on, Style: Qt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: Zo, Evented: e.Evented, config: e.config, prewarm: function() {
          je().acquire(Ue);
        }, clearPrewarmedResources: function() {
          const e2 = Ge;
          e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return e.config.ACCESS_TOKEN;
        }, set accessToken(t2) {
          e.config.ACCESS_TOKEN = t2;
        }, get baseApiUrl() {
          return e.config.API_URL;
        }, set baseApiUrl(t2) {
          e.config.API_URL = t2;
        }, get workerCount() {
          return Ne.workerCount;
        }, set workerCount(e2) {
          Ne.workerCount = e2;
        }, get maxParallelImageRequests() {
          return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t2) {
          e.config.MAX_PARALLEL_IMAGE_REQUESTS = t2;
        }, clearStorage(t2) {
          e.clearTileCache(t2);
        }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
        return fn;
      });
      var mapboxgl$1 = mapboxgl2;
      return mapboxgl$1;
    });
  }
});

// src/homeflow/index.tsx
var import_react40 = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@mantine/core/esm/core/utils/keys/keys.mjs
function keys(object) {
  return Object.keys(object);
}

// node_modules/@mantine/core/esm/core/utils/deep-merge/deep-merge.mjs
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target };
  const _source = source;
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(_source[key])) {
        if (!(key in target)) {
          result[key] = _source[key];
        } else {
          result[key] = deepMerge(result[key], _source[key]);
        }
      } else {
        result[key] = _source[key];
      }
    });
  }
  return result;
}

// node_modules/@mantine/core/esm/core/utils/camel-to-kebab-case/camel-to-kebab-case.mjs
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}

// node_modules/@mantine/core/esm/core/utils/units-converters/px.mjs
function getTransformedScaledValue(value) {
  if (typeof value !== "string" || !value.includes("var(--mantine-scale)")) {
    return value;
  }
  return value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px(value) {
  const transformedValue = getTransformedScaledValue(value);
  if (typeof transformedValue === "number") {
    return transformedValue;
  }
  if (typeof transformedValue === "string") {
    if (transformedValue.includes("calc") || transformedValue.includes("var")) {
      return transformedValue;
    }
    if (transformedValue.includes("px")) {
      return Number(transformedValue.replace("px", ""));
    }
    if (transformedValue.includes("rem")) {
      return Number(transformedValue.replace("rem", "")) * 16;
    }
    if (transformedValue.includes("em")) {
      return Number(transformedValue.replace("em", "")) * 16;
    }
    return Number(transformedValue);
  }
  return NaN;
}

// node_modules/@mantine/core/esm/core/utils/units-converters/rem.mjs
function scaleRem(remValue) {
  if (remValue === "0rem") {
    return "0rem";
  }
  return `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = false } = {}) {
  function converter(value) {
    if (value === 0 || value === "0") {
      return `0${units}`;
    }
    if (typeof value === "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value === "string") {
      if (value === "") {
        return value;
      }
      if (value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba(")) {
        return value;
      }
      if (value.includes(",")) {
        return value.split(",").map((val) => converter(val)).join(",");
      }
      if (value.includes(" ")) {
        return value.split(" ").map((val) => converter(val)).join(" ");
      }
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
var rem = createConverter("rem", { shouldScale: true });
var em = createConverter("em");

// node_modules/@mantine/core/esm/core/utils/filter-props/filter-props.mjs
function filterProps(props) {
  return Object.keys(props).reduce((acc, key) => {
    if (props[key] !== void 0) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
}

// node_modules/@mantine/core/esm/core/utils/is-number-like/is-number-like.mjs
function isNumberLike(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value === "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "") {
      return true;
    }
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    const values2 = value.trim().split(/\s+/);
    return values2.every((val) => cssUnitsRegex.test(val));
  }
  return false;
}

// node_modules/@mantine/core/esm/core/utils/create-safe-context/create-safe-context.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
function createSafeContext(errorMessage) {
  const Context = (0, import_react.createContext)(null);
  const useSafeContext = () => {
    const ctx = (0, import_react.useContext)(Context);
    if (ctx === null) {
      throw new Error(errorMessage);
    }
    return ctx;
  };
  const Provider = ({ children, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
  return [Provider, useSafeContext];
}

// node_modules/@mantine/core/esm/core/utils/get-size/get-size.mjs
function getSize(size, prefix = "size", convertToRem = true) {
  if (size === void 0) {
    return void 0;
  }
  return isNumberLike(size) ? convertToRem ? rem(size) : size : `var(--${prefix}-${size})`;
}
function getSpacing(size) {
  return getSize(size, "mantine-spacing");
}

// node_modules/@mantine/core/esm/core/utils/get-breakpoint-value/get-breakpoint-value.mjs
function getBreakpointValue(breakpoint, breakpoints) {
  if (breakpoint in breakpoints) {
    return px(breakpoints[breakpoint]);
  }
  return px(breakpoint);
}

// node_modules/@mantine/core/esm/core/utils/get-sorted-breakpoints/get-sorted-breakpoints.mjs
function getSortedBreakpoints(values2, breakpoints) {
  const convertedBreakpoints = values2.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue(breakpoint, breakpoints)
  }));
  convertedBreakpoints.sort((a, b) => a.px - b.px);
  return convertedBreakpoints;
}

// node_modules/@mantine/core/esm/core/utils/get-base-value/get-base-value.mjs
function getBaseValue(value) {
  if (typeof value === "object" && value !== null) {
    if ("base" in value) {
      return value.base;
    }
    return void 0;
  }
  return value;
}

// node_modules/@mantine/hooks/esm/utils/clamp/clamp.mjs
function clamp(value, min, max) {
  if (min === void 0 && max === void 0) {
    return value;
  }
  if (min !== void 0 && max === void 0) {
    return Math.max(value, min);
  }
  if (min === void 0 && max !== void 0) {
    return Math.min(value, max);
  }
  return Math.min(Math.max(value, min), max);
}

// node_modules/@mantine/hooks/esm/use-isomorphic-effect/use-isomorphic-effect.mjs
var import_react2 = __toESM(require_react(), 1);
var useIsomorphicEffect = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;

// node_modules/@mantine/core/esm/core/styles-api/create-vars-resolver/create-vars-resolver.mjs
function createVarsResolver(resolver) {
  return resolver;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/resolve-class-names/resolve-class-names.mjs
var EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  objects.forEach((obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (merged[key]) {
        merged[key] = clsx_default(merged[key], value);
      } else {
        merged[key] = value;
      }
    });
  });
  return merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const arrayClassNames = Array.isArray(classNames) ? classNames : [classNames];
  const resolvedClassNames = arrayClassNames.map(
    (item) => typeof item === "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-styles/resolve-styles.mjs
function resolveStyles({ theme, styles, props, stylesCtx }) {
  const arrayStyles = Array.isArray(styles) ? styles : [styles];
  return arrayStyles.reduce((acc, style) => {
    if (typeof style === "function") {
      return { ...acc, ...style(theme, props, stylesCtx) };
    }
    return { ...acc, ...style };
  }, {});
}

// node_modules/@mantine/core/esm/core/MantineProvider/Mantine.context.mjs
var import_react3 = __toESM(require_react(), 1);
var MantineContext = (0, import_react3.createContext)(null);
function useMantineContext() {
  const ctx = (0, import_react3.useContext)(MantineContext);
  if (!ctx) {
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  }
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}

// node_modules/@mantine/core/esm/core/MantineProvider/default-theme.mjs
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/default-variant-colors-resolver/default-variant-colors-resolver.mjs
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/to-rgba/to-rgba.mjs
function isHexColor(hex) {
  const HEX_REGEXP = /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i;
  return HEX_REGEXP.test(hex);
}
function hexToRgba(color) {
  let hexString = color.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16);
  const r2 = parsed >> 16 & 255;
  const g = parsed >> 8 & 255;
  const b = parsed & 255;
  return {
    r: r2,
    g,
    b,
    a: 1
  };
}
function rgbStringToRgba(color) {
  const [r2, g, b, a] = color.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g, b, a: a === void 0 ? 1 : a };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i;
  const matches = hslaString.match(hslaRegex);
  if (!matches) {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  }
  const h = parseInt(matches[1], 10);
  const s = parseInt(matches[2], 10) / 100;
  const l = parseInt(matches[3], 10) / 100;
  const a = matches[5] ? parseFloat(matches[5]) : void 0;
  const chroma = (1 - Math.abs(2 * l - 1)) * s;
  const huePrime = h / 60;
  const x = chroma * (1 - Math.abs(huePrime % 2 - 1));
  const m = l - chroma / 2;
  let r2;
  let g;
  let b;
  if (huePrime >= 0 && huePrime < 1) {
    r2 = chroma;
    g = x;
    b = 0;
  } else if (huePrime >= 1 && huePrime < 2) {
    r2 = x;
    g = chroma;
    b = 0;
  } else if (huePrime >= 2 && huePrime < 3) {
    r2 = 0;
    g = chroma;
    b = x;
  } else if (huePrime >= 3 && huePrime < 4) {
    r2 = 0;
    g = x;
    b = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    r2 = x;
    g = 0;
    b = chroma;
  } else {
    r2 = chroma;
    g = 0;
    b = x;
  }
  return {
    r: Math.round((r2 + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255),
    a: a || 1
  };
}
function toRgba(color) {
  if (isHexColor(color)) {
    return hexToRgba(color);
  }
  if (color.startsWith("rgb")) {
    return rgbStringToRgba(color);
  }
  if (color.startsWith("hsl")) {
    return hslStringToRgba(color);
  }
  return {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/darken/darken.mjs
function darken(color, alpha2) {
  if (color.startsWith("var(")) {
    return `color-mix(in srgb, ${color}, black ${alpha2 * 100}%)`;
  }
  const { r: r2, g, b, a } = toRgba(color);
  const f = 1 - alpha2;
  const dark = (input) => Math.round(input * f);
  return `rgba(${dark(r2)}, ${dark(g)}, ${dark(b)}, ${a})`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-primary-shade/get-primary-shade.mjs
function getPrimaryShade(theme, colorScheme) {
  if (typeof theme.primaryShade === "number") {
    return theme.primaryShade;
  }
  if (colorScheme === "dark") {
    return theme.primaryShade.dark;
  }
  return theme.primaryShade.light;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/luminance/luminance.mjs
function gammaCorrect(c) {
  return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color) {
  if (color.startsWith("oklch(")) {
    return (getLightnessFromOklch(color) || 0) / 100;
  }
  const { r: r2, g, b } = toRgba(color);
  const sR = r2 / 255;
  const sG = g / 255;
  const sB = b / 255;
  const rLinear = gammaCorrect(sR);
  const gLinear = gammaCorrect(sG);
  const bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color, luminanceThreshold = 0.179) {
  if (color.startsWith("var(")) {
    return false;
  }
  return luminance(color) > luminanceThreshold;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/parse-theme-color/parse-theme-color.mjs
function parseThemeColor({
  color,
  theme,
  colorScheme
}) {
  if (typeof color !== "string") {
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color}`
    );
  }
  if (color === "bright") {
    return {
      color,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: false,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  }
  if (color === "dimmed") {
    return {
      color,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: void 0,
      isThemeColor: false,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6],
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  }
  if (color === "white" || color === "black") {
    return {
      color,
      value: color === "white" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: false,
      isLight: isLightColor(
        color === "white" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: `--mantine-color-${color}`
    };
  }
  const [_color, shade] = color.split(".");
  const colorShade = shade ? Number(shade) : void 0;
  const isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color,
    value: color,
    isThemeColor,
    isLight: isLightColor(color, theme.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs
function getThemeColor(color, theme) {
  const parsed = parseThemeColor({ color: color || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-gradient/get-gradient.mjs
function getGradient(gradient, theme) {
  const merged = {
    from: gradient?.from || theme.defaultGradient.from,
    to: gradient?.to || theme.defaultGradient.to,
    deg: gradient?.deg ?? theme.defaultGradient.deg ?? 0
  };
  const fromColor = getThemeColor(merged.from, theme);
  const toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/rgba/rgba.mjs
function rgba(color, alpha2) {
  if (typeof color !== "string" || alpha2 > 1 || alpha2 < 0) {
    return "rgba(0, 0, 0, 1)";
  }
  if (color.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color}, transparent ${mixPercentage}%)`;
  }
  if (color.startsWith("oklch")) {
    if (color.includes("/")) {
      return color.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`);
    }
    return color.replace(")", ` / ${alpha2})`);
  }
  const { r: r2, g, b } = toRgba(color);
  return `rgba(${r2}, ${g}, ${b}, ${alpha2})`;
}
var alpha = rgba;

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/default-variant-colors-resolver/default-variant-colors-resolver.mjs
var defaultVariantColorsResolver = ({
  color,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color, theme });
  const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "none") {
    return {
      background: "transparent",
      hover: "transparent",
      color: "inherit",
      border: "none"
    };
  }
  if (variant === "filled") {
    const textColor = _autoContrast ? parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" : "var(--mantine-color-white)";
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: `var(--mantine-color-${color}-filled)`,
          hover: `var(--mantine-color-${color}-filled-hover)`,
          color: textColor,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
        color: textColor,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: color,
      hover: darken(color, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: `var(--mantine-color-${color}-light)`,
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba(parsedColor, 0.1),
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba(color, 0.1),
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color}-outline-hover)`,
          color: `var(--mantine-color-${color}-outline)`,
          border: `${rem(1)} solid var(--mantine-color-${color}-outline)`
        };
      }
      return {
        background: "transparent",
        hover: rgba(theme.colors[parsed.color][parsed.shade], 0.05),
        color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
      };
    }
    return {
      background: "transparent",
      hover: rgba(color, 0.05),
      color,
      border: `${rem(1)} solid ${color}`
    };
  }
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color}-light-hover)`,
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba(color, 0.12),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "transparent") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: "transparent",
          hover: "transparent",
          color: `var(--mantine-color-${color}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: "transparent",
        hover: "transparent",
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: "transparent",
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "white") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0) {
        return {
          background: "var(--mantine-color-white)",
          hover: darken(theme.white, 0.01),
          color: `var(--mantine-color-${color}-filled)`,
          border: `${rem(1)} solid transparent`
        };
      }
      return {
        background: "var(--mantine-color-white)",
        hover: darken(theme.white, 0.01),
        color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "var(--mantine-color-white)",
      hover: darken(theme.white, 0.01),
      color,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "gradient") {
    return {
      background: getGradient(gradient, theme),
      hover: getGradient(gradient, theme),
      color: "var(--mantine-color-white)",
      border: "none"
    };
  }
  if (variant === "default") {
    return {
      background: "var(--mantine-color-default)",
      hover: "var(--mantine-color-default-hover)",
      color: "var(--mantine-color-default-color)",
      border: `${rem(1)} solid var(--mantine-color-default-border)`
    };
  }
  return {};
};

// node_modules/@mantine/core/esm/core/MantineProvider/default-colors.mjs
var DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
};

// node_modules/@mantine/core/esm/core/MantineProvider/default-theme.mjs
var DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji";
var DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: true,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: false,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: false,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/is-mantine-color-scheme.mjs
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}

// node_modules/@mantine/core/esm/core/MantineProvider/color-scheme-managers/local-storage-manager.mjs
function localStorageColorSchemeManager({
  key = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window === "undefined") {
        return defaultValue;
      }
      try {
        const storedColorScheme = window.localStorage.getItem(key);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        if (event.storageArea === window.localStorage && event.key === key) {
          isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
        }
      };
      window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key);
    }
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineClasses/MantineClasses.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/merge-mantine-theme/merge-mantine-theme.mjs
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more \u2013 https://mantine.dev/theming/colors/#primary-color";
var INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  if (shade < 0 || shade > 9) {
    return false;
  }
  return parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors)) {
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  }
  if (typeof theme.primaryShade === "object") {
    if (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)) {
      throw new Error(INVALID_PRIMARY_SHADE_ERROR);
    }
  }
  if (typeof theme.primaryShade === "number" && !isValidPrimaryShade(theme.primaryShade)) {
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  }
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride) {
    validateMantineTheme(currentTheme);
    return currentTheme;
  }
  const result = deepMerge(currentTheme, themeOverride);
  if (themeOverride.fontFamily && !themeOverride.headings?.fontFamily) {
    result.headings.fontFamily = themeOverride.fontFamily;
  }
  validateMantineTheme(result);
  return result;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs
var MantineThemeContext = (0, import_react7.createContext)(null);
var useSafeMantineTheme = () => (0, import_react7.useContext)(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = (0, import_react7.useContext)(MantineThemeContext);
  if (!ctx) {
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  }
  return ctx;
}
function MantineThemeProvider({
  theme,
  children,
  inherit = true
}) {
  const parentTheme = useSafeMantineTheme();
  const mergedTheme = (0, import_react7.useMemo)(
    () => mergeMantineTheme(inherit ? parentTheme : DEFAULT_THEME, theme),
    [theme, parentTheme, inherit]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(MantineThemeContext.Provider, { value: mergedTheme, children });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";

// node_modules/@mantine/core/esm/core/MantineProvider/MantineClasses/MantineClasses.mjs
function MantineClasses() {
  const theme = useMantineTheme();
  const nonce = useMantineStyleNonce();
  const classes3 = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px");
    const pxValue = px(theme.breakpoints[breakpoint]);
    const maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1);
    const minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: classes3 }
    }
  );
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/css-variables-object-to-string.mjs
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/wrap-with-selector.mjs
function wrapWithSelector(selectors, code) {
  const _selectors = Array.isArray(selectors) ? selectors : [selectors];
  return _selectors.reduce((acc, selector) => `${selector}{${acc}}`, code);
}

// node_modules/@mantine/core/esm/core/MantineProvider/convert-css-variables/convert-css-variables.mjs
function convertCssVariables(input, selector) {
  const sharedVariables = cssVariablesObjectToString(input.variables);
  const shared = sharedVariables ? wrapWithSelector(selector, sharedVariables) : "";
  const dark = cssVariablesObjectToString(input.dark);
  const light = cssVariablesObjectToString(input.light);
  const darkForced = dark ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="dark"])`, dark) : wrapWithSelector(`${selector}[data-mantine-color-scheme="dark"]`, dark) : "";
  const lightForced = light ? selector === ":host" ? wrapWithSelector(`${selector}([data-mantine-color-scheme="light"])`, light) : wrapWithSelector(`${selector}[data-mantine-color-scheme="light"]`, light) : "";
  return `${shared}

${darkForced}

${lightForced}`;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-merged-variables.mjs
var import_react12 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/default-css-variables-resolver.mjs
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/color-functions/get-contrast-color/get-contrast-color.mjs
function getContrastColor({ color, theme, autoContrast }) {
  const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme.autoContrast;
  if (!_autoContrast) {
    return "var(--mantine-color-white)";
  }
  const parsed = parseThemeColor({ color: color || theme.primaryColor, theme });
  return parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-css-color-variables.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function getCSSColorVariables({
  theme,
  color,
  colorScheme,
  name = color,
  withColorValues = true
}) {
  if (!theme.colors[color]) {
    return {};
  }
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light");
    const dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha(theme.colors[color][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha(theme.colors[color][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha(theme.colors[color][primaryShade2], 0.05)
    };
    if (!withColorValues) {
      return dynamicVariables2;
    }
    return {
      [`--mantine-color-${name}-0`]: theme.colors[color][0],
      [`--mantine-color-${name}-1`]: theme.colors[color][1],
      [`--mantine-color-${name}-2`]: theme.colors[color][2],
      [`--mantine-color-${name}-3`]: theme.colors[color][3],
      [`--mantine-color-${name}-4`]: theme.colors[color][4],
      [`--mantine-color-${name}-5`]: theme.colors[color][5],
      [`--mantine-color-${name}-6`]: theme.colors[color][6],
      [`--mantine-color-${name}-7`]: theme.colors[color][7],
      [`--mantine-color-${name}-8`]: theme.colors[color][8],
      [`--mantine-color-${name}-9`]: theme.colors[color][9],
      ...dynamicVariables2
    };
  }
  const primaryShade = getPrimaryShade(theme, "dark");
  const dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha(
      theme.colors[color][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha(
      theme.colors[color][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha(
      theme.colors[color][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  if (!withColorValues) {
    return dynamicVariables;
  }
  return {
    [`--mantine-color-${name}-0`]: theme.colors[color][0],
    [`--mantine-color-${name}-1`]: theme.colors[color][1],
    [`--mantine-color-${name}-2`]: theme.colors[color][2],
    [`--mantine-color-${name}-3`]: theme.colors[color][3],
    [`--mantine-color-${name}-4`]: theme.colors[color][4],
    [`--mantine-color-${name}-5`]: theme.colors[color][5],
    [`--mantine-color-${name}-6`]: theme.colors[color][6],
    [`--mantine-color-${name}-7`]: theme.colors[color][7],
    [`--mantine-color-${name}-8`]: theme.colors[color][8],
    [`--mantine-color-${name}-9`]: theme.colors[color][9],
    ...dynamicVariables
  };
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/virtual-color/virtual-color.mjs
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function isVirtualColor(value) {
  return !!value && typeof value === "object" && "mantine-virtual-color" in value;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/default-css-variables-resolver.mjs
function assignSizeVariables(variables, sizes, name) {
  keys(sizes).forEach(
    (size) => Object.assign(variables, { [`--mantine-${name}-${size}`]: sizes[size] })
  );
}
var defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light");
  const defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius);
  const result = {
    variables: {
      "--mantine-z-index-app": "100",
      "--mantine-z-index-modal": "200",
      "--mantine-z-index-popover": "300",
      "--mantine-z-index-overlay": "400",
      "--mantine-z-index-max": "9999",
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-color-scheme": "light",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)",
      "--mantine-color-disabled": "var(--mantine-color-gray-2)",
      "--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
      "--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
    },
    dark: {
      "--mantine-color-scheme": "dark",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)",
      "--mantine-color-disabled": "var(--mantine-color-dark-6)",
      "--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
      "--mantine-color-disabled-border": "var(--mantine-color-dark-4)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint");
  assignSizeVariables(result.variables, theme.spacing, "spacing");
  assignSizeVariables(result.variables, theme.fontSizes, "font-size");
  assignSizeVariables(result.variables, theme.lineHeights, "line-height");
  assignSizeVariables(result.variables, theme.shadows, "shadow");
  assignSizeVariables(result.variables, theme.radius, "radius");
  theme.colors[theme.primaryColor].forEach((_, index) => {
    result.variables[`--mantine-primary-color-${index}`] = `var(--mantine-color-${theme.primaryColor}-${index})`;
  });
  keys(theme.colors).forEach((color) => {
    const value = theme.colors[color];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: true
        })
      );
      Object.assign(
        result.dark,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: true
        })
      );
      return;
    }
    value.forEach((shade, index) => {
      result.variables[`--mantine-color-${color}-${index}`] = shade;
    });
    Object.assign(
      result.light,
      getCSSColorVariables({
        theme,
        color,
        colorScheme: "light",
        withColorValues: false
      })
    );
    Object.assign(
      result.dark,
      getCSSColorVariables({
        theme,
        color,
        colorScheme: "dark",
        withColorValues: false
      })
    );
  });
  const headings3 = theme.headings.sizes;
  keys(headings3).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings3[heading].fontSize;
    result.variables[`--mantine-${heading}-line-height`] = headings3[heading].lineHeight;
    result.variables[`--mantine-${heading}-font-weight`] = headings3[heading].fontWeight || theme.headings.fontWeight;
  });
  return result;
};

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/get-merged-variables.mjs
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme);
  const providerGenerator = generator?.(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/remove-default-variables.mjs
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  keys(input.variables).forEach((key) => {
    if (defaultCssVariables.variables[key] !== input.variables[key]) {
      cleaned.variables[key] = input.variables[key];
    }
  });
  keys(input.light).forEach((key) => {
    if (defaultCssVariables.light[key] !== input.light[key]) {
      cleaned.light[key] = input.light[key];
    }
  });
  keys(input.dark).forEach((key) => {
    if (defaultCssVariables.dark[key] !== input.dark[key]) {
      cleaned.dark[key] = input.dark[key];
    }
  });
  return cleaned;
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs
function getColorSchemeCssVariables(selector) {
  return `
  ${selector}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme();
  const nonce = useMantineStyleNonce();
  const generator = useMantineCssVariablesResolver();
  const mergedVariables = getMergedVariables({ theme, generator });
  const shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables;
  const cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables;
  const css = convertCssVariables(cleanedVariables, cssVariablesSelector);
  if (css) {
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      "style",
      {
        "data-mantine-styles": true,
        nonce: nonce?.(),
        dangerouslySetInnerHTML: {
          __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
        }
      }
    );
  }
  return null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
var import_react15 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/MantineProvider/use-mantine-color-scheme/use-provider-color-scheme.mjs
var import_react14 = __toESM(require_react(), 1);
function setColorSchemeAttribute(colorScheme, getRootElement) {
  const hasDarkColorScheme = typeof window !== "undefined" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches;
  const computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
  getRootElement()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement,
  forceColorScheme
}) {
  const media = (0, import_react14.useRef)(null);
  const [value, setValue] = (0, import_react14.useState)(() => manager.get(defaultColorScheme));
  const colorSchemeValue = forceColorScheme || value;
  const setColorScheme = (0, import_react14.useCallback)(
    (colorScheme) => {
      if (!forceColorScheme) {
        setColorSchemeAttribute(colorScheme, getRootElement);
        setValue(colorScheme);
        manager.set(colorScheme);
      }
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  );
  const clearColorScheme = (0, import_react14.useCallback)(() => {
    setValue(defaultColorScheme);
    setColorSchemeAttribute(defaultColorScheme, getRootElement);
    manager.clear();
  }, [manager.clear, defaultColorScheme]);
  (0, import_react14.useEffect)(() => {
    manager.subscribe(setColorScheme);
    return manager.unsubscribe;
  }, [manager.subscribe, manager.unsubscribe]);
  useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
  }, []);
  (0, import_react14.useEffect)(() => {
    if (forceColorScheme) {
      setColorSchemeAttribute(forceColorScheme, getRootElement);
      return () => {
      };
    }
    if (forceColorScheme === void 0) {
      setColorSchemeAttribute(value, getRootElement);
    }
    if (typeof window !== "undefined" && "matchMedia" in window) {
      media.current = window.matchMedia("(prefers-color-scheme: dark)");
    }
    const listener = (event) => {
      if (value === "auto") {
        setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
      }
    };
    media.current?.addEventListener("change", listener);
    return () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]);
  return { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}

// node_modules/@mantine/core/esm/core/MantineProvider/use-respect-reduce-motion/use-respect-reduce-motion.mjs
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement
}) {
  useIsomorphicEffect(() => {
    if (respectReducedMotion) {
      getRootElement()?.setAttribute("data-respect-reduced-motion", "true");
    }
  }, [respectReducedMotion]);
}

// node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs
function MantineProvider({
  theme,
  children,
  getStyleNonce,
  withStaticClasses = true,
  withGlobalClasses = true,
  deduplicateCssVariables = true,
  withCssVariables = true,
  cssVariablesSelector = ":root",
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform,
  env
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement
  });
  useRespectReduceMotion({
    respectReducedMotion: theme?.respectReducedMotion || false,
    getRootElement
  });
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector,
        withStaticClasses,
        stylesTransform,
        env
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(MantineThemeProvider, { theme, children: [
        withCssVariables && /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(MantineClasses, {}),
        children
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function HeadlessMantineProvider({ children, theme, env }) {
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    MantineContext.Provider,
    {
      value: {
        colorScheme: "auto",
        setColorScheme: () => {
        },
        clearColorScheme: () => {
        },
        getRootElement: () => document.documentElement,
        classNamesPrefix: "mantine",
        cssVariablesSelector: ":root",
        withStaticClasses: false,
        headless: true,
        env
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(MantineThemeProvider, { theme, children })
    }
  );
}
HeadlessMantineProvider.displayName = "@mantine/core/HeadlessMantineProvider";

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-global-class-names/get-global-class-names.mjs
var FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx_default(
    options?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]),
    options?.active && !unstyled && theme.activeClassName
  );
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-styles.mjs
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-options-class-names/get-options-class-names.mjs
function getOptionsClassNames({
  selector,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-resolved-class-names/get-resolved-class-names.mjs
function getResolvedClassNames({
  selector,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-root-class-name/get-root-class-name.mjs
function getRootClassName({ rootSelector, selector, className }) {
  return rootSelector === selector ? className : void 0;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-selector-class-name/get-selector-class-name.mjs
function getSelectorClassName({ selector, classes: classes3, unstyled }) {
  return unstyled ? void 0 : classes3[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-static-class-names/get-static-class-names.mjs
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector,
  withStaticClass
}) {
  if (withStaticClass === false) {
    return [];
  }
  return themeName.map((n) => `${classNamesPrefix}-${n}-${selector}`);
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-theme-class-names/get-theme-class-names.mjs
function getThemeClassNames({
  themeName,
  theme,
  selector,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n) => resolveClassNames({
      theme,
      classNames: theme.components[n]?.classNames,
      props,
      stylesCtx
    })?.[selector]
  );
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-variant-class-name/get-variant-class-name.mjs
function getVariantClassName({
  options,
  classes: classes3,
  selector,
  unstyled
}) {
  return options?.variant && !unstyled ? classes3[`${selector}--${options.variant}`] : void 0;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-class-name/get-class-name.mjs
function getClassName({
  theme,
  options,
  themeName,
  selector,
  classNamesPrefix,
  classNames,
  classes: classes3,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx_default(
    getGlobalClassNames({ theme, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme, themeName, selector, props, stylesCtx }),
    getVariantClassName({ options, classes: classes3, selector, unstyled }),
    getResolvedClassNames({ selector, stylesCtx, theme, classNames, props }),
    getResolvedClassNames({ selector, stylesCtx, theme, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector, stylesCtx, options, props, theme }),
    getRootClassName({ rootSelector, selector, className }),
    getSelectorClassName({ selector, classes: classes3, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector,
      withStaticClass: options?.withStaticClass
    }),
    options?.className
  );
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-theme-styles/get-theme-styles.mjs
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector
}) {
  return themeName.map(
    (n) => resolveStyles({
      theme,
      styles: theme.components[n]?.styles,
      props,
      stylesCtx
    })[selector]
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-style/resolve-style.mjs
function resolveStyle({ style, theme }) {
  if (Array.isArray(style)) {
    return [...style].reduce(
      (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }),
      {}
    );
  }
  if (typeof style === "function") {
    return style(theme);
  }
  if (style == null) {
    return {};
  }
  return style;
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/merge-vars.mjs
var import_react16 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function mergeVars(vars) {
  return vars.reduce((acc, current) => {
    if (current) {
      Object.keys(current).forEach((key) => {
        acc[key] = { ...acc[key], ...filterProps(current[key]) };
      });
    }
    return acc;
  }, {});
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/resolve-vars/resolve-vars.mjs
function resolveVars({
  vars,
  varsResolver: varsResolver2,
  theme,
  props,
  stylesCtx,
  selector,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver2?.(theme, props, stylesCtx),
    ...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
    vars?.(theme, props, stylesCtx)
  ])?.[selector];
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/get-style/get-style.mjs
function getStyle({
  theme,
  themeName,
  selector,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style,
  vars,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector],
    ...!withStylesTransform && resolveStyles({ theme, styles: options?.styles, props: options?.props || props, stylesCtx })[selector],
    ...resolveVars({ theme, props, stylesCtx, vars, varsResolver: varsResolver2, selector, themeName, headless }),
    ...rootSelector === selector ? resolveStyle({ style, theme }) : null,
    ...resolveStyle({ style: options?.style, theme })
  };
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-transformed-styles.mjs
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme = useMantineTheme();
  const stylesTransform = useMantineStylesTransform()?.();
  const getTransformedStyles = (styles) => {
    if (!stylesTransform) {
      return [];
    }
    const transformedStyles = styles.map(
      (style) => stylesTransform(style, { props, theme, ctx: stylesCtx })
    );
    return [
      ...transformedStyles,
      ...themeName.map(
        (n) => stylesTransform(theme.components[n]?.styles, { props, theme, ctx: stylesCtx })
      )
    ].filter(Boolean);
  };
  return {
    getTransformedStyles,
    withStylesTransform: !!stylesTransform
  };
}

// node_modules/@mantine/core/esm/core/styles-api/use-styles/use-styles.mjs
function useStyles({
  name,
  classes: classes3,
  props,
  stylesCtx,
  className,
  style,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver: varsResolver2,
  attributes
}) {
  const theme = useMantineTheme();
  const classNamesPrefix = useMantineClassNamesPrefix();
  const withStaticClasses = useMantineWithStaticClasses();
  const headless = useMantineIsHeadless();
  const themeName = (Array.isArray(name) ? name : [name]).filter((n) => n);
  const { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector,
      classNamesPrefix,
      classNames,
      classes: classes3,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style,
      vars,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    }),
    ...attributes?.[selector]
  });
}

// node_modules/@mantine/core/esm/core/MantineProvider/use-props/use-props.mjs
var import_react19 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function useProps(component, defaultProps3, props) {
  const theme = useMantineTheme();
  const contextPropsPayload = theme.components[component]?.defaultProps;
  const contextProps = typeof contextPropsPayload === "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps3, ...contextProps, ...filterProps(props) };
}

// node_modules/@mantine/core/esm/core/InlineStyles/InlineStyles.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/InlineStyles/css-object-to-string/css-object-to-string.mjs
var import_react20 = __toESM(require_react(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function cssObjectToString(css) {
  return keys(css).reduce(
    (acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc,
    ""
  ).trim();
}

// node_modules/@mantine/core/esm/core/InlineStyles/styles-to-string/styles-to-string.mjs
function stylesToString({ selector, styles, media, container: container2 }) {
  const baseStyles = styles ? cssObjectToString(styles) : "";
  const mediaQueryStyles = !Array.isArray(media) ? [] : media.map((item) => `@media${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
  const containerStyles = !Array.isArray(container2) ? [] : container2.map(
    (item) => `@container ${item.query}{${selector}{${cssObjectToString(item.styles)}}}`
  );
  return `${baseStyles ? `${selector}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}

// node_modules/@mantine/core/esm/core/InlineStyles/InlineStyles.mjs
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}

// node_modules/@mantine/core/esm/core/Box/style-props/extract-style-props/extract-style-props.mjs
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function extractStyleProps(others) {
  const {
    m,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bdrs,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  const styleProps = filterProps({
    m,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    bdrs,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  });
  return { styleProps, rest };
}

// node_modules/@mantine/core/esm/core/Box/style-props/style-props-data.mjs
var STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bdrs: { type: "radius", property: "borderRadius" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/parse-style-props.mjs
var import_react29 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/border-resolver/border-resolver.mjs
var import_react24 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/color-resolver/color-resolver.mjs
var import_react23 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function colorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  if (parsedColor.color === "dimmed") {
    return "var(--mantine-color-dimmed)";
  }
  if (parsedColor.color === "bright") {
    return "var(--mantine-color-bright)";
  }
  return parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color, theme) {
  const parsedColor = parseThemeColor({ color, theme });
  if (parsedColor.isThemeColor && parsedColor.shade === void 0) {
    return `var(--mantine-color-${parsedColor.color}-text)`;
  }
  return colorResolver(color, theme);
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/border-resolver/border-resolver.mjs
function borderResolver(value, theme) {
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    const [size, style, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size)}`;
    style && (result += ` ${style}`);
    colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`);
    return result.trim();
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-family-resolver/font-family-resolver.mjs
var values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  if (typeof fontFamily === "string" && fontFamily in values) {
    return values[fontFamily];
  }
  return fontFamily;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/font-size-resolver/font-size-resolver.mjs
var import_react25 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var headings = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  if (typeof value === "string" && value in theme.fontSizes) {
    return `var(--mantine-font-size-${value})`;
  }
  if (typeof value === "string" && headings.includes(value)) {
    return `var(--mantine-${value}-font-size)`;
  }
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    return rem(value);
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/identity-resolver/identity-resolver.mjs
function identityResolver(value) {
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/line-height-resolver/line-height-resolver.mjs
var headings2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  if (typeof value === "string" && value in theme.lineHeights) {
    return `var(--mantine-line-height-${value})`;
  }
  if (typeof value === "string" && headings2.includes(value)) {
    return `var(--mantine-${value}-line-height)`;
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/radius-resolver/radius-resolver.mjs
var import_react26 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function radiusResolver(value, theme) {
  if (typeof value === "string" && value in theme.radius) {
    return `var(--mantine-radius-${value})`;
  }
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    return rem(value);
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/size-resolver/size-resolver.mjs
var import_react27 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function sizeResolver(value) {
  if (typeof value === "number") {
    return rem(value);
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/spacing-resolver/spacing-resolver.mjs
var import_react28 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function spacingResolver(value, theme) {
  if (typeof value === "number") {
    return rem(value);
  }
  if (typeof value === "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing)) {
      return rem(value);
    }
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}

// node_modules/@mantine/core/esm/core/Box/style-props/resolvers/index.mjs
var resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  radius: radiusResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/sort-media-queries.mjs
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const breakpoints = Object.keys(media);
  const sortedMedia = breakpoints.sort((a, b) => Number(replaceMediaQuery(a)) - Number(replaceMediaQuery(b))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}

// node_modules/@mantine/core/esm/core/Box/style-props/parse-style-props/parse-style-props.mjs
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp !== "object" || styleProp === null) {
    return false;
  }
  const breakpoints = Object.keys(styleProp);
  if (breakpoints.length === 1 && breakpoints[0] === "base") {
    return false;
  }
  return true;
}
function getBaseValue2(value) {
  if (typeof value === "object" && value !== null) {
    if ("base" in value) {
      return value.base;
    }
    return void 0;
  }
  return value;
}
function getBreakpointKeys(value) {
  if (typeof value === "object" && value !== null) {
    return keys(value).filter((key) => key !== "base");
  }
  return [];
}
function getBreakpointValue2(value, breakpoint) {
  if (typeof value === "object" && value !== null && breakpoint in value) {
    return value[breakpoint];
  }
  return value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(
    keys(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx") {
          return acc;
        }
        const propertyData = data[styleProp];
        const properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property];
        const baseValue = getBaseValue2(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp])) {
          properties.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
          });
          return acc;
        }
        acc.hasResponsiveStyles = true;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        properties.forEach((property) => {
          if (baseValue != null) {
            acc.styles[property] = resolvers[propertyData.type](baseValue, theme);
          }
          breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue2(styleProps[styleProp], breakpoint),
                theme
              )
            };
          });
        });
        return acc;
      },
      {
        hasResponsiveStyles: false,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}

// node_modules/@mantine/core/esm/core/Box/use-random-classname/use-random-classname.mjs
var import_react30 = __toESM(require_react(), 1);
function useRandomClassName() {
  const id = (0, import_react30.useId)().replace(/[:]/g, "");
  return `__m__-${id}`;
}

// node_modules/@mantine/core/esm/core/Box/Box.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/core/factory/create-polymorphic-component.mjs
function createPolymorphicComponent(component) {
  return component;
}

// node_modules/@mantine/core/esm/core/Box/get-box-mod/get-box-mod.mjs
function transformModKey(key) {
  return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key) => {
    const value = props[key];
    if (value === void 0 || value === "" || value === false || value === null) {
      return acc;
    }
    acc[transformModKey(key)] = props[key];
    return acc;
  }, {});
}
function getBoxMod(mod) {
  if (!mod) {
    return null;
  }
  if (typeof mod === "string") {
    return { [transformModKey(mod)]: true };
  }
  if (Array.isArray(mod)) {
    return [...mod].reduce(
      (acc, value) => ({ ...acc, ...getBoxMod(value) }),
      {}
    );
  }
  return getMod(mod);
}

// node_modules/@mantine/core/esm/core/Box/get-box-style/get-box-style.mjs
function mergeStyles(styles, theme) {
  if (Array.isArray(styles)) {
    return [...styles].reduce(
      (acc, item) => ({ ...acc, ...mergeStyles(item, theme) }),
      {}
    );
  }
  if (typeof styles === "function") {
    return styles(theme);
  }
  if (styles == null) {
    return {};
  }
  return styles;
}
function getBoxStyle({
  theme,
  style,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style, theme);
  const _vars = mergeStyles(vars, theme);
  return { ..._style, ..._vars, ...styleProps };
}

// node_modules/@mantine/core/esm/core/Box/Box.mjs
var _Box = (0, import_react31.forwardRef)(
  ({
    component,
    style,
    __vars,
    className,
    variant,
    mod,
    size,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    const theme = useMantineTheme();
    const Element = component || "div";
    const { styleProps, rest } = extractStyleProps(others);
    const useSxTransform = useMantineSxTransform();
    const transformedSx = useSxTransform?.()?.(styleProps.sx);
    const responsiveClassName = useRandomClassName();
    const parsedStyleProps = parseStyleProps({
      styleProps,
      theme,
      data: STYlE_PROPS_DATA
    });
    const props = {
      ref,
      style: getBoxStyle({
        theme,
        style,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx_default(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size) ? void 0 : size || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot === "function" ? renderRoot(props) : /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Element, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
var Box = createPolymorphicComponent(_Box);

// node_modules/@mantine/core/esm/core/factory/factory.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);
function identity(value) {
  return value;
}
function factory(ui) {
  const Component = (0, import_react32.forwardRef)(ui);
  Component.extend = identity;
  Component.withProps = (fixedProps) => {
    const Extended = (0, import_react32.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Component, { ...fixedProps, ...props, ref }));
    Extended.extend = Component.extend;
    Extended.displayName = `WithProps(${Component.displayName})`;
    return Extended;
  };
  return Component;
}

// node_modules/@mantine/core/esm/core/factory/polymorphic-factory.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);
function polymorphicFactory(ui) {
  const Component = (0, import_react33.forwardRef)(ui);
  Component.withProps = (fixedProps) => {
    const Extended = (0, import_react33.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Component, { ...fixedProps, ...props, ref }));
    Extended.extend = Component.extend;
    Extended.displayName = `WithProps(${Component.displayName})`;
    return Extended;
  };
  Component.extend = identity;
  return Component;
}

// node_modules/@mantine/core/esm/core/DirectionProvider/DirectionProvider.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);
var DirectionContext = (0, import_react34.createContext)({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return (0, import_react34.useContext)(DirectionContext);
}

// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.module.css.mjs
var classes = { "root": "m_87cf2631" };

// node_modules/@mantine/core/esm/components/UnstyledButton/UnstyledButton.mjs
var defaultProps = {
  __staticSelector: "UnstyledButton"
};
var UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps, _props);
    const {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style,
      attributes,
      ...others
    } = props;
    const getStyles = useStyles({
      name: __staticSelector,
      props,
      classes,
      className,
      style,
      classNames,
      styles,
      unstyled,
      attributes
    });
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
      Box,
      {
        ...getStyles("root", { focusable: true }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";

// node_modules/@mantine/core/esm/components/Accordion/AccordionChevron.mjs
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
function AccordionChevron({ style, size = 16, ...others }) {
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style, width: rem(size), height: rem(size), display: "block" },
      ...others,
      children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        "path",
        {
          d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
AccordionChevron.displayName = "@mantine/core/AccordionChevron";

// node_modules/@mantine/carousel/esm/Carousel.mjs
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);

// node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js
var import_react37 = __toESM(require_react(), 1);

// node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js
function isObject2(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function isRecord(subject) {
  return isObject2(subject) || Array.isArray(subject);
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function areOptionsEqual(optionsA, optionsB) {
  const optionsAKeys = Object.keys(optionsA);
  const optionsBKeys = Object.keys(optionsB);
  if (optionsAKeys.length !== optionsBKeys.length) return false;
  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
  if (breakpointsA !== breakpointsB) return false;
  return optionsAKeys.every((key) => {
    const valueA = optionsA[key];
    const valueB = optionsB[key];
    if (typeof valueA === "function") return `${valueA}` === `${valueB}`;
    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;
    return areOptionsEqual(valueA, valueB);
  });
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map((plugin) => plugin.options);
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length) return false;
  const optionsA = sortAndMapPluginToOptions(pluginsA);
  const optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every((optionA, index) => {
    const optionB = optionsB[index];
    return areOptionsEqual(optionA, optionB);
  });
}

// node_modules/embla-carousel/esm/embla-carousel.esm.js
function isNumber(subject) {
  return typeof subject === "number";
}
function isString(subject) {
  return typeof subject === "string";
}
function isBoolean(subject) {
  return typeof subject === "boolean";
}
function isObject3(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function mathAbs(n) {
  return Math.abs(n);
}
function mathSign(n) {
  return Math.sign(n);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index) {
  return index === arrayLastIndex(array);
}
function arrayFromNumber(n, startAt = 0) {
  return Array.from(Array(n), (_, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach((key) => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject3(valueA) && isObject3(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
}
function Alignment(align, viewSize) {
  const predefined = {
    start,
    center,
    end
  };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return viewSize - n;
  }
  function measure(n, index) {
    if (isString(align)) return predefined[align](n);
    return align(viewSize, n, index);
  }
  const self2 = {
    measure
  };
  return self2;
}
function EventStore() {
  let listeners = [];
  function add(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ("addEventListener" in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners.push(removeListener);
    return self2;
  }
  function clear() {
    listeners = listeners.filter((remove) => remove());
  }
  const self2 = {
    add,
    clear
  };
  return self2;
}
function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1e3 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) {
      lastTimeStamp = timeStamp;
      update();
      update();
    }
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha2 = accumulatedTime / fixedTimeStep;
    render(alpha2);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self2 = {
    init,
    destroy,
    start,
    stop,
    update,
    render
  };
  return self2;
}
function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === "rtl";
  const isVertical = axis === "y";
  const scroll = isVertical ? "y" : "x";
  const cross = isVertical ? "x" : "y";
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return "top";
    return isRightToLeft ? "right" : "left";
  }
  function getEndEdge() {
    if (isVertical) return "bottom";
    return isRightToLeft ? "left" : "right";
  }
  function direction(n) {
    return n * sign;
  }
  const self2 = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self2;
}
function Limit(min = 0, max = 0) {
  const length = mathAbs(min - max);
  function reachedMin(n) {
    return n < min;
  }
  function reachedMax(n) {
    return n > max;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n)) return n;
    return reachedMin(n) ? min : max;
  }
  function removeOffset(n) {
    if (!length) return n;
    return n - length * Math.ceil((n - max) / length);
  }
  const self2 = {
    length,
    max,
    min,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self2;
}
function Counter(max, start, loop) {
  const {
    constrain
  } = Limit(0, max);
  const loopEnd = max + 1;
  let counter = withinLimit(start);
  function withinLimit(n) {
    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
  }
  function get() {
    return counter;
  }
  function set(n) {
    counter = withinLimit(n);
    return self2;
  }
  function add(n) {
    return clone().set(get() + n);
  }
  function clone() {
    return Counter(max, get(), loop);
  }
  const self2 = {
    get,
    set,
    add,
    clone
  };
  return self2;
}
function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, "touchmove", () => void 0, nonPassiveEvent).add(node, "touchend", () => void 0).add(node, "touchstart", downIfAllowed).add(node, "mousedown", downIfAllowed).add(node, "touchcancel", up).add(node, "contextmenu", up).add(node, "click", click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, "touchmove", move, nonPassiveEvent).add(node, "touchend", up).add(node, "mousemove", move, nonPassiveEvent).add(node, "mouseup", up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || "";
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? "mouse" : "touch";
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit("pointerDown");
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit("pointerUp");
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self2 = {
    init,
    destroy,
    pointerDown
  };
  return self2;
}
function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === "x" ? "X" : "Y"}`;
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self2 = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self2;
}
function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset;
  }
  const self2 = {
    measure
  };
  return self2;
}
function PercentOfView(viewSize) {
  function measure(n) {
    return viewSize * (n / 100);
  }
  const self2 = {
    measure
  };
  return self2;
}
function ResizeHandler(container2, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container2].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container2);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container2;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container2 : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit("resize");
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver((entries) => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach((node) => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self2;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 1e-3;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n) {
    scrollDuration = n;
    return self2;
  }
  function useFriction(n) {
    scrollFriction = n;
    return self2;
  }
  const self2 = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self2;
}
function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target.get())) return false;
    if (!limit.reachedAny(location.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location.get()) ? "min" : "max";
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self2 = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self2;
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min = snapsBounded.lastIndexOf(startSnap);
    const max = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min, max);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index) => {
      const {
        min,
        max
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index;
      const isLast = arrayIsLastIndex(snapsAligned, index);
      if (isFirst) return max;
      if (isLast) return min;
      if (usePixelTolerance(min, snap)) return min;
      if (usePixelTolerance(max, snap)) return max;
      return snap;
    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === "keepSnaps") return snapsBounded;
    const {
      min,
      max
    } = scrollContainLimit;
    return snapsBounded.slice(min, max);
  }
  const self2 = {
    snapsContained,
    scrollContainLimit
  };
  return self2;
}
function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max = scrollSnaps[0];
  const min = loop ? max - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min, max);
  const self2 = {
    limit
  };
  return self2;
}
function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min = limit.min + jointSafety;
  const max = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min, max);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location.get());
    if (direction === -1) return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach((v) => v.add(loopDistance));
  }
  const self2 = {
    loop
  };
  return self2;
}
function ScrollProgress(limit) {
  const {
    max,
    length
  } = limit;
  function get(n) {
    const currentLocation = n - max;
    return length ? currentLocation / -length : 0;
  }
  const self2 = {
    get
  };
  return self2;
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments[index]);
  }
  const self2 = {
    snaps,
    snapsAligned
  };
  return self2;
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min,
    max
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === "keepSnaps";
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(groups, index);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self2 = {
    slideRegistry
  };
  return self2;
}
function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index2) => ({
      diff: shortcut(snap - distance, 0),
      index: index2
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index
    } = ascDiffsToSnaps[0];
    return {
      index,
      distance
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop) return target;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter((t) => mathSign(t) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index, direction) {
    const diffToSnap = scrollSnaps[index] - targetVector.get();
    const distance = shortcut(diffToSnap, direction);
    return {
      index,
      distance
    };
  }
  function byDistance(distance, snap) {
    const target = targetVector.get() + distance;
    const {
      index,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound) return {
      index,
      distance
    };
    const diffToSnap = scrollSnaps[index] - targetSnapDistance;
    const snapDistance = distance + shortcut(diffToSnap, 0);
    return {
      index,
      distance: snapDistance
    };
  }
  const self2 = {
    byDistance,
    byIndex,
    shortcut
  };
  return self2;
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit("select");
    }
  }
  function distance(n, snap) {
    const target = scrollTarget.byDistance(n, snap);
    scrollTo(target);
  }
  function index(n, direction) {
    const targetIndex = indexCurrent.clone().set(n);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self2 = {
    distance,
    index
  };
  return self2;
}
function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index) {
      const nowTime = (/* @__PURE__ */ new Date()).getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit("slideFocusStart");
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex((group2) => group2.includes(index));
      if (!isNumber(group)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit("slideFocus");
    }
    eventStore.add(document, "keydown", registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, "focus", (evt) => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
  }
  const self2 = {
    init
  };
  return self2;
}
function Vector1D(initialValue) {
  let value = initialValue;
  function get() {
    return value;
  }
  function set(n) {
    value = normalizeInput(n);
  }
  function add(n) {
    value += normalizeInput(n);
  }
  function subtract(n) {
    value -= normalizeInput(n);
  }
  function normalizeInput(n) {
    return isNumber(n) ? n : n.get();
  }
  const self2 = {
    get,
    set,
    add,
    subtract
  };
  return self2;
}
function Translate(axis, container2) {
  const translate = axis.scroll === "x" ? x : y;
  const containerStyle = container2.style;
  let previousTarget = null;
  let disabled = false;
  function x(n) {
    return `translate3d(${n}px,0px,0px)`;
  }
  function y(n) {
    return `translate3d(0px,${n}px,0px)`;
  }
  function to(target) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = "";
    if (!container2.getAttribute("style")) container2.removeAttribute("style");
  }
  const self2 = {
    clear,
    to,
    toggleActive
  };
  return self2;
}
function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset) {
    return snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + roundingSafety + offset,
      end: snap + viewSize - roundingSafety + offset
    }));
  }
  function findLoopPoints(indexes, offset, isEndEdge) {
    const slideBounds = findSlideBounds(offset);
    return indexes.map((index) => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? "end" : "start";
      const loopPoint = slideBounds[index][boundEdge];
      return {
        index,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index
    }) => {
      const otherIndexes = ascItems.filter((i) => i !== index);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach((loopPoint) => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get()) return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
  }
  const self2 = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self2;
}
function SlidesHandler(container2, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          emblaApi.reInit();
          eventHandler.emit("slidesChanged");
          break;
        }
      }
    }
    mutationObserver = new MutationObserver((mutations) => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container2, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function SlidesInView(container2, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver((entries) => {
      if (destroyed) return;
      entries.forEach((entry) => {
        const index = slides.indexOf(entry.target);
        intersectionEntryMap[index] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit("slidesInView");
    }, {
      root: container2.parentElement,
      threshold
    });
    slides.forEach((slide) => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index);
      return list;
    }, []);
  }
  function get(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self2 = {
    init,
    destroy,
    get
  };
  return self2;
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(rects, index);
      if (isFirst) return slideSizes[index] + startGap;
      if (isLast) return slideSizes[index] + endGap;
      return rects[index + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self2 = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self2;
}
function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index, groups) => {
      const previousSize = Math.max(groups[index - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self2 = {
    groupSlides
  };
  return self2;
}
function Engine(root, container2, slides, ownerDocument, ownerWindow, options, eventHandler) {
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container2);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index.clone();
  const slideIndexes = arrayKeys(slides);
  const update = ({
    dragHandler,
    scrollBody: scrollBody2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }) => {
    if (!loop2) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody2.seek();
  };
  const render = ({
    scrollBody: scrollBody2,
    translate,
    location: location2,
    offsetLocation: offsetLocation2,
    previousLocation: previousLocation2,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation: animation2,
    eventHandler: eventHandler2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }, alpha2) => {
    const shouldSettle = scrollBody2.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
    if (hasSettledAndIdle) animation2.stop();
    const interpolatedLocation = location2.get() * alpha2 + previousLocation2.get() * (1 - alpha2);
    offsetLocation2.set(interpolatedLocation);
    if (loop2) {
      scrollLooper.loop(scrollBody2.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation2.get());
    if (hasSettledAndIdle) eventHandler2.emit("settle");
    if (!hasSettled) eventHandler2.emit("scroll");
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha2) => render(engine, alpha2));
  const friction = 0.68;
  const startLocation = scrollSnaps[index.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container2, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container2, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container2, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container2)
  };
  return engine;
}
function EventHandler() {
  let listeners = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach((e) => e(api, evt));
    return self2;
  }
  function on(evt, cb) {
    listeners[evt] = getListeners(evt).concat([cb]);
    return self2;
  }
  function off(evt, cb) {
    listeners[evt] = getListeners(evt).filter((e) => e !== cb);
    return self2;
  }
  function clear() {
    listeners = {};
  }
  const self2 = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self2;
}
var defaultOptions = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia2 = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self2 = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self2;
}
function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter((plugin) => plugin.destroy());
  }
  const self2 = {
    init,
    destroy
  };
  return self2;
}
function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container2;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container2 = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container2.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container2.children);
  }
  function createEngine(options2) {
    const engine2 = Engine(root, container2, slides, ownerDocument, ownerWindow, options2, eventHandler);
    if (options2.loop && !engine2.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options2, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine2;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options: options2
    }) => options2)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self2);
    engine.eventHandler.init(self2);
    engine.resizeHandler.init(self2);
    engine.slidesHandler.init(self2);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container2.offsetParent && slides.length) engine.dragHandler.init(self2);
    pluginApis = pluginsHandler.init(self2, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit("reInit");
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit("destroy");
    eventHandler.clear();
  }
  function scrollTo(index, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container2;
  }
  function slideNodes() {
    return slides;
  }
  const self2 = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit("init"), 0);
  return self2;
}
EmblaCarousel.globalOptions = void 0;

// node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js
function useEmblaCarousel(options = {}, plugins = []) {
  const storedOptions = (0, import_react37.useRef)(options);
  const storedPlugins = (0, import_react37.useRef)(plugins);
  const [emblaApi, setEmblaApi] = (0, import_react37.useState)();
  const [viewport, setViewport] = (0, import_react37.useState)();
  const reInit = (0, import_react37.useCallback)(() => {
    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);
  }, [emblaApi]);
  (0, import_react37.useEffect)(() => {
    if (areOptionsEqual(storedOptions.current, options)) return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  (0, import_react37.useEffect)(() => {
    if (arePluginsEqual(storedPlugins.current, plugins)) return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  (0, import_react37.useEffect)(() => {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmblaApi(newEmblaApi);
      return () => newEmblaApi.destroy();
    } else {
      setEmblaApi(void 0);
    }
  }, [viewport, setEmblaApi]);
  return [setViewport, emblaApi];
}
useEmblaCarousel.globalOptions = void 0;

// node_modules/@mantine/carousel/esm/Carousel.context.mjs
var [CarouselProvider, useCarouselContext] = createSafeContext(
  "Carousel component was not found in tree"
);

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.mjs
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/carousel/esm/Carousel.module.css.mjs
var classes2 = { "root": "m_17884d0f", "viewport": "m_a2dae653", "container": "m_fcd81474", "controls": "m_39bc3463", "control": "m_64f58e10", "indicators": "m_71ea3ab1", "indicator": "m_eae68602", "slide": "m_d98df724" };

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.mjs
var CarouselSlide = factory((props, ref) => {
  const { classNames, className, style, styles, vars, mod, ...others } = useProps(
    "CarouselSlide",
    null,
    props
  );
  const ctx = useCarouselContext();
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
    Box,
    {
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      ...ctx.getStyles("slide", { className, style, classNames, styles }),
      ...others
    }
  );
});
CarouselSlide.classes = classes2;
CarouselSlide.displayName = "@mantine/carousel/CarouselSlide";

// node_modules/@mantine/carousel/esm/CarouselVariables/CarouselVariables.mjs
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function CarouselVariables({ slideGap, slideSize, selector }) {
  const theme = useMantineTheme();
  const baseStyles = filterProps({
    "--carousel-slide-gap": getSpacing(getBaseValue(slideGap)),
    "--carousel-slide-size": rem(getBaseValue(slideSize))
  });
  const queries = keys(theme.breakpoints).reduce(
    (acc, breakpoint) => {
      if (!acc[breakpoint]) {
        acc[breakpoint] = {};
      }
      if (typeof slideGap === "object" && slideGap[breakpoint] !== void 0) {
        acc[breakpoint]["--carousel-slide-gap"] = getSpacing(slideGap[breakpoint]);
      }
      if (typeof slideSize === "object" && slideSize[breakpoint] !== void 0) {
        acc[breakpoint]["--carousel-slide-size"] = getSpacing(slideSize[breakpoint]);
      }
      return acc;
    },
    {}
  );
  const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme.breakpoints).filter(
    (breakpoint) => keys(queries[breakpoint.value]).length > 0
  );
  const media = sortedBreakpoints.map((breakpoint) => ({
    query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(InlineStyles, { styles: baseStyles, media, selector });
}
function getBreakpoints(values2) {
  if (typeof values2 === "object" && values2 !== null) {
    return keys(values2);
  }
  return [];
}
function sortBreakpoints(breakpoints) {
  return breakpoints.sort((a, b) => px(a) - px(b));
}
function getUniqueBreakpoints({ slideGap, slideSize }) {
  const breakpoints = Array.from(
    /* @__PURE__ */ new Set([...getBreakpoints(slideGap), ...getBreakpoints(slideSize)])
  );
  return sortBreakpoints(breakpoints);
}
function CarouselContainerVariables({
  slideGap,
  slideSize,
  selector
}) {
  const baseStyles = filterProps({
    "--carousel-slide-gap": getSpacing(getBaseValue(slideGap)),
    "--carousel-slide-size": rem(getBaseValue(slideSize))
  });
  const queries = getUniqueBreakpoints({ slideGap, slideSize }).reduce((acc, breakpoint) => {
    if (!acc[breakpoint]) {
      acc[breakpoint] = {};
    }
    if (typeof slideGap === "object" && slideGap[breakpoint] !== void 0) {
      acc[breakpoint]["--carousel-slide-gap"] = getSpacing(slideGap[breakpoint]);
    }
    if (typeof slideSize === "object" && slideSize[breakpoint] !== void 0) {
      acc[breakpoint]["--carousel-slide-size"] = getSpacing(slideSize[breakpoint]);
    }
    return acc;
  }, {});
  const media = Object.keys(queries).map((breakpoint) => ({
    query: `carousel (min-width: ${breakpoint})`,
    styles: queries[breakpoint]
  }));
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(InlineStyles, { styles: baseStyles, container: media, selector });
}

// node_modules/@mantine/carousel/esm/get-chevron-rotation.mjs
function getChevronRotation({ dir, orientation, direction }) {
  if (direction === "previous") {
    return orientation === "horizontal" ? 90 * (dir === "ltr" ? 1 : -1) : -180;
  }
  return orientation === "horizontal" ? 90 * (dir === "ltr" ? -1 : 1) : 0;
}

// node_modules/@mantine/carousel/esm/Carousel.mjs
var defaultProps2 = {
  controlSize: 26,
  controlsOffset: "sm",
  slideSize: "100%",
  slideGap: 0,
  orientation: "horizontal",
  includeGapInSize: true,
  initialSlide: 0,
  withControls: true,
  withIndicators: false,
  withKeyboardEvents: true,
  type: "media"
};
var defaultEmblaOptions = {
  align: "center",
  loop: false,
  slidesToScroll: 1,
  dragFree: false,
  inViewThreshold: 0,
  skipSnaps: false,
  containScroll: "trimSnaps"
};
var varsResolver = createVarsResolver(
  (_, { height, controlSize, controlsOffset }) => ({
    root: {
      "--carousel-height": rem(height),
      "--carousel-control-size": rem(controlSize),
      "--carousel-controls-offset": getSpacing(controlsOffset)
    }
  })
);
var Carousel = factory((_props, ref) => {
  const props = useProps("Carousel", defaultProps2, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    children,
    getEmblaApi,
    onNextSlide,
    onPreviousSlide,
    onSlideChange,
    nextControlProps,
    previousControlProps,
    controlSize,
    controlsOffset,
    slideSize,
    slideGap,
    orientation,
    height,
    includeGapInSize,
    draggable,
    initialSlide,
    withControls,
    withIndicators,
    plugins,
    nextControlIcon,
    previousControlIcon,
    withKeyboardEvents,
    mod,
    type,
    emblaOptions,
    attributes,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "Carousel",
    classes: classes2,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver
  });
  const responsiveClassName = useRandomClassName();
  const { dir } = useDirection();
  const [emblaRefElement, embla] = useEmblaCarousel(
    {
      axis: orientation === "horizontal" ? "x" : "y",
      direction: orientation === "horizontal" ? dir : void 0,
      startIndex: initialSlide,
      ...defaultEmblaOptions,
      ...emblaOptions
    },
    plugins
  );
  const [selected, setSelected] = (0, import_react38.useState)(0);
  const [slidesCount, setSlidesCount] = (0, import_react38.useState)(0);
  const handleScroll = (0, import_react38.useCallback)((index) => embla && embla.scrollTo(index), [embla]);
  const handleSelect = (0, import_react38.useCallback)(() => {
    if (!embla) {
      return;
    }
    const slide = embla.selectedScrollSnap();
    setSelected(slide);
    slide !== selected && onSlideChange?.(slide);
  }, [embla, setSelected, onSlideChange, selected]);
  const handlePrevious = (0, import_react38.useCallback)(() => {
    embla?.scrollPrev();
    onPreviousSlide?.();
  }, [embla]);
  const handleNext = (0, import_react38.useCallback)(() => {
    embla?.scrollNext();
    onNextSlide?.();
  }, [embla]);
  const handleKeydown = (0, import_react38.useCallback)(
    (event) => {
      if (withKeyboardEvents) {
        if (event.key === "ArrowRight") {
          event.preventDefault();
          handleNext();
        }
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          handlePrevious();
        }
      }
    },
    [embla]
  );
  (0, import_react38.useEffect)(() => {
    if (embla) {
      getEmblaApi?.(embla);
      handleSelect();
      setSlidesCount(embla.scrollSnapList().length);
      embla.on("select", handleSelect);
      return () => {
        embla.off("select", handleSelect);
      };
    }
    return void 0;
  }, [embla, emblaOptions?.slidesToScroll, handleSelect]);
  (0, import_react38.useEffect)(() => {
    if (embla) {
      embla.reInit();
      setSlidesCount(embla.scrollSnapList().length);
      setSelected(
        (currentSelected) => clamp(currentSelected, 0, import_react38.Children.toArray(children).length - 1)
      );
    }
  }, [import_react38.Children.toArray(children).length, emblaOptions?.slidesToScroll]);
  const canScrollPrev = embla?.canScrollPrev() || false;
  const canScrollNext = embla?.canScrollNext() || false;
  const indicators = Array(slidesCount).fill(0).map((_, index) => /* @__PURE__ */ (0, import_react38.createElement)(
    UnstyledButton,
    {
      ...getStyles("indicator"),
      key: index,
      "data-active": index === selected || void 0,
      "aria-hidden": true,
      tabIndex: -1,
      onClick: () => handleScroll(index),
      "data-orientation": orientation,
      onMouseDown: (event) => event.preventDefault()
    }
  ));
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(CarouselProvider, { value: { getStyles, orientation }, children: [
    type === "container" ? /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(CarouselContainerVariables, { ...props, selector: `.${responsiveClassName}` }) : /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(CarouselVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(
      Box,
      {
        ref,
        ...getStyles("root", { className: "responsiveClassName" }),
        ...others,
        mod: [{ orientation, "include-gap-in-size": includeGapInSize }, mod],
        onKeyDownCapture: handleKeydown,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { ...getStyles("viewport"), ref: emblaRefElement, "data-type": type, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
            "div",
            {
              ...getStyles("container", { className: responsiveClassName }),
              "data-orientation": orientation,
              children
            }
          ) }),
          withIndicators && /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { ...getStyles("indicators"), "data-orientation": orientation, children: indicators }),
          withControls && /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { ...getStyles("controls"), "data-orientation": orientation, children: [
            /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
              UnstyledButton,
              {
                ...previousControlProps,
                ...getStyles("control", {
                  className: previousControlProps?.className,
                  style: previousControlProps?.style
                }),
                onClick: (event) => {
                  handlePrevious();
                  previousControlProps?.onClick?.(event);
                },
                "data-inactive": !canScrollPrev || void 0,
                "data-type": "previous",
                tabIndex: canScrollPrev ? 0 : -1,
                children: typeof previousControlIcon !== "undefined" ? previousControlIcon : /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
                  AccordionChevron,
                  {
                    style: {
                      transform: `rotate(${getChevronRotation({
                        dir,
                        orientation,
                        direction: "previous"
                      })}deg)`
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
              UnstyledButton,
              {
                ...getStyles("control", {
                  className: nextControlProps?.className,
                  style: nextControlProps?.style
                }),
                ...nextControlProps,
                onClick: (event) => {
                  handleNext();
                  nextControlProps?.onClick?.(event);
                },
                "data-inactive": !canScrollNext || void 0,
                "data-type": "next",
                tabIndex: canScrollNext ? 0 : -1,
                children: typeof nextControlIcon !== "undefined" ? nextControlIcon : /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
                  AccordionChevron,
                  {
                    style: {
                      transform: `rotate(${getChevronRotation({
                        dir,
                        orientation,
                        direction: "next"
                      })}deg)`
                    }
                  }
                )
              }
            )
          ] })
        ]
      }
    )
  ] });
});
Carousel.classes = classes2;
Carousel.displayName = "@mantine/carousel/Carousel";
Carousel.Slide = CarouselSlide;

// src/homeflow/index.tsx
var import_mapbox_gl = __toESM(require_mapbox_gl(), 1);

// src/shared/openai.ts
var import_react39 = __toESM(require_react(), 1);
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";
var isOpenAiAvailable = () => typeof window !== "undefined" && typeof window.openai === "object" && window.openai !== null;
var useIsOpenAiAvailable = () => {
  const [available, setAvailable] = (0, import_react39.useState)(() => isOpenAiAvailable());
  (0, import_react39.useEffect)(() => {
    if (available) return;
    const id = window.setInterval(() => {
      if (isOpenAiAvailable()) {
        setAvailable(true);
        window.clearInterval(id);
      }
    }, 200);
    return () => window.clearInterval(id);
  }, [available]);
  return available;
};
var getOpenAi = () => {
  if (typeof window === "undefined") return void 0;
  return window.openai;
};
var useOpenAiGlobal = (key) => (0, import_react39.useSyncExternalStore)(
  (onChange) => {
    const openai = getOpenAi();
    if (!openai) {
      return () => void 0;
    }
    const handler = (event) => {
      const globalsEvent = event;
      const value = globalsEvent.detail.globals[key];
      if (value !== void 0) {
        onChange();
      }
    };
    window.addEventListener(SET_GLOBALS_EVENT_TYPE, handler, { passive: true });
    return () => window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handler);
  },
  () => {
    const openai = getOpenAi();
    return openai ? openai[key] : void 0;
  },
  () => void 0
);
var useToolInput = () => useOpenAiGlobal("toolInput") ?? void 0;
var useToolOutput = () => useOpenAiGlobal("toolOutput");
var extractWidgetData = (toolOutput) => {
  if (!toolOutput || typeof toolOutput !== "object") return void 0;
  const container2 = toolOutput;
  if (container2.widgetData && typeof container2.widgetData === "object") {
    return container2.widgetData;
  }
  const direct = container2._meta?.widgetData;
  if (direct && typeof direct === "object") {
    return direct;
  }
  const nested = container2.toolResult?._meta?.widgetData;
  if (nested && typeof nested === "object") {
    return nested;
  }
  return toolOutput;
};
var useWidgetDataFromToolOutput = () => {
  const toolOutput = useToolOutput();
  return (0, import_react39.useMemo)(() => extractWidgetData(toolOutput), [toolOutput]);
};

// src/homeflow/index.tsx
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var ROOT_ID = "homeflow-root";
var DATA_ATTR = "data-homeflow-config";
var variantToClass = (variant) => {
  switch (variant) {
    case "primary":
      return "bg-emerald-500 hover:bg-emerald-400 text-slate-950";
    case "secondary":
      return "bg-slate-800 hover:bg-slate-700 text-white border border-slate-600";
    case "ghost":
      return "bg-transparent border border-slate-700 text-slate-200 hover:bg-slate-800";
    case "danger":
      return "bg-red-500 hover:bg-red-400 text-white";
    default:
      return "bg-slate-800 hover:bg-slate-700 text-white";
  }
};
var formatCurrency = (amount, currency = "MYR") => {
  if (typeof amount !== "number" || Number.isNaN(amount)) return "";
  try {
    return new Intl.NumberFormat("en-MY", { style: "currency", currency, maximumFractionDigits: 0 }).format(amount);
  } catch {
    return `${currency} ${amount}`;
  }
};
var MAPBOX_TOKEN = "pk.eyJ1IjoiZXJpY25pbmciLCJhIjoiY21icXlubWM1MDRiczJvb2xwM2p0amNyayJ9.n-3O6JI5nOp_Lw96ZO5vJQ";
var getHostApi = () => {
  if (typeof window === "undefined") return void 0;
  const api = window.openai ?? window.oai?.widget ?? null;
  if (!api || typeof api !== "object") return void 0;
  if (typeof api.callTool === "function") {
    return api;
  }
  const callTool = api.callTool ? api.callTool : window.openai?.callTool;
  if (!callTool) return void 0;
  return { ...api, callTool };
};
var readInitialConfig = () => {
  if (typeof document === "undefined") {
    return { view: "error", title: "HomeFlow", description: "UI not available." };
  }
  const container2 = document.getElementById(ROOT_ID);
  const raw = container2?.getAttribute(DATA_ATTR);
  if (!raw || raw === "__HOMEFLOW_CONFIG_JSON__") {
    return {
      view: "error",
      title: "Loading HomeFlow\u2026",
      description: "Please try again shortly."
    };
  }
  try {
    return JSON.parse(raw);
  } catch (error) {
    console.error("[HomeFlow] Failed to parse config:", error);
    return {
      view: "error",
      title: "HomeFlow unavailable",
      description: "We couldn't render the latest data."
    };
  }
};
var useHomeflowConfig = () => {
  const openAiAvailable = useIsOpenAiAvailable();
  const widgetData = useWidgetDataFromToolOutput();
  const toolInput = useToolInput();
  const [config, setConfig] = import_react40.default.useState(() => readInitialConfig());
  import_react40.default.useEffect(() => {
    if (!openAiAvailable) return;
    if (widgetData) {
      setConfig(widgetData);
      return;
    }
    if (toolInput?.view) {
      setConfig(toolInput);
    }
  }, [openAiAvailable, widgetData, toolInput]);
  return config;
};
var ActionButton = ({ action, onAction, compact }) => {
  const variantClass = variantToClass(action.variant);
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
    "button",
    {
      type: "button",
      className: clsx_default(
        "min-w-[120px] rounded-lg px-4 py-2 text-sm font-medium transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-400 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950",
        variantClass,
        compact ? "h-10" : "h-11"
      ),
      onClick: () => onAction(action),
      children: action.label
    }
  );
};
var Pill = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: "rounded-full border border-slate-700 bg-slate-900/60 px-3 py-1 text-xs font-medium text-slate-200", children });
var ProCard = ({ pro, onAction, layout = "compact" }) => {
  const expanded = layout === "expanded";
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
    "div",
    {
      className: clsx_default(
        "flex-shrink-0 rounded-2xl border border-slate-800 bg-slate-900/80 p-4 shadow-lg backdrop-blur",
        expanded ? "min-w-[280px] max-w-[320px]" : "min-w-[220px] max-w-[260px]"
      ),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center gap-3", children: [
          pro.image ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
            "img",
            {
              src: pro.image,
              alt: pro.imageAlt ?? pro.name,
              className: clsx_default(
                "rounded-full object-cover",
                expanded ? "h-16 w-16" : "h-12 w-12"
              ),
              loading: "lazy"
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
            "div",
            {
              className: clsx_default(
                "flex items-center justify-center rounded-full bg-slate-800 text-slate-100",
                expanded ? "h-16 w-16 text-xl font-bold" : "h-12 w-12 text-lg font-semibold"
              ),
              children: pro.name.slice(0, 1)
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-1", children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: clsx_default("font-semibold text-slate-100", expanded ? "text-base" : "text-sm"), children: pro.name }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: clsx_default("flex flex-wrap items-center gap-2 text-slate-300", expanded ? "text-sm" : "text-xs"), children: [
              typeof pro.rating === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
                "\u2605 ",
                pro.rating.toFixed(1),
                " (",
                pro.reviews ?? 0,
                ")"
              ] }) : null,
              pro.priceFrom !== void 0 ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: formatCurrency(pro.priceFrom, pro.currency) }) : null
            ] })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "mt-3 space-y-2", children: [
          pro.nextAvailable ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Pill, { children: [
            "Next: ",
            pro.nextAvailable.slice(0, 16)
          ] }) : null,
          typeof pro.distanceKm === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Pill, { children: [
            pro.distanceKm,
            " km away"
          ] }) : null,
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: clsx_default("flex flex-wrap gap-2", expanded ? "justify-start" : ""), children: pro.badges?.slice(0, 3).map((badge) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Pill, { children: badge }, badge)) })
        ] }),
        pro.recentReviews?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "mt-3 space-y-1", children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-xs uppercase tracking-wide text-slate-500", children: "Recent feedback" }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "rounded-xl border border-slate-800 bg-slate-900/60 p-2 text-xs text-slate-200", children: pro.recentReviews[0].review ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
            "\u201C",
            pro.recentReviews[0].review,
            "\u201D"
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
            pro.recentReviews[0].rating.toFixed(1),
            "\u2605 service"
          ] }) })
        ] }) : null,
        pro.actions && pro.actions.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-4 flex flex-wrap gap-2", children: pro.actions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction, compact: true }, `${pro.id}-${action.label}`)) }) : null
      ]
    }
  );
};
var InfoRow = ({ label, value }) => {
  if (!value) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-start justify-between gap-3 text-sm", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: "text-slate-400", children: label }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: "text-right text-slate-100", children: value })
  ] });
};
var Notifications = ({ items }) => {
  if (!items?.length) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-4 space-y-2", children: items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "rounded-lg border border-emerald-500/50 bg-emerald-500/10 px-4 py-3 text-sm text-emerald-200", children: item }, item)) });
};
var VIEW_LABELS = {
  list: "List",
  carousel: "Carousel",
  map: "Map"
};
var ViewSwitcher = ({ views, active, onChange }) => {
  if (!views || views.length <= 1) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap items-center gap-2", children: views.map((view) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
    "button",
    {
      type: "button",
      className: clsx_default(
        "rounded-full px-4 py-2 text-sm font-medium transition-colors",
        active === view ? "bg-emerald-500/90 text-slate-950" : "bg-slate-900 text-slate-300 hover:bg-slate-800"
      ),
      onClick: () => onChange(view),
      children: VIEW_LABELS[view] ?? view
    },
    view
  )) });
};
var SearchCarousel = ({ pros, onAction }) => {
  if (!pros?.length) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Carousel, { slideSize: "260px", slideGap: "md", align: "start", containScroll: "trimSnaps", children: pros.map((pro) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Carousel.Slide, { style: { display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProCard, { pro, onAction, layout: "expanded" }) }, pro.id)) });
};
var SearchList = ({ pros, onAction }) => {
  if (!pros?.length) {
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "rounded-2xl border border-slate-800 bg-slate-900/60 p-4 text-sm text-slate-300", children: "No providers found. Try adjusting the filters." });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "space-y-2", children: pros.map((pro, index) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
    "div",
    {
      className: "flex items-center justify-between gap-3 rounded-2xl border border-slate-800 bg-slate-950/80 px-4 py-3",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center gap-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex h-9 w-9 items-center justify-center rounded-full bg-slate-800 text-sm font-semibold text-slate-200", children: index + 1 }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-sm font-semibold text-slate-100", children: pro.name }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex flex-wrap items-center gap-2 text-xs text-slate-400", children: [
              typeof pro.rating === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
                "\u2605 ",
                pro.rating.toFixed(1)
              ] }) : null,
              pro.priceFrom !== void 0 ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: formatCurrency(pro.priceFrom, pro.currency) }) : null,
              typeof pro.distanceKm === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
                pro.distanceKm,
                " km away"
              ] }) : null
            ] })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: (pro.actions ?? []).filter(
          (action) => action.type === "tool" && ["See slots", "Get quote", "\u2605 Reviews"].includes(action.label)
        ).slice(0, 3).map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction, compact: true }, `${pro.id}-${action.label}`)) })
      ]
    },
    pro.id
  )) });
};
import_mapbox_gl.default.accessToken = MAPBOX_TOKEN;
var MapView = ({ map, pros, onAction }) => {
  const containerRef = import_react40.default.useRef(null);
  const mapInstance = import_react40.default.useRef(null);
  const markersRef = import_react40.default.useRef([]);
  const [selectedId, setSelectedId] = import_react40.default.useState(() => map?.selectedId ?? null);
  const proLookup = import_react40.default.useMemo(() => {
    const lookup = /* @__PURE__ */ new Map();
    (pros ?? []).forEach((card) => lookup.set(card.id, card));
    return lookup;
  }, [pros]);
  const markerKey = import_react40.default.useMemo(
    () => map?.markers ? map.markers.map((marker) => marker.id).join(",") : "",
    [map?.markers]
  );
  import_react40.default.useEffect(() => {
    const fallback = map?.selectedId ?? map?.markers?.[0]?.id ?? null;
    setSelectedId((prev) => (prev ?? fallback) === fallback ? prev ?? fallback : fallback);
  }, [map?.selectedId, markerKey]);
  import_react40.default.useEffect(() => {
    if (!containerRef.current) return;
    if (!mapInstance.current) {
      mapInstance.current = new import_mapbox_gl.default.Map({
        container: containerRef.current,
        style: "mapbox://styles/mapbox/streets-v12",
        center: map?.center ?? [101.686, 3.139],
        zoom: map?.zoom ?? 11,
        attributionControl: false
      });
      const nav = new import_mapbox_gl.default.NavigationControl({ showCompass: false });
      mapInstance.current.addControl(nav, "top-left");
    }
    return () => {
      markersRef.current.forEach((marker) => marker.remove());
      markersRef.current = [];
      if (mapInstance.current) {
        mapInstance.current.remove();
        mapInstance.current = null;
      }
    };
  }, [map]);
  import_react40.default.useEffect(() => {
    if (!map || !mapInstance.current) return;
    markersRef.current.forEach((marker) => marker.remove());
    markersRef.current = [];
    if (map.center) {
      mapInstance.current.flyTo({ center: map.center, zoom: map.zoom ?? 12, speed: 0.8 });
    }
    map.markers.forEach((marker) => {
      const instance = new import_mapbox_gl.default.Marker({
        color: marker.id === selectedId ? "#22c55e" : "#f97316"
      }).setLngLat(marker.coords).addTo(mapInstance.current);
      const el = instance.getElement();
      if (el) {
        el.style.cursor = "pointer";
        el.addEventListener("click", () => {
          setSelectedId(marker.id);
          mapInstance.current?.flyTo({ center: marker.coords, zoom: 13 });
        });
      }
      markersRef.current.push(instance);
    });
  }, [map, selectedId]);
  const selectedMarker = map?.markers?.find((marker) => marker.id === selectedId) ?? map?.markers?.[0] ?? null;
  const selectedCard = selectedMarker ? proLookup.get(selectedMarker.id) ?? pros?.find((pro) => pro.id === selectedMarker.id) ?? null : null;
  if (!map) {
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex h-[360px] w-full items-center justify-center rounded-3xl border border-slate-800 bg-slate-900/60 text-sm text-slate-300", children: "Map view unavailable." });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "grid gap-0 overflow-hidden rounded-3xl border border-slate-800 md:grid-cols-[2.2fr,1fr]", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "relative h-[360px] md:h-[420px]", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { ref: containerRef, className: "absolute inset-0" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex max-h-[420px] flex-col gap-3 overflow-y-auto border-t border-slate-800 bg-slate-950/80 p-4 md:border-t-0 md:border-l", children: (pros ?? []).map((card, index) => {
      const marker = map.markers.find((m) => m.id === card.id);
      const isActive = card.id === selectedId;
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
        "div",
        {
          onClick: () => {
            setSelectedId(card.id);
            if (marker && mapInstance.current) {
              mapInstance.current.flyTo({ center: marker.coords, zoom: 13, speed: 0.8 });
            }
          },
          className: clsx_default(
            "cursor-pointer rounded-2xl border px-4 py-3 transition",
            isActive ? "border-emerald-400 bg-slate-950" : "border-slate-800 bg-slate-900/70 hover:border-emerald-300"
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center justify-between text-sm text-slate-100", children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { className: "font-semibold", children: [
                index + 1,
                ". ",
                card.name
              ] }),
              typeof card.rating === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { className: "text-emerald-300", children: [
                "\u2605 ",
                card.rating.toFixed(1)
              ] }) : null
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "mt-1 flex flex-wrap items-center gap-2 text-xs text-slate-400", children: [
              card.priceFrom !== void 0 ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: formatCurrency(card.priceFrom, card.currency) }) : null,
              typeof card.distanceKm === "number" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { children: [
                card.distanceKm,
                " km away"
              ] }) : null
            ] }),
            card.badges?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-2 flex flex-wrap gap-2", children: card.badges.slice(0, 2).map((badge) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Pill, { children: badge }, `${card.id}-${badge}`)) }) : null,
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-3 flex flex-wrap gap-2", children: (card.actions ?? []).filter(
              (action) => action.type === "tool" && ["See slots", "Get quote", "\u2605 Reviews"].includes(action.label)
            ).slice(0, 3).map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction, compact: true }, `${card.id}-${action.label}`)) })
          ]
        },
        card.id
      );
    }) })
  ] });
};
var SlotsView = ({ config, onAction }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-5", children: [
  config.pro ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProCard, { pro: config.pro, onAction }) : null,
  /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Available slots" }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: config.slots?.map((slot) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      "button",
      {
        className: "rounded-full border border-slate-700 bg-slate-900 px-4 py-2 text-sm text-slate-100 hover:border-emerald-400 hover:text-emerald-300 focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-400",
        onClick: () => slot.primaryAction && onAction(slot.primaryAction),
        children: slot.label
      },
      slot.start
    )) })
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Notifications, { items: config.notifications })
] });
var QuoteView = ({ config, onAction }) => {
  const quote = config.quote;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-5", children: [
    config.pro ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProCard, { pro: config.pro, onAction }) : null,
    quote ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "rounded-2xl border border-slate-800 bg-slate-900/80 p-5 shadow-lg", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(InfoRow, { label: "Estimate", value: `${formatCurrency(quote.estimateLow, quote.currency)} \u2013 ${formatCurrency(quote.estimateHigh, quote.currency)}` }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(InfoRow, { label: "Valid until", value: quote.expiresAt?.slice(0, 16) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-4 flex flex-wrap gap-2", children: quote.actions?.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction }, action.label)) })
    ] }) : null,
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Notifications, { items: config.notifications })
  ] });
};
var JobCardView = ({ job, onAction }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "rounded-2xl border border-slate-800 bg-slate-900/80 p-5 shadow-lg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center justify-between text-sm text-slate-300", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: job.pro.name ?? job.pro.id }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: "uppercase tracking-wide text-emerald-300", children: job.status })
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "mt-3 space-y-3 text-sm", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(InfoRow, { label: "When", value: `${job.slot.start.slice(0, 16)} \u2192 ${job.slot.end.slice(11, 16)}` }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(InfoRow, { label: "Price", value: formatCurrency(job.priceEstimate, job.currency) }),
    job.instructions ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(InfoRow, { label: "Instructions", value: job.instructions }) : null,
    job.badges?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: job.badges.map((badge) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Pill, { children: badge }, `${job.jobId}-${badge}`)) }) : null
  ] }),
  job.actions?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-4 flex flex-wrap gap-2", children: job.actions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction }, `${job.jobId}-${action.label}`)) }) : null
] });
var HistoryList = ({
  history,
  onAction
}) => {
  if (!history?.length) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-3", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Past ratings" }),
    history.map((entry) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "rounded-xl border border-slate-800 bg-slate-900/60 p-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex flex-wrap items-center justify-between gap-3 text-sm text-slate-300", children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: entry.job.pro.name ?? entry.job.pro.id }),
        entry.rating ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { className: "text-emerald-300", children: [
          "\u2605 ",
          entry.rating.toFixed(1)
        ] }) : null
      ] }),
      entry.review ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("p", { className: "mt-2 text-sm text-slate-200", children: [
        '"',
        entry.review,
        '"'
      ] }) : null,
      entry.actions?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "mt-3 flex flex-wrap gap-2", children: entry.actions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction, compact: true }, `${entry.job.jobId}-${action.label}`)) }) : null
    ] }, entry.job.jobId))
  ] });
};
var HomeView = ({ config, onAction }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-6", children: [
  config.quickActions?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("section", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "mb-3 text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Quick actions" }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: config.quickActions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction }, action.label)) })
  ] }) : null,
  config.pricingActions?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("section", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "mb-3 text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Pricing shortcuts" }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: config.pricingActions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction }, action.label)) })
  ] }) : null,
  config.pros?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("section", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "mb-3 text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Featured pros" }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      Carousel,
      {
        slideSize: "260px",
        slideGap: "md",
        align: "start",
        containScroll: "trimSnaps",
        styles: { control: { backgroundColor: "rgba(15,23,42,0.8)", border: "1px solid rgba(148, 163, 184, 0.4)" } },
        className: "rounded-2xl border border-slate-800 bg-slate-900/40 px-3 py-4",
        children: config.pros.map((pro) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Carousel.Slide, { style: { display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProCard, { pro, onAction, layout: "expanded" }) }, pro.id))
      }
    )
  ] }) : null,
  config.manageActions?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("section", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "mb-3 text-sm font-semibold uppercase tracking-wide text-slate-400", children: "Manage bookings" }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex flex-wrap gap-2", children: config.manageActions.map((action) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ActionButton, { action, onAction }, action.label)) })
  ] }) : null
] });
var SearchView = ({ config, viewMode, setViewMode, onAction }) => {
  const views = config.viewModes ?? ["list"];
  const effectiveView = views.includes(viewMode) ? viewMode : views[0];
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ViewSwitcher, { views, active: effectiveView, onChange: setViewMode }),
    effectiveView === "carousel" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SearchCarousel, { pros: config.pros, onAction }) : effectiveView === "map" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(MapView, { map: config.map, pros: config.pros, onAction }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SearchList, { pros: config.pros, onAction }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Notifications, { items: config.notifications })
  ] });
};
var JobStatusView = ({ config, viewMode, setViewMode, onAction }) => {
  const views = config.viewModes ?? (config.map ? ["list", "map"] : ["list"]);
  const effectiveView = views.includes(viewMode) ? viewMode : views[0];
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ViewSwitcher, { views, active: effectiveView, onChange: setViewMode }),
    effectiveView === "map" && config.map ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(MapView, { map: config.map, pros: config.pros, onAction }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
      config.job ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobCardView, { job: config.job, onAction }) : null,
      config.jobs?.length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "space-y-3", children: config.jobs.map((job) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobCardView, { job, onAction }, job.jobId)) }) : null
    ] })
  ] });
};
var RateView = ({ config, onAction }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-6", children: [
  config.job ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobCardView, { job: config.job, onAction }) : null,
  /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(HistoryList, { history: config.history, onAction })
] });
var RateFormView = ({ config, onSubmit, onAction }) => {
  const form = config.reviewForm;
  const [rating, setRating] = import_react40.default.useState(form?.rating ?? 5);
  const [review, setReview] = import_react40.default.useState(form?.review ?? "");
  const [error, setError] = import_react40.default.useState(null);
  if (!form) {
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "rounded-xl border border-red-500/40 bg-red-500/10 p-4 text-sm text-red-200", children: "Unable to load review form. Try again later." });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-5", children: [
    config.job ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobCardView, { job: config.job, onAction }) : null,
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-3 rounded-2xl border border-slate-800 bg-slate-950/70 p-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("label", { className: "text-sm font-medium text-slate-200", htmlFor: "rating-input", children: "Rating (1\u20135)" }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "input",
          {
            id: "rating-input",
            type: "number",
            min: 1,
            max: 5,
            value: rating,
            onChange: (event) => setRating(Number(event.target.value)),
            className: "mt-1 w-full rounded-lg border border-slate-700 bg-slate-900 px-3 py-2 text-slate-100 focus:border-emerald-400 focus:outline-none"
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("label", { className: "text-sm font-medium text-slate-200", htmlFor: "review-input", children: "Review (optional)" }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "textarea",
          {
            id: "review-input",
            value: review,
            onChange: (event) => setReview(event.target.value),
            rows: 4,
            className: "mt-1 w-full rounded-lg border border-slate-700 bg-slate-900 px-3 py-2 text-sm text-slate-100 focus:border-emerald-400 focus:outline-none",
            placeholder: "Tell us how it went..."
          }
        )
      ] }),
      error ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-sm text-red-400", children: error }) : null,
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        "button",
        {
          type: "button",
          className: "w-full rounded-lg bg-emerald-500 px-4 py-2 text-sm font-semibold text-slate-950 transition hover:bg-emerald-400 focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-400",
          onClick: () => {
            if (!Number.isFinite(rating) || rating < 1 || rating > 5) {
              setError("Please provide a rating between 1 and 5.");
              return;
            }
            setError(null);
            onSubmit(form.jobId, Math.round(rating * 10) / 10, review.trim());
          },
          children: "Submit review"
        }
      )
    ] })
  ] });
};
var AccountView = ({ config }) => {
  const raw = config.context?.account;
  const name = raw?.name ?? "Signed-in Google user";
  const email = raw?.email ?? "Email unavailable";
  const subject = raw?.subject ?? "Unknown";
  const hasError = !raw;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "rounded-2xl border border-slate-800 bg-slate-900/80 p-6 text-slate-100 shadow-lg", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h2", { className: "text-lg font-semibold text-emerald-300", children: "Google account" }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "mt-1 text-sm text-slate-400", children: "Linked identity used for HomeFlow automations." }),
      hasError ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "mt-4 rounded-lg border border-red-500/40 bg-red-500/10 px-4 py-3 text-sm text-red-200", children: "No Google account data available. Run the Google Account tool and try again." }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("dl", { className: "mt-4 space-y-3 text-sm", children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dt", { className: "text-slate-400", children: "Name" }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dd", { className: "font-medium text-slate-100", children: name })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dt", { className: "text-slate-400", children: "Email" }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dd", { className: "font-mono text-emerald-200", children: email })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dt", { className: "text-slate-400", children: "Google ID" }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("dd", { className: "font-mono text-slate-300", children: subject })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-xs text-slate-500", children: "HomeFlow uses this information to personalize bookings and securely connect your Google account." })
  ] });
};
var ProReviewsView = ({ config, onAction }) => {
  const reviews = config.reviews ?? config.pro?.recentReviews ?? [];
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-5", children: [
    config.pro ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProCard, { pro: config.pro, onAction, layout: "expanded" }) : null,
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "space-y-3", children: reviews.length ? reviews.map((entry) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
      "div",
      {
        className: "rounded-2xl border border-slate-800 bg-slate-950/70 p-4 text-sm text-slate-100",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center justify-between text-xs text-slate-400", children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { children: entry.updatedAt?.slice(0, 16) ?? "Recent" }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("span", { className: "text-emerald-300", children: [
              "\u2605 ",
              entry.rating.toFixed(1)
            ] })
          ] }),
          entry.review ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("p", { className: "mt-2 text-sm", children: [
            "\u201C",
            entry.review,
            "\u201D"
          ] }) : null
        ]
      },
      `${entry.jobId}-${entry.updatedAt}`
    )) : /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "rounded-xl border border-slate-800 bg-slate-900/60 p-4 text-sm text-slate-300", children: "No reviews yet. Be the first to leave feedback after your booking." }) })
  ] });
};
var renderView = (config, viewMode, setViewMode, onAction, onBack, onSubmitRating) => {
  switch (config.view) {
    case "home":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(HomeView, { config, onAction });
    case "search":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SearchView, { config, viewMode, setViewMode, onAction })
      ] });
    case "slots":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SlotsView, { config, onAction })
      ] });
    case "quote":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(QuoteView, { config, onAction })
      ] });
    case "booking":
    case "update":
    case "cancelled":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        config.job ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobCardView, { job: config.job, onAction }) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Notifications, { items: config.notifications })
      ] });
    case "pro_reviews":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ProReviewsView, { config, onAction })
      ] });
    case "rate_form":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          RateFormView,
          {
            config,
            onAction,
            onSubmit: (jobId, rating, review) => onSubmitRating?.(jobId, rating, review)
          }
        )
      ] });
    case "account":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(AccountView, { config })
      ] });
    case "job_status":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(JobStatusView, { config, viewMode, setViewMode, onAction })
      ] });
    case "rate_job":
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-4", children: [
        onBack ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 text-sm text-slate-300 hover:text-emerald-300",
            onClick: onBack,
            children: "\u2190 Back"
          }
        ) : null,
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RateView, { config, onAction })
      ] });
    default:
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "rounded-xl border border-red-500/40 bg-red-500/10 p-4 text-sm text-red-200", children: config.description ?? "Something went wrong. Try again soon." });
  }
};
var App = () => {
  const baseConfig = useHomeflowConfig();
  useIsOpenAiAvailable();
  const displayMode = useOpenAiGlobal("displayMode");
  const viewKey = import_react40.default.useMemo(
    () => baseConfig.viewModes ? baseConfig.viewModes.join("|") : "",
    [baseConfig.viewModes]
  );
  const [viewMode, setViewMode] = import_react40.default.useState(() => baseConfig.defaultView ?? baseConfig.viewModes?.[0] ?? "list");
  const [isReady, setIsReady] = import_react40.default.useState(false);
  const [localConfig, setLocalConfig] = import_react40.default.useState(null);
  import_react40.default.useEffect(() => {
    setIsReady(false);
    const timer = window.setTimeout(() => setIsReady(true), 150);
    return () => window.clearTimeout(timer);
  }, [baseConfig.view, baseConfig.timestamp, viewKey]);
  import_react40.default.useEffect(() => {
    const initial = baseConfig.defaultView ?? baseConfig.viewModes?.[0] ?? "list";
    setViewMode(initial);
  }, [baseConfig.view, baseConfig.defaultView, viewKey]);
  import_react40.default.useEffect(() => {
    setLocalConfig(null);
  }, [baseConfig.view, baseConfig.timestamp]);
  const callToolAndHydrate = import_react40.default.useCallback(
    async (tool, params) => {
      const host = getHostApi();
      if (!host) {
        console.info("[HomeFlow] Host API unavailable. Tool requested:", tool, params);
        return void 0;
      }
      setIsReady(false);
      let nextConfig;
      try {
        const response = await host.callTool?.(tool, params ?? {});
        const maybeConfig = extractWidgetData(response) ?? extractWidgetData(response?.toolResult) ?? extractWidgetData(response?._meta);
        if (maybeConfig) {
          nextConfig = maybeConfig;
          setLocalConfig(maybeConfig);
          const nextDefault = maybeConfig.defaultView ?? maybeConfig.viewModes?.[0];
          if (nextDefault) {
            setViewMode(nextDefault);
          }
        }
      } catch (error) {
        console.error("[HomeFlow] Tool invocation failed", tool, error);
      } finally {
        setIsReady(true);
      }
      return nextConfig;
    },
    []
  );
  const handleAction = import_react40.default.useCallback(
    async (action) => {
      const host = getHostApi();
      if (!host) {
        console.info("[HomeFlow] Host API unavailable. Action requested:", action);
        return;
      }
      if (action.type === "tool") {
        await callToolAndHydrate(action.tool, action.params ?? {});
        return;
      }
      try {
        switch (action.type) {
          case "followup":
            if (host.sendFollowUpMessage) {
              await host.sendFollowUpMessage({ prompt: action.prompt });
            }
            break;
          case "link":
            if (action.external) {
              window.open(action.href, "_blank", "noopener");
            } else if (host.openExternal) {
              host.openExternal({ href: action.href });
            } else {
              window.location.href = action.href;
            }
            break;
          default:
            break;
        }
      } catch (error) {
        console.error("[HomeFlow] Failed to execute action", action, error);
      }
    },
    [callToolAndHydrate]
  );
  const submitRating = import_react40.default.useCallback(
    async (jobId, ratingValue, reviewValue) => {
      const host = getHostApi();
      if (!host?.callTool) {
        console.info("[HomeFlow] Host API unavailable. Cannot submit review.");
        return;
      }
      try {
        await host.callTool("rate_job", {
          job_id: jobId,
          rating: ratingValue,
          review: reviewValue
        });
      } catch (error) {
        console.error("[HomeFlow] Failed to submit rating", error);
        return;
      }
      await callToolAndHydrate("job_status", {});
    },
    [callToolAndHydrate]
  );
  const handleBack = import_react40.default.useCallback(() => {
    setLocalConfig(null);
    setViewMode(baseConfig.defaultView ?? baseConfig.viewModes?.[0] ?? "list");
  }, [baseConfig.defaultView, baseConfig.viewModes]);
  const handleExpand = import_react40.default.useCallback(async () => {
    const host = getHostApi();
    if (!host?.requestDisplayMode) return;
    try {
      await host.requestDisplayMode({ mode: "fullscreen" });
    } catch (error) {
      console.error("[HomeFlow] Failed to request fullscreen", error);
    }
  }, []);
  const handleShowAccount = import_react40.default.useCallback(async () => {
    const host = getHostApi();
    try {
      if (host?.callTool) {
        await host.callTool("google-account", {});
      }
    } catch (error) {
      console.error("[HomeFlow] Failed to refresh Google account", error);
    }
    const updatedConfig = await callToolAndHydrate("homeflow_home", {});
    setLocalConfig((previous) => {
      const base = updatedConfig ?? previous ?? baseConfig;
      const account = base.context?.account;
      if (!account || typeof account !== "object") {
        return updatedConfig ?? previous ?? baseConfig;
      }
      return { ...base, view: "account" };
    });
  }, [callToolAndHydrate, baseConfig]);
  const config = localConfig ?? baseConfig;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(MantineProvider, { defaultColorScheme: "dark", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "min-h-full space-y-5 rounded-3xl border border-slate-800 bg-black px-5 py-6 text-slate-100 shadow-xl backdrop-blur", children: !isReady ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "flex h-48 items-center justify-center text-sm text-slate-400", children: "Preparing HomeFlow\u2026" }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("header", { className: "flex flex-wrap items-start justify-between gap-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "space-y-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("h1", { className: "text-lg font-semibold text-slate-100", children: config.title }),
        config.subtitle ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-sm text-slate-300", children: config.subtitle }) : null,
        config.description ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: "text-sm text-slate-400", children: config.description }) : null,
        config.timestamp ? /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("p", { className: "text-xs uppercase tracking-wide text-slate-500", children: [
          "Updated ",
          config.timestamp.slice(0, 16)
        ] }) : null
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "flex items-center gap-3", children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 rounded-full border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-medium text-slate-200 hover:border-emerald-400 hover:text-emerald-300",
            onClick: handleShowAccount,
            title: "View Google account",
            children: "\u{1F464} Account"
          }
        ),
        displayMode !== "fullscreen" ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "button",
          {
            type: "button",
            className: "inline-flex items-center gap-2 rounded-full border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-medium text-slate-200 hover:border-emerald-400 hover:text-emerald-300",
            onClick: handleExpand,
            children: "\u2922 Expand"
          }
        ) : null
      ] })
    ] }),
    renderView(
      config,
      viewMode,
      setViewMode,
      handleAction,
      config.view !== "home" ? handleBack : void 0,
      submitRating
    )
  ] }) }) });
};
var container = document.getElementById(ROOT_ID);
if (container) {
  const root = (0, import_client.createRoot)(container);
  root.render(/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(App, {}));
}
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

mapbox-gl/dist/mapbox-gl.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/

  </script>
</body>
</html>